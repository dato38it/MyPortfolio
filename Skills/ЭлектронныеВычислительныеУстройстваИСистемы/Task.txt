Task:
Сколько времени занимает считывание диска с 800 цилиндрами,каждый из которых содержит 5 дорожек по 32сектора? Сначала считываются все сек-тора дорожки0,начиная с сектора0,затем все сектора дорожки1,начиная с сектора0 и т.д. Оборот совершается за 20мс, поиск между соседними цилиндрами занимает10мс, а в случае расположения считываемых данных в разных частях диска—до 50мс. Переход от одной дорожки цилиндра к другой происходит мгновенно.
Decision:
5дорожек *20мс= 100 мс –время считывания одного цилиндра.100мс *800=80с = t время считывания всех цилиндров
Время считывания диска будет лежать в пределах от t+tmin до t+tmax. Следовательно,считывание диска занимает от 87,99с до 119,95с2.
Task:
Система адресации LBA использует 24 битадля обращения к сектору. Каков максимальный объем диска,с которым она можетработать?
Decision:
2^24=16777216 кол-во секторов. Один сектор как правило содержит 512 Мбайт. Следовательно,максимальный объём дискасоставляет кол-во секторов*объём одного сектора =8589934592 Мбайт = 8388608Гбайт = 8192 Тбайт = 8 Пбайт
Task:
Чтобы вместить фильм длительностью 133 минуты на односторонний DVDс одним слоем, требуется небольшая компрессия. Вычислите, насколько нужно сжать фильм. Предполагается, что для записи дорожки изображения нужно 3,5 Гбайт, разрешающая способность изображения 720x480 пикселов с 24-битным цветом и в секунду меняется 30 кадров.
Decision:
Кол-во пикселей (разрешение) N= 720*480 = 345600
Размер одногокадра R=N*размер(вес) одного пикселя = 345600*24бит = 8294400бит = 1036800байт = 1012,5Кбайт
Размер одной секунды изображения V= R*30кадров = 30375Кбайт
Размер изображения фильма X= V*133*60c= 242392500Кбайт ≈ 231Гбайт
Фильм надо сжать на 231-3,5 = 227,5Гбайт, но обычно вычисляется величина отношение размеров (она более информативна). Следовательно, фильм необходимо сжать в 231/3,5 = 66 раз.
Task:
Предположим, что центральный процессор (CPU) содержит кэш-память первого и второго уровня со временем доступа 5нcи 10 нcсоответственно. Время доступа к основной памяти составляет 50нc.Если 20% от всех обращений к памяти приходится на долю кэш-памяти первого уровня, а 60%—на долю кэш-памяти второго уровня, то каково среднее время доступа?
Decision:
р1–вероятность при запросе оказаться в кэше первого уровня. р1= 1 т.к. при любом запросе мы сначала оказываемся на кэш-пямяти первого уровня.
р2–вероятность при запросе оказаться в кэше второго уровня. р2= 1 -0.2 = 0.8 кэш-память первого уровня обрабатывает только 20% запросов, остальные попадают в кэш-память второго уровня.
р3–вероятность при запросе оказаться в основной памяти. р3= р2–0.6 = 0.2 если запрос был не найден в кэш-памяти то он попадает в основную память.
<t> = t1*p1+ t2*p2+ t3*p3= 5нс*1 + 10нс*0.8 + 50нс*0.2 = 23нс
Task:
Компьютер содержит двухуровневую кэш-память. Предположим, что 80% обращений к памяти—удачные обращения в кэш-память первого уровня, 15%—в кэш-память второго уровня, а 5%—промахи кэша. Время доступа составляет 5нс, 15нс и 60нс соответственно, причем время доступа в кэш-память второго уровня и в основную память отсчитывается с того момента, как стало известно, что они нужны (например, доступ к кэш-памяти второго уровня не может начаться, пока не произойдет npoмаx кэш-памяти первого уровня). Каково среднее время доступа?
Decision:
Решение данной задачи аналогично решению задачи 5. Следовательно <t> = t1*p1+ t2*p2+ t3*p3=5нс*1 + 15нс*0.2 + 60нс*0.05 = 11нс
Task:
Вычислите логическое выражение (А & В) ˅ С для:
А -1101000010101101
В -111 1111100001111
С -0000000000100000
Task:
Компьютер имеет 16 страниц виртуального адресного пространства и только 4 страничных кадра. Изначально память пуста. Программа обращается к виртуальным страницам в следующем порядке: 0,7,2,7,5,8,9,2,4
Какие из обращений вызовут ошибку с алгоритмом LRU?
Какие из обращений вызовут ошибку с алгоритмом FIFO?
Decision:
ВС –виртуальная страница. О№ -номер ошибки(fault’а). Цифрами 1,2,3,4 обозначены номера заполненных страничных кадров
Task:
1% определенной программы отвечает за 50% времени выполнения этой программы. Сравните следующие три стратегии с точки зрения времени программирования и времени выполнения. Предположим, что для написания программы на языке С потребуется 10 0 человеко-месяцев, а программу на языке ассемблера написать в 10 раз труднее, но зато она работает в 4 раза эффективнее.
Вся программа написана на языке С.
Вся программа написана на ассемблере.
Программа сначала написана на С, а затем нужный 1% программы переписан на ассемблере.
Task:
Cisc- и Risc-архитектуры процессоров, их характернык признаки. Особенности Risc-процессоров и их влияние на производительность
Decision:
Справедливости ради стоит отметить, что эти две архитектуры определяют разновидности двух основных видов процессоров, при этом существуют еще менее распространенные архитектуры, например:
- архитектура MISC — эта архитектура свойственна нетребовательным процессорам устройств с минимальным набором команд, например: роутеры, миникомпьютеры, IoT и др.;
- архитектура VLIW — данная архитектура рассчитана для «очень длинных машинных команд», что по факту дает процессору возможность выполнять инструкции с несколькими параллельными операциями;
- виртуальная архитектура — это своеобразный вид архитектуры, который эмулируется на реальных компьютерах; под такой архитектурой работает Java-виртуальная машина (JVM) и .NET CIL;
- прочие специфические архитектуры, которые очень узко специализированы, иногда даже под конкретное устройство.
Сегодня же остановимся подробнее на самых популярных решениях и разберемся, чем отличаются RISC- и CISC-архитектуры между собой. Однако бытует мнение, что сегодня разница между этими архитектурами практически незаметна, по сравнению с периодом их возникновения. Со временем границы между этими архитектурами немного размылись, потому что в процессе своего развития они очень многое переняли друг от друга.
Архитектура CISC (Complex Instruction Set Computer) — это специальный тип архитектуры процессора, который, во-первых, поддерживает нефиксированную длину команд, а во-вторых, содержит внутри себя большое количество сложных инструкций процессора, которые могут выполнять большое количество действий.
Хочется сразу отметить, что архитектура CISC настолько популярна, что на ее основе выпускают много разных процессоров, и дать их точное описание сложно, так как они разнообразны по своим свойствам. Но попробовать дать описание философии, которую несет в себе архитектура CISC, можно.
Архитектура CISC предполагает:
- минимальное количество регистров общего характера;
- максимальный объем простых машинных инструкций;
- присутствие сложных инструкций, которые функционально напоминают операторы высокоуровневых языков программирования;
- различные варианты адресации инструкций;
- принятие различных форматов инструкций;
- присутствие возможности обрабатывать команды «регистр-память».
Применение архитектуры CISC делает компиляцию программ намного проще за счет уменьшения исполняемых модулей. Но такая архитектура имеет один существенный недостаток — она не дает реализовать новейшие подходы для ускорения работы процессоров, например, такие, которые позволяют организовать в процессоре в определенный момент времени несколько одновременно выполняемых инструкций.
Архитектура CISC с технической стороны выглядит намного сложнее, чем архитектура RISC, отсюда и вытекают ее плюсы и минусы, например:
- она является более «мощной», так как позволяет заменять несколько похожих простых инструкций на одну аналогичную, но сложную, при этом не дает возможность ускорять производительные процессы за счет внедрения новых технологий обработки инструкций;
- процессоры с архитектурой CISC будут немного дороже, чем процессоры с архитектурой RISC с аналогичными параметрами.
Наиболее яркими процессорами с такой архитектурой являются:
- х86 (IA-32);
- x86_64 (AMD64).
Архитектура RISC появилась уже после CISC, так как технологии шагнули вперед: открывались новые возможности, поэтому пришла необходимость что-то менять и в процессорах.
Многие разработчики стали замечать, что потенциал архитектуры CISC не использовался полностью, поэтому множество ее сложных инструкций просто оставались без дела. Плюс была явная сложность в правильном выборе нужной инструкции для компилирования конкретной программы — это также вводило в ступор. Поэтому было принято решение создать процессор с архитектурой, в основе которой будет находиться множество простых инструкций.
То есть основной подход архитектуры RISC заключается в том, чтобы заменить сложные инструкции набором простых, соответственно, сократить объем сложных команд для самого процессора. При этом «длина» простых инструкций является постоянной, а время на их выполнение примерно одинаковым. За счет этого в архитектуре RISC удалось внедрить процесс конвейеризации.
Конвейеризация процессора позволяет выполнять несколько инструкций одновременно, но в разных тактах. Объясним, как это работает, на примере работы кассы в супермаркете.
Допустим, чтобы покупатель совершил покупку на кассе, ему нужно выполнить 3 такта:
- Выложить товар на ленту.
- Оплатить товар через терминал.
- Сложить товар в свой пакет.
Без внедрения конвейеризации процесс будет происходить следующим образом: пока один покупатель не пройдет все три такта на кассе — следующий будет ждать. То есть, пока один покупатель не сложит свой оплаченный товар в пакет, другой не начнет выкладывать свой товар на ленту. Но если внедрить конвейеризацию, то все будет происходить по-другому.
Первый покупатель выкладывает товар на ленту и переходит ко второму такту — оплате через терминал. Пока он оплачивает, второй покупатель начинает выкладывать товар на ленту. Первый покупатель оплачивает товар и начинает складывать его в пакет. Пока он это делает, второй покупатель начинает оплачивать свой товар через терминал, а третий уже начинает выкладывать свой товар на ленту.
Точно так же происходит и с инструкциями в процессорах с архитектурой RISC. За счет конвейеризации архитектура RISC работает намного быстрее, чем архитектура CISC. Это заметно, даже если архитектура RISC должна выполнить 5-6 инструкций вместо одной в CISC.
Архитектуру RISC применяют ARM-процессоры. Кстати, в 2020-м году с большим отрывом по производительности среди всех суперкомпьютеров мира победил суперкомпьютер, который использовал в качестве своей «начинки» ARM-процессоры с архитектурой RISC.
Может возникнуть резонный вопрос: «Если архитектура RISC настолько хороша и работает быстрее, то почему ее не применяют во всех современных компьютерах?». Объясняется все очень просто: исторически так сложилось. То есть до какого-то времени в компьютерах применяли только архитектуру CISC, а это значит, что все старые и многие новые программы были написаны именно для этой архитектуры и они не будут работать в RISC. Огромное количество такого ПО является проприетарными программами, а это значит, что, для того чтобы они заработали в RISC — этого должны захотеть их создатели и, соответственно, их переделать.
В итоге получается, что если сейчас использовать компьютер с RISC-процессором, то для него будет очень ограниченное количество программного обеспечения, что доставит массу неудобств пользователям. Поэтому смену архитектуры разом должны захотеть и производители процессоров, и производители ПО. Пока до этого далеко, но все к этому идет.
Source:
1. https://codernet.ru/articles/drugoe/cisc_i_risc_proczessoryi_arxitektura_ierarxiya_raznovidnosti/
Task:
Факторы, виляющие на производительность процессора. Измерение производительности. MIPS и MFLOPS. Смеси команд их использование при оценке производительности.
Decision:
Высокая производительность МП (микропроцессора)– один из ключевых факторов в конкурентной борьбе производителей процессоров.
Производительность процессора напрямую связана с количеством работы, вычислений, которые он может выполнить за единицу времени.
Очень условно:- Производительность = Кол-во инструкций / Время
Мы будем рассматривать производительность процессоров на базе архитектур IA32 и IA32e. (IA32 with EM64T).
Факторы влияющие на производительность процессора:
- Тактовая частота процессора.
- Объем адресуемой памяти и скорость доступа к внешней памяти.
- Скорость выполнения и набор инструкций.
- Использование внутренней памяти, регистров.
- Качество конвейеризации.
- Качество предсказания переходов.
- Качество упреждающей выборки.
- Суперскалярность.
- Наличие векторных инструкций.
- Многоядерность.
Поскольку процессор имеет много различных электронных компонент, которые работают независимо, то для того, чтобы синхронизировать их работу, чтобы они знали, в какой момент надо начать работать, когда нужно выполнить свою работу и ждать, существует таймер, который посылает синхроимпульс. Частота, с которой посылается синхроимпульс – и есть тактовая частота процессора. Есть устройства, которые успевают две операции выполнить за это время, тем не менее, к этому синхроимпульсу работа процессора привязана, и, можно сказать, что если мы эту частоту увеличим, то мы заставим все эти микросхемы работать с большим напряжением сил и меньше простаивать.
Объем памяти - необходимо, чтобы памяти хватало для нашей программы и наших данных. То есть, технология EM64T позволяет адресовать огромное количество памяти и на данный момент вопрос с тем, что нам не хватает адресуемой памяти не стоит.
CISC,RISC (complex, reduced instruction set computing)
Современные процессоры Intel® представляют собой гибрид CISC и RISC процессоров, перед исполнением преобразуют CISC инструкции в более простой набор RISC инструкций.
По сути дела, когда архитекторы проектируют процессоры, они постоянно работают с целью улучшить его производительность. Одной из их задач является сбор статистики, для определения , какие инструкции или последовательности инструкций являются ключевыми с точки зрения производительности. Пытаясь улучшить производительность, архитекторы пытаются самые горячие инструкции сделать быстрее, для каких-то наборов инструкций сделать специальную инструкцию, которая заменит этот набор и будет работать эффективнее. От архитектуры к архитектуре изменяются характеристики инструкций, появляются новые инструкции, которые позволяют добиться лучшей производительности. Т.е. можно считать что от архитектуры к архитектуре базовый набор инструкций постоянно совершенствуется и расширяется. Но если вы не указываете на каких архитектурах будет выполняться ваша программа, то в вашем приложении будет задействован некий умолчательный набор инструкций, который поддерживают все последние микропроцессоры. Т.е. наилучшей производительности мы можем добиться только если будем четко специфицировать тот микропроцессор, на котором будет выполняться задача.
Регистры – самые быстрые элементы памяти, они находятся непосредственно на ядре, и доступ к ним практически мгновенный. Если ваша программа делает какие-то вычисления, хотелось бы, чтобы все промежуточные данные хранились на регистрах. Понятно, что это невозможно. Одна из возможных проблем производительности– это проблема вытеснения регистров. Когда вы под каким-нибудь анализатором производительности смотрите на ассемблерный код, вы видите, что у вас очень много движения со стека в регистры и обратно выгрузка регистров на стек. Стоит вопрос – как оптимизировать код так, чтобы самые горячие адреса, самые горячие промежуточные данные, лежали именно на системных регистрах.
Следующая часть памяти – это обычная оперативная память. С ростом производительности процессоров стало ясно, что самым узким местом производительности является доступ к оперативной памяти. Для того, чтобы добраться до оперативной памяти, нужны сотня, а то и две сотни тактов процессора. То есть, запросив какую-то ячейку памяти в оперативной памяти, мы будем ждать двести тактов, а процессор будет простаивать.
Существует две характеристики для описания свойств памяти – это время отклика, то есть число циклов процессора, необходимое для передачи единицы данных из памяти, и пропускная способность — сколько элементов данных могут быть отправлены процессором из памяти за один цикл. Встретившись с проблемой, что у нас узким местом является доступ к памяти, мы можем решать эту проблему двумя путями – либо уменьшением времени отклика, либо делать упреждающие запросы нужной памяти. То есть, в данный момент нам значение какой-то переменной неинтересно, но мы знаем, что оно скоро нам понадобится, и мы его уже запрашиваем.
Кэш-память служит для уменьшения времени доступа к данным.
Для этого блоки оперативной памяти отображаются в более быструю кэш-память.
Если адрес памяти находится в кэше – происходит "попадание" и скорость получения данных значительно увеличивается.
В противном случае – "промах" (cache miss)
В этом случае блок оперативной памяти считывается в кэш-память за один или несколько циклов шины, называемых заполнением строки кэш-памяти.
Можно выделить следующие виды кэш-памяти:
- полностью ассоциативная кэш-память (каждый блок может отображаться в любое место кэша)
- память с прямым отображением (каждый блок может отображаться в одно место)
- гибридные варианты (секторная память, память с множественно-ассоциативным доступом)
Множественно-ассоциативный доступ – по младшим разрядам определяется строка кэша, куда может отображаться данная память, но в этой строке может находиться только несколько слов основной памяти, выбор из которых проводится на ассоциативной основе.
Качество использования кэша – ключевое условие быстродействия.
Дополнительная информация: в современных IA32 системах размер кэш-линии 64 байта.
Уменьшение времени доступа было достигнуто введением кэш-памяти. Кэш-память – это буферная память, находящаяся между оперативной памятью и микропроцессором. Она реализована на ядре, то есть доступ к ней гораздо быстрее чем к обычной памяти, но она намного дороже, поэтому при разработке микроархитектуры нужно найти точный баланс между ценой и производительностью. Если вы посмотрите на описания предлагаемых в продаже процессоров, вы увидите, что всегда в описании пишется, сколько кэша памяти того или иного уровня на данном процессоре есть. Эта цифра серьезно влияет на цену данного изделия. Кэш-память устроена так, что обычная память отображается на кэш-память, отображение идет блоками. Вы, запрашивая в оперативной памяти какой-то адрес, делаете проверку, отображен ли этот адрес в кэш-памяти. Если этот адрес уже есть в кэш-памяти, то вы экономите время на обращение к памяти. Вы считываете эту информацию из быстрой памяти, и у вас время отклика существенно уменьшается, если же этого адреса в кэш-памяти нет, то мы должны обратиться к обычной памяти, чтобы этот необходимый нам адрес вместе с каким-то блоком, в котором он находится, отобразился в эту кэш-память.
Существуют разные реализации кэш-памяти. Бывает полностью ассоциативная кэш-память, когда каждый блок может отображаться в любое место кэша. Существует память с прямым отображением, когда каждый блок может отображаться в одно место, также существуют различные гибридные варианты – например кэш с множественно-ассоциативным доступом. В чем разница? Разница во времени и сложности проверки на наличие нужного адреса в кэш-памяти. Предположим, что нам нужен определенный адрес. В случае с ассоциативной памятью нам нужно проверить весь кэш – убедиться, что этого адреса в кэше нет. В случае с прямым отображением нам нужно проверить только одну ячейку. В случае с гибридными вариантами, например, когда используется кэш с множественно-ассоциативным доступом, нам нужно проверить, к примеру, четыре или восемь ячеек. То есть, задача определить есть ли адрес кэша – тоже важна. Качество использования кэша – важное условие быстродействия. Если нам удастся написать программу так, чтобы как можно чаще те данные, с которыми мы собирались работать, находились в кэше, то такая программа будет работать гораздо быстрее.
Характерные времена отклика при обращении к кэш памяти для Nehalem i7:
- L1 - latency 4
- L2 - latency 11
- L3 - latency 38
Время отклика для оперативной памяти > 100
Упреждающий механизм доступа к памяти реализован при помощи механизма упреждающей выборки (hardware prefetching).
Есть специальный набор инструкций, позволяющий побудить процессор загрузить в кэш память расположенную по определенному адресу (software prefetching).
Для примера возьмем наш последний процессор Nehalem: i7.
Здесь мы имеем не просто кэш, а некий иерархический кэш. Долгое время он был двухуровневый, в современной системе Nehalem он трехуровневый – совсем немного очень быстрого кэша, чуть побольше кэша второго уровня и достаточно большое количество кэша третьего уровня. При этом, эта система построена так, что если какой-то адрес находится в кэше первого уровня, он автоматически находится во втором и в третьем уровнях. Это и есть иерархическая система. Для кэша первого уровня задержка – 4 такта, для второго – 11, третьего – 38 и время отклика оперативной памяти – больше 100 тактов процессора.
Принцип локальности. Качество упреждающей выборки.
Локальность ссылки (locality of reference) – повторное использование переменных или взаимосвязанных данных. Различают временную локальность (temporal locality) – когда речь идет об одних и тех же данных и пространственную локальность (spatial locality) – использование различных данных, имеющих относительно близкие области хранения.
Механизм кэширования использует принцип временной локальности. (Стремится сохранять в кэше наиболее часто используемые данные).
Механизм упреждающей выборки использует принцип пространственной локальности. (Стремится определить закономерность в доступе к памяти, чтобы заранее подгружать в кэш необходимую память). При этом, чем выше пространственная локальность (элементы расположены ближе в памяти), тем меньше данных требуется загружать в кэш и меньше нагрузка на системную шину.
Кэш aliasing – из-за неудачного расположения в памяти различных объектов, участвующих в вычислении, происходит вытеснению из кэш памяти одних адресов другими.
Второй вариант улучшения быстродействия и работы с памятью, про который мы упомянули – это подкладывать в кэш заранее необходимые адреса – упреждающий механизм доступа к памяти (Hardware Prefetching). Этот механизм выявляет закономерности, с которыми вы обращаетесь к памяти, и заранее закачивает в кэш адреса, которые могут вам понадобиться. Если вы обрабатываете несколько массивов, движетесь по ним последовательно или с каким-то постоянным шагом, то, скорее всего, этот механизм начнет эти адреса заранее подгружать. Есть специальный набор инструкций, позволяющий загрузить в кэш память, расположенную по определенному адресу. (Software Prefetching)
Кэш имеет внутренние алгоритмы работы. Введем несколько понятий.
Локальность ссылки – переиспользование переменных или взаимосвязанных данных. Различают временную локальность – переиспользование определенных данных и ресурсов и пространственную локальность - использование данных, имеющих относительно близкие области хранения.
Механизм кэширования использует механизм временной локальности. Он пытается отследить те адреса, которые чаще всего используются, и сохранять их в кэше, а те, которые больше не используются – из кэша удалять. То есть каждый раз, когда вы запрашиваете из памяти какой-то новый адрес, механизм кэширования оценивает, какие блоки у него есть, какой из имеющихся у него блоков давно не использовался, и удаляет этот блок, заменяя его на новый. Этот механизм пытается сохранять только те данные, с которыми ведется активная работа.
Механизм упреждающей выборки использует принцип пространственной локальности, то есть подгружает соседние элементы.
При работе механизма кэширования могут происходить неприятные моменты. Например, вы работаете с двумя массивами, но они расположены в памяти так, что взяв адреса одного массива, которые вам нужны, вы вытесняете из кэша адреса другого массива, которые будут вам нужны. Формально, ничего не мешает расположить эти массивы в памяти по-другому и избежать этой проблемы.
Конвейеризация предполагает, что последовательные инструкции будут перекрываться при выполнении.
Выполнение типичной команды можно разделить на следующие этапы:
- выборка команды – IF;
- декодирование команды / выборка операндов из регистров - ID;
- выполнение операции / вычисление эффективного адреса памяти - EX;
- обращение к памяти - MEM;
- запоминание результата - WB.
Конвейеризация улучшает пропускную способность процессора, но если инструкции зависят от результатов выполнения предыдущих инструкций, то возникают задержки. Таким образом, польза от конвейеризации определяется уровнем инструкционного параллелизма.
- Качество конвейеризации.
Было время, когда процессор выполнял одновременно одну инструкцию. После введения конвейеризации процесс обработки инструкции разбит на несколько этапов. Один из вариантов, который широко используется, приведен:
- выборка команды;
- декодирования команды;
- выполнение операции;
- обращение к памяти;
- запоминание результатов.
Использование конвейера позволяет процессору одновременно обрабатывать несколько инструкций. Это невозможно в случае если инструкция зависит от результатов другой, поэтому чем больше у вас независимых инструкций, тем лучше работает конвейер. Если у вас все инструкции не зависят от результатов предыдущих, то он должен работать оптимально.
Измерение производительности – довольно сложная тема. Как вы должны были догадаться из предыдущих рассуждений производительность зависит от двух факторов: от непосредственной качественной работы микропроцессора (МП) и от качества работы оптимизирующего компилятора. То есть качество работы оптимизирующего компилятора влияет непосредственно на результаты измерения производительности. Есть специальная организация – Standard Performance Evaluated Corporation — некоммерческая организация, которая делает аудиторскую независимую оценку производительности разных вычислительных систем. Она занимается сбором типичных задач, предоставляет своим пользователям некую универсальную систему тестирования и гарантирует независимое мнение о производительности микропроцессоров.
Соответственно, если вас интересует вопрос о производительности, вы можете зайти на сайт этой организации, заплатить небольшие деньги и скачать оттуда пакет для измерения производительности, получить доступ к двум различным вычислительным системам, взять этот пакет, инсталлировать его. Пакет позволяет построить и прогнать специальные программы, получить цифры и сказать: "с использованием представительной выборки задач из сюиты такой-то мы получили результат, что вот эта система в таких-то задачах эту систему превосходит, а на таких задачах немного проигрывает". В мире существуют аналитики, которые на этом зарабатывают деньги. Перед публикацией в научных компьютерных журналах своих отчетов, они используют этот пакет. Есть различные пакеты CPU2006, OMP2001 и так далее для тестирования различных аспектов производительности. Поскольку производительность зависит от микропроцессора и от компилятора, то компилятор — это важная часть в борьбе за признание высокой производительностей изделий. Если появляется новый микропроцессор, которые реализует какие-то новые команды, трудно показать улучшение его производительности из-за этих команд если не будет компилятора способного использовать эти команды в исполняемой программе. Другой фактор влияния компилятора на производительность связан с тем, что если в процессе эксплуатации процессора обнаружены какие-то инструкции, которые на процессоре почему-либо выполняются медленно, то с помощью компилятора мы можем каким-то образом заменить плохие инструкции на хорошие. Компилятор также активно используется при тестировании и разработке новых архитектур.
Т.е. с точки зрения разработки и продвижения процессоров компилятор очень важный инструмент.
Можно провести некую аналогию на использование компилятора. Например, выполнение какой-то расчетной задачи мы можем сравнить с прохождением человеком некоего маршрута по пересеченной местности из точки А в точку В. Примерную схему маршрута и контрольные точки определил разработчик, написавший алгоритм и запрашивающий результаты рассчетов. Процессор в данном случае будет отвечать за физические кондиции того человека, который пойдет через лес. То есть он может быть очень сильный и может идти по ровной местности со скоростью 6 км/ч. Другой процессор может идти со скоростью 5 км/ч. А дальше вопрос стоит в выборе маршрута. Умный компилятор найдет места, где мы можем срезать путь и пойти более короткой дорогой. Формально, может случиться так, что процессор, который обеспечивает меньшую скорость, за счет компилятора данную задачу по перемещению из точки А в точку В выполнит быстрее.
С подходом, основанным на сравнении производительности микропроцессоров по их рабочим частотам, тесно связан подход по оценке производительности системы по тому, насколько быстро система может выполнять команды процессора.
Однако это весьма расплывчатый показатель. Скорость работы процессора, обычно выражаемая в миллионах операций в секунду (millions of INsTRuctions per second - MIPS ), сильно привязана к его тактовой частоте.
Кроме того, оценка производительности в MIPS существенно зависит от системы команд микропроцессора: одна команда в микропроцессоре одного типа может быть эквивалентна по вычислительной мощности нескольким командам другого МП. К тому же различные операции, особенно в CISC-микропроцессорах, требуют разного времени для их выполнения. Следовательно, MIPS -оценка существенно зависит от того, какие команды принимаются в расчет. Таким образом, MIPS является полезным показателем лишь при сравнении процессоров одного производителя. Такие процессоры должны поддерживать одинаковую систему команд. Кроме того, следует применять одинаковые компиляторы. Существенная слабость MIPS как показателя производительности часто являлась поводом для шутки: MIPS - это аббревиатура выражения "MeanINgless INdicator of Processor Speed" ("бессмысленный показатель скорости процессора").
Аналогичным подходом является измерение производительности работы процессора в миллионах операций с плавающей точкой в секунду (millions of floatINg-poINT operations per second - MFLOPS ). Обычно скорость в MFLOPS вычисляют для смеси операций сложений и умножений с плавающей точкой. Но поскольку микропроцессоры становятся все быстрее и быстрее, значение максимума MFLOPS перестает быть полезным в качестве разумной меры производительности операций с плавающей точкой: ограничивающим фактором становится пропускная способность каналов памяти (насколько быстро данные можно перемещать из процес сора и в процессор).
Source:
1. https://intuit.ru/studies/courses/707/563/lecture/12566
2. https://intuit.ru/studies/courses/604/460/lecture/10355
Task:
Способы адресации. Формирование исполнительного адреса операнда при относительной адресации с помощью базирования. Использование базирования при организации виртуальной памяти.
Decision:
Следует различать понятия «адресный код в команде Ак» и «исполнительный (физический адрес) адрес Аи».
- Адресный код — это информация об адресе операнда, содержащаяся в команде.
- Исполнительный адрес — это номер ячейки памяти, к которой производится фактическое обращение.
Таким образом, способ адресации можно определить как способ формирования исполнительного адреса операнда Аи по адресному коду команды Ак.
В системах команд современных ЭВМ часто предусматривается возможность использования нескольких способов адресации операндов для одной и той же операции. Для указания способа адресации в некоторых системах команд выделяется специальное поле в команде — поле «метод» (указатель адресации, УА), рис. 4.13, а.
В этом случае любая операция может выполняться с любым способом адресации, что значительно упрощает программирование.
Классификация способов адресации по наличию адресной информации в команде:
- явная адресация - в команде есть поле адреса этого операнда, в котором задается адресный код Ак. Большинство методов адресации являются явными;
- неявная адресация - адресное поле в команде отсутствует, адрес операнда подразумевается кодом операции..
Классификация способов адресации по кратности обращения в память. Широко используются следующие методы адресации операнда с различной кратностью обращения (г) в память:
Непосредственная адресация операнда (/*= 0) - Обращение к регистровой памяти (РП) или ОП не производится (R = 0). Таким образом уменьшается время выполнения операции, сокращается объем памяти; 
Прямая адресация операндов (r= 1) - При этом способе (рис. 4.13) адресации обращение за операндом в РП или ОП производится по адресному коду в поле команды, т.е. исполнительный адрес операнда совпадает с адресным кодом команды (Аисп = Ак). Обеспечивая простоту программирования, этот метод имеет существенные недостатки, так как для адресации к ячейкам памяти большой емкости требуется «длинное» адресное поле в команде;
Косвенная адресация операндов (г> 2). Адресный код команды указывает адрес ячейки памяти, в которой находится не сам операнд, а лишь адрес операнда, называемый указателем операнда. Адресация к операнду через цепочку указателей (косвенных адресов) называется косвенной. Адрес указателя остается неизменным, а косвенный адрес может изменяться в процессе выполнения программы. Это обеспечивает переадресацию данных, т.е. упрощает обработку массивов и списковых структур данных, упрощает передачу параметров подпрограммам, но не обеспечивает перемещаемость программ в памяти (рис. 4.15, а).
Source:
1. https://studref.com/660861/informatika/struktura_formaty_komand
Task:
Формат команды микропроцессора. Назначение основных полей команды. Особенности основных тиопв команд: 1-, 2- и 3-адресных.
Decision:
По характеру выполняемых операций различают следующие основные группы команд:
- команды арифметических операций над числами с фиксированной и плавающей точками;
- команды десятичной арифметики;
- команды логических операций и сдвигов;
- команды передачи кодов;
- команды операций ввода/вывода;
- команды передачи управления;
- команды векторной обработки;
- команды задания режима работы машины и др.
Форматом команды называют ее структуру с разметкой номеров разрядов (битов), определяющих границы отдельных полей команды, или с указанием числа битов в определенных полях.
Важной и сложной проблемой при проектировании вычислительных машин является выбор структуры и форматов команды, т.е. ее длины, назначения и размерности отдельных ее полей. Естественно стремление разместить в команде в возможно более полной форме информацию о предписываемой командой операции. Однако в условиях, когда в современных ЭВМ значительно возросло число выполняемых различных операций и соответственно команд (в системе команд х86 более 500 команд) и значительно увеличилась емкость адресуемой основной памяти (4, 6 Гбайт), это приводит к недопустимо большой длине формата команды.
Действительно, число двоичных разрядов, отводимых под код операции, должно быть таким, чтобы можно было представить все выполняемые машинные операции. Если ЭВМ выполняет Мразличных операций, то число разрядов в коде операции
- nкоп>=log2(M)
Например, при М= 500 якоп = 9.
Если основная память содержит S адресуемых ячеек (байтов), то для явного представления только одного адреса необходимо в команде иметь адресное поле для одного операнда с числом разрядов
- nA>=log2(S)
Например, при 5=4 Гбайт пА = 32.
Отмечавшиеся ранее характерные для процесса развития ЭВМ расширение системы (наборы) команд и увеличение емкости основной памяти, а особенно создание микроЭВМ с коротким словом, потребовали разработки методов сокращения длины команды. При решении этой проблемы существенно видоизменилась структура команды, получили развитие различные способы адресации информации.
Проследим изменения классических структур команд.
Чтобы команда содержала в явном виде всю необходимую информацию о задаваемой операции, она должна, как это показано на рис. 4.12, б, содержать следующую информацию:
- Aj, A2 — адреса операндов;
- A3 — адрес результата;
- A4 —адрес следующей команды (принудительная адресация команд). Такая структура приводит к большой длине команды (например, при М= 500, S = 4 Гб длина команды — 137 бит) и неприемлема для прямой адресации операндов основной памяти. В компьютерах с RISC-архитектурой четырехадресные команды используются для адресации операндов, хранящихся в регистровой памяти процессора.
Можно установить, что после выполнения данной команды, расположенной по адресу К (и занимающей L ячеек), выполняется команда из (К + Т)-й ячейки. Такой порядок выборки команды называется естественным. Он нарушается только специальными командами передачи управления. В таком случае отпадает необходимость указывать в команде в явном виде адрес следующей команды.
В одноадресной команде (рис. 4.12, д) подразумеваемые адреса имеют уже и результат операции, и один из операндов. Один из операндов указывается адресом в команде, в качестве второго используется содержимое регистра процессора, называемого в этом случае регистром результата или аккумулятором. Результат операции записывается в тот же регистр. Наконец, в некоторых случаях возможно использование безадресных команд (рис. 4.12, е), когда подразумеваются адреса обоих операндов и результата операции, например при работе со стековой памятью.
В трехадресной команде (рис. 4.12, в) первый и второй адреса указывают ячейки памяти, в которых расположены операнды, а третий определяет ячейку, в которую помещается результат операции. Можно условиться, что результат операции всегда помещается на место одного из операндов, например первого. Получим двухадресную команду (рис. 4.12, г), т.е. для результата используется подразумеваемый адрес.
Source:
1. https://studref.com/660861/informatika/struktura_formaty_komand
Task:
Типовая структура микропроцессора и ее основные блоки
Decision:
В данном случае под структурой следует понимать не только набор компонентов рабочей системы, но и средства соединения между ними, а также устройства, обеспечивающие их взаимодействие. Как и в функциональной классификации, содержание структуры можно выразить через три оставляющих – операционное наполнение, средства коммуникации с шиной и управляющую инфраструктуру.
Устройство операционной части определяет характер декодирования команд и обработки данных. В этот комплекс могут входить арифметико-логические функциональные блоки, а также резисторы для временного хранения информации – в том числе о состоянии микропроцессора. В логической структуре предусматривается использование 16-разрядных резисторов, которые выполняют не только логические и арифметические процедуры, но и операции сдвига. Работа регистров может быть организована по разным схемам, определяющим в том числе их доступность программисту. Отдельный регистр отводится для обеспечения функции аккумуляторного блока.
Устройства сопряжения с шиной отвечают за соединения с периферийной аппаратурой. В спектр их задач также входит осуществление выборки данных из памяти и формирование очереди команд. В типовую структуру микропроцессора входит указатель IP-команд, сумматоры адресов, сегментные регистры и буферы, посредством которых обслуживаются связки с шинами адреса.
Управляющее устройство, в свою очередь, формирует управляющие сигналы, выполняет дешифровку команды, а также обеспечивает работу вычислительной системы, отдавая микрокоманды по внутренним операциям МП.
В упрощенной структуре данного микропроцессора предусматриваются две функциональные части:
Операционная. В этот блок входят средства управления и обработки данных, а также микропроцессорная память. В отличие от полной конфигурации, структура базового микропроцессора исключает наличие сегментных регистров. Некоторые исполнительные устройства объединяются в один функциональный блок, что также подчеркивает оптимизированный характер данной архитектуры.
Интерфейсная. В сущности, средство обеспечения связи с главной магистралью. В этой части содержатся регистры внутренней памяти и сумматор адреса.
На внешних выводных каналах базовых МП часто используется принцип мультиплексирования сигналов. Это означает, что передача сигналов происходит по общим каналам с разделением времени. Помимо этого, в зависимости от текущего режима функционирования системы один и тот же вывод может применяться для передачи сигналов разного назначения.
Source:
1. https://abc-import.ru/jelektronika/5397-klassifikacija-i-struktura-mikroprocessorov/#:~:text=%D0%92%20%D1%82%D0%B8%D0%BF%D0%BE%D0%B2%D1%83%D1%8E%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%83%20%D0%BC%D0%B8%D0%BA%D1%80%D0%BE%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80%D0%B0%20%D0%B2%D1%85%D0%BE%D0%B4%D0%B8%D1%82,%D0%BC%D0%B8%D0%BA%D1%80%D0%BE%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D1%8B%20%D0%BF%D0%BE%20%D0%B2%D0%BD%D1%83%D1%82%D1%80%D0%B5%D0%BD%D0%BD%D0%B8%D0%BC%20%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D1%8F%D0%BC%20%D0%9C%D0%9F
Decision:
https://github.com/David138it/MyPortfolio/tree/main/TaskDecision/Engineer-Isu/Engineer/ЭлектронныеВычислительныеУстройстваИСистемы/
Task:
Соотнесите знаки оформления с их значением
Decision:
! - "НЕ"
|| - "ИЛИ"
&& - "И"
Task:
Какие значения соответствуют "истинно" и "ложно"?
Decision:
-+ и —
-1 и -1
+1 и 0
-0 и 1
Task:
В каком случае утверждение с операндом "&&" при переменных А и В верно?
Decision:
-Если верно либо А, либо В
-Если и А, и В не верны
-Строго если верно А
+Если верны и А, и В
Task:
((X > Y) && ( X <= Z)) = 1 при каких значениях X, Y и Z?
Decision:
-X = 0, Y = 0, Z = 0
-X = 0, Y = 0, Z = 1
-X = 0, Y = 1, Z = 0
-X = 0, Y = 1, Z = 1
-X = 1, Y = 0, Z = 0
+X = 1, Y = 0, Z = 1
-X = 1, Y =1, Z = 0
-X = 1, Y = 1, Z = 1
Task:
((( X != Y) != Z) || X) = 0 при каких значениях X, Y и Z?
Decision:
+X = 0, Y = 0, Z = 0
-X = 0, Y = 0, Z = 1
-X = 0, Y = 1, Z = 0
+X = 0, Y = 1, Z = 1
-X = 1, Y = 0, Z = 0
-X = 1, Y = 0, Z = 1
-X = 1, Y = 1, Z = 0
-X = 1, Y = 1, Z = 1
Task:
В каком случае утверждение с операндом "!=" при переменных А и В верно?
Decision:
-Если и А, и В верны
-Если и А, и В не верны
-Если верно либо А, либо В
+Если А и В неодинаковы
Task:
(X && !Y) = 1 при каких значениях Х и Y?
Decision:
-X = 0, Y = 0
-X = 0, Y = 1
+X = 1, Y = 0
-X = 1, Y = 1
Task:
Какой элемент ветвления выполняет все неконтролируемые ситуации?
Decision:
-if
-else — if
+else
-Ветвление всегда контролирует все ситуации
Task:
В какой последовательности сформирована конструкция ветвления?
Decision:
-else — if — else if
-else if — if — else
-if — else — else if
+if — else if — else
Task:
В каких случаях утверждение с операндом ">=" при переменных А и В верно?
Decision:
-Если верно А или B
-Если A и В неодинаковы
-Если B больше А
-Если А и В одинаковы
+Если А истинно
Task:
В каком из случаев утверждение A > В верно?
Decision:
+Если А истинно, а B != A
-Если A и В неодинаковы
-Если А и В одинаковы
-Если А истинно
Task:
((X && Y) != (X | | Y )) = 0 при
Decision:
? Х = 0, Y = 0
? Х = 0, Y = 1
? Х = 1, Y = 0
? Х = 1, Y = 1
Task:
(!(!(!X == Y))) = 1 при
Decision:
-Х = 0, Y = 0
Х = 0, Y = 1
+Х = 1, Y = 0
-Х = 1, Y = 1
Task:
((X < Z) && Y) = 0 при
Decision:
+X = 0, Y = 0, Z = 0
+X = 0, Y = 0, Z = 1
+X = 0, Y = 1, Z = 0
-X = 0, Y = 1, Z = 1
+X =1, Y = 0, Z = 0
+X = 1, Y = 0, Z = 1
+X = 1, Y = 1, Z = 0
+X = 1, Y = 1, Z = 1
Task:
((X != Y) && ((Z != Z) || (!X <= Z))) = 1 при
Decision:
?X = 0, Y = 0, Z = 0
?X = 0, Y = 0, Z = 1
?X = 0, Y = 1, Z = 0
?X = 0, Y = 1, Z = 1
?X = 1, Y = 0, Z = 0
?X = 1, Y = 0, Z = 1
?X = 1, Y = 1, Z = 0
?X = 1, Y = 1, Z = 1