Mail for feedback: David138it@gmail.com

1c, База данных "Практическое пособие разработчика"
	Task:
	В качестве конфигурации для разработки использовать базу, полученную в результате решения тестового примера по книге Радченко М.Г.
	Необходимо доработать конфигурацию так, чтобы обеспечить расчет вознаграждения мастеру за оказанные им услуги при проведении документа «Оказание услуг». Вознаграждение высчитывается как процент от общей суммы, предоставленных по данному документу услуг (без учёта проданных товаров) и составляет:
	5%    сумма меньше 1 000 руб.
	10%    сумма от 1 000 до 5 000 руб.
	15%    сумма больше 5 000 руб.
	Требуется разработать структуру данных для хранения накопленного вознаграждения.
	Разработать отчет, позволяющий получить общие суммы вознаграждений по каждому мастеру за произвольно выбранный период.
	Пример отчета:
	Период: 01.01.2013 – 15.05.2013
	Мастер    Сумма
	Иванов Иван    1000
	Петров Пётр    1500
	Task:
	План видов характеристик
	Task:
	Анализ производительности
	Добавим в диалог кнопку, которую программа будет для каждой строки документа получать из справочника цену товара, подставлять ее в строку и пересчитывать сумму. Добавим неовую комаанду Сделать с флажком Изменяет сохраняемые данные.
	Decision:
	    конфигруатор-документы-поступление товаров-формаДокументов-командная панель-команды-добавить-имя:сделать-флажок:изменяет сохраненные данные-перетаскиваем в командную панель команду-действие-добавить-
	&НаКлиенте
	Процедура ТоварыЦенаПриИзменении(Элемент)
	    Стр=Элементы.Товары.ТекущиеДанные;
	    РасчетСтроки(Стр);
	    //Стр=Элементы.Товары.ТекущиеДанные;
	    //ПроцедурыДокументов.РассчетСтроки(Стр);
	КонецПроцедуры
	&НаКлиенте
	Процедура ТоварыКоличествоПриИзменении(Элемент)
	    Стр=Элементы.Товары.ТекущиеДанные;
	    РасчетСтроки(Стр);
	    //Стр=Элементы.Товары.Стр;
	    //ПроцедурыДокументов.РассчетСтроки(Стр);
	КонецПроцедуры
	&НаКлиенте
	Процедура РасчетСтроки(ТекСтр)
	    ТекСтр.Сумма=ТекСтр.Цена*ТекСтр.Количество;
	КонецПроцедуры
	&НаКлиенте
	Процедура ТоварыСуммаПриИзменении(Элемент)
	    Стр=Элементы.Товары.ТекущиеДанные;
	    Если Стр.Количество = 0 Тогда
	        Сообщить("Ошибка");
	    Иначе
	        Стр.Цена=Стр.Сумма/Стр.Количество;
	    КонецЕсли
	КонецПроцедуры
	&НаКлиенте
	Процедура ТоварыНоменклатураПриИзменении(Элемент)
	    Стр=Элементы.Товары.ТекущиеДанные;
	    Стр.Цена=ПолучитьЦену(Стр.Номенклатура);  
	    РасчетСтроки(Стр);
	КонецПроцедуры
	&НаСервереБезКонтекста
	Функция ПолучитьЦену(Товар)
	    //Возврат Товар.Цена;    //{{КОНСТРУКТОР_ЗАПРОСА_С_ОБРАБОТКОЙ_РЕЗУЛЬТАТА
	    // Данный фрагмент построен конструктором.
	    // При повторном использовании конструктора, внесенные вручную изменения будут утеряны!!!         
	    Запрос = Новый Запрос;
	    Запрос.Текст =
	        "ВЫБРАТЬ
	        |    Номенклатура.Цена
	        |ИЗ
	        |    Справочник.Номенклатура КАК Номенклатура
	        |ГДЕ
	        |    Номенклатура.Ссылка = &Ссылка";               
	    Запрос.УстановитьПараметр("Ссылка", Товар);            
	    РезультатЗапроса = Запрос.Выполнить();                   
	    ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();        
	    Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
	        // Вставить обработку выборки ВыборкаДетальныеЗаписи
	    КонецЦикла;                                                 
	    //}}КОНСТРУКТОР_ЗАПРОСА_С_ОБРАБОТКОЙ_РЕЗУЛЬТАТА
	КонецФункции
	&НаКлиенте
	Процедура Сделать(Команда)
	    Для каждого Стр Из Объект.Товары Цикл
	        Стр.Цена=ПолучитьЦену(Стр.Номенклатура);
	        РасчетСтроки(Стр);
	    КонецЦикла;
	КонецПроцедуры
	Task:
	Точка останова
	понять, как работает механзим получения цены и номенклатуры из справочника (в форме документы, форма докмента)
	Decision:
	установить точку останова на интересующую строку содержимого этой процедуры. В нашем случае, поставим точку в первой строке (Стр=Элементы.Товары.ТекущиеДанные;) процедуры:
	&НаКлиенте
	Процедура ТоварыНоменклатураПриИзменении(Элемент)
	    Стр=Элементы.Товары.ТекущиеДанные;
	    Стр.Цена=ПолучитьЦену(Стр.Номенклатура);  
	    РасчетСтроки(Стр);
	КонецПроцедуры
	запускаем в обычном пользовательском режиме - пробуем создать новую номенклатуру в поступлении товаров - увидим что в конфигураторе появится стреллочка - можем перемещаться по коду нажимая f11 или shift+f10
	Task:
	Сервис при программировании. Шаблоны текста
	Включить шаблоны
	Decision:
	Меню:Конфигуратор-Сервис-Параметры
	Task:
	Увидеть шаблоны
	Decision:
	Меню-сервис-Шаблоны текста
	Task:
	Выбрать шаблоны
	Decision:
	Действия-настройка шаблонов
	Task:
	Создание ролей и описание прав пользоавтелей
	Decision:
	справочник номенклатура - создадим новый элемент справочника - в документе выбрать этот товар в табличную часть - запишем документ (т.е. купим товар) - вернемся в справочник номенклатура - удалим его совсем - В результате будет битая ссылка. Это не правильно.
	    пометить на удаление товар - главное меню - все функции - стандартные - удаление помеченных объектов
	Task:
	Создадим в нашей конфигурации роль для себя - "полные права"
	Decision:
	    Конфигурация-общие-роли-Имя:ПолныеПрава-добавить-права:отметить все элементы-действия:установить все права-
	Task:
	Мы ведь собираемся создавать новые объекты, и у старых появятся со временем новые реквизиты и табличные частицы поэтому еще добавим
	Decision:
	    -флажок:устанавливать права для новых объектов-флажок:Устанавливать права для реквизитов и табличчных частей по умолчанию-
	Task:
	Для роли ПОЛНЫЕ ПРАВА, чтобы пользователь не смог удалять элемент справочника из базы без проверки ссылочной целстности базы.
	Decision:
	    -справочники,документы-снять флажок-интерактивное удаление-меню-конфигурация-обновить конфигурацию БД
	Task:
	Добавим нового пользователя
	Decision:
	    меню-администрирование-пользователи-добавить-Имя:Администратор-прочие-флажок:полные права
	Теперь можно выйти и войти под учеткой. И удалить новый товар не получится, такая функция просто исчезнет с меню "Еще"
	Task:
	Активные пользователи
	посмотреть работающих сейчас пользователей БД
	Decision:
	    меню-администрирование-активные пользователи.
	Попросить их выйти из БД можно, воспользовавшись механизмом конфигурации или службой администирования серверов, которая инсталируется в каталог программных файлов (1СV7 servers.msc) и позваляет отключать соединения с БД.
	Task:
	Журнал регистрации
	Настроим конфигуратор так, чтобы журнал велся, регистрировать некие события в нем:
	Decision:
	    меню-администрирование-настройка журнала регистрации-флажок:регистрировать ошибки, предупреждения, информацию, примечания
	Task:
	События пользователя можно посмотреть в
	Decision:
	    меню-администрирование-журнал регистрации
	Task:
	Выгрузка и загрузка БД
	Выгрузить из конфигурации. В момент выгрузки в БД не должны работать пользователи
	Decision:
	    меню-администрирование-выгрузить БД-расширение .dt
	Task:
	Загрузить в конфигурацию
	Decision:
	меню-администрирование-загрузить БД-расширение .dt
	Task:
	Конфигурация БД
	в базе сидит огромное предприятие, все работают и одному пользователю повезло залезть туда, где вы допустили ошибку. одному ему она мешает, а остальные даже о ней не догадываются. Чтобы всех с БД не выгонять, нужно:
	Decision:
	    исправить ошибку - обновить динамически- и одного попросить выйти из программы - заново войти
	Task:
	Тестирование и исправление БД
	Когда мы удалили элементы, осталась битая ссылка. Нужно это исправлять. Когда нет пользователей в БД можно выполнить тестирование и исправление БД.
	Decision:
	    меню-администрирование-тестирование и исправление-поставим везде флажки-в двух колонках отметим создавать объекты-выполнить
	Запустим конфигуратор - посмотрим, что изменилось в элементе, которую мы оставили с битой ссылкой
	Task:
	Лечение файловой БД
	Если после сбоя совсем все плохо и вас даже не пускают в конфигуратор, можно восппользоваться программой проверки физической целостности файла БД называется chdbfl.exe. он позваоляет восстановить БД
	Decision:
	    указывается расположение БД - исправлять ошибки - выполнить
	Task:
	Константы
	Решили мы продать конфигурацию предприятию, которое торгует услугами. И нет у них складов, и просят они убрать эти склады.
	Decision:
	Для того чтобы убрать надо убрать из главного окна, убрать из всех документов, из всех отчетов. Проще не убрать, а скрыть по флажку. Этот флажок и бдет храниться в константе.
	    конфигурация-добавить константу-УчетПоСкладам-тип:булево-Представление:использовать стандартные команды-конфигурацияобщие-подсистемы-сервис-состав:открыть-флаг:УчетПоСкладам
	Task:
	Функциональные опции
	В примере учет по складам мы можем установить конфигурацию разным предприятиям. Некоторые из них имеют несколько складов, и учет в разрезе складов им обяазательно нужен. Некоторые могу завести этот один склад и во всех документах его выбирать, а во всех отчетах ео видеть, но не хотят. Поэтому нужно предусмотреть режим, при котором с панели навигации должна убраться ссылка открытия справочника "Склады", а из документов поле ввода для выбора склада.
	Decision:
	    Конфигурация-общие-функциональные опции-добавить-имя:УчетПоСкладам-хранение:указывыаем нашу константу УчетПоСкладам-состав-помечаем флажками там где есть связь со складом
	Decision:
	В пользовательском интерфейсе вся информация о складах исчезнет
	Task:
	Создание механизма компоновки данных
	Добавим в нашу конфигурацию отчет, который позволит распечать список справочника "номенклатура". Мы хотим напечатать не весь справочник, а с нужной сортировкой.
	Decision:
	    Конфигурация-отчеты-добавить-имя,синонимы:ПрайсЛист-подсистемы-продажи-основные-открыть схему компоновки данных-добавить набор данных запрос-
	    -конструктор запроса-таблицы-справочники-номенклатура > - код >, изготовитель >, наименование >, цена > - ок - поле - флажок "Цена" - поменяем на "Цена продажи"
	Task:
	Группировка отчета
	Нужно описать какие в отчете будут группировки.вывести все строки, которые есть в справочнике
	Decision:
	    Конфигурация-отчеты-добавить-имя,синонимы:ПрайсЛист-подсистемы-продажи-основные-открыть схему компоновки данных-настройки-новая группировка-ок-
	Task:
	Если бы нам нужно было бы сгруппировать данные, например, по поставкам НДС и посчитать, например, количество, качество товаров с с каждой ставкой , мы бы вместо пустой добавили группировку "Ставка НДС"
	Decision:
	    -выбранные поля-код, наименование, цена-другие настройки-флаг:заголово-Прайс лист-
	Task:
	Свойства пользовательских настроек
	B отчете мы разрешим управлять пользователю.
	Decision:
	-отчет-свойства элемента пользовательских настроек-выбор поля:колонки,быстрый доступ-отбор:быстрый доступ-порядок:быстрый доступ-условное офомление:обычный-группировки-обычный
	Task:
	Соединение таблиц в запросе
	Decision:
	    Запрос - простое соединение - конструктор запроса - Справочники - Контрагенты, Организации> - Нименование(Контрагенты),ИНН(Организации))> - ок
	ВЫБРАТЬ
	    Контрагенты.Наименование КАК Наименование,
	    Организации.ИНН КАК ИНН
	ИЗ
	    Справочник.Контрагенты КАК Контрагенты,
	    Справочник.Организации КАК Организации
	Decision:
	    Запрос - Безусловное соединение - конструктор запроса - Справочники - Контрагенты> БанковскиеСчетаОрганизаций> - Наименование (Контрагенты, БанковскиеСчетаОрганизаций)> - Объединение/Псевдонимы - Имя полей - Контрагент, Банк - ок - выполнить
	ВЫБРАТЬ
	    БанковскиеСчетаОрганизаций.Наименование КАК Банк,
	    Контрагенты.Наименование КАК Контрагент
	ИЗ
	    Справочник.Контрагенты КАК Контрагенты,
	    Справочник.БанковскиеСчетаОрганизаций КАК БанковскиеСчетаОрганизаций
	Task:
	Объединение таблиц в запросе
	Получить список всех продаж и товаров в хронологиическом порядке
	Decision:
	    Добавить запрос - Объединение (продажи и товары в хронологии) - конструктор запроса - таблицы и поля - база данных - документы - заказ клиента> - номер, дата, партнер, сумма документа> - объединение/псевдонимы - запрос - добавить - Таблицы и поля - РасходныйОрдерНаТовары> - номер, дата - поля -добавить - 0 - объединение/псевдонимы - запрос2 - 0 - ок
	ВЫБРАТЬ
	    ЗаказКлиента.Номер КАК Номер,
	    ЗаказКлиента.Дата КАК Дата,
	    ЗаказКлиента.Партнер КАК Партнер,
	    ЗаказКлиента.СуммаДокумента КАК СуммаДокумента
	ИЗ
	    Документ.ЗаказКлиента КАК ЗаказКлиента
	ОБЪЕДИНИТЬ ВСЕ
	ВЫБРАТЬ
	    РасходныйОрдерНаТовары.Номер,
	    РасходныйОрдерНаТовары.Дата,
	    0,
	    0
	ИЗ
	    Документ.РасходныйОрдерНаТовары КАК РасходныйОрдерНаТовары
	    Конструктор заппроса - порядок - дата> - возрастание - ок
	ВЫБРАТЬ
	    ЗаказКлиента.Номер КАК Номер,
	    ЗаказКлиента.Дата КАК Дата,
	    ЗаказКлиента.Партнер КАК Партнер,
	    ЗаказКлиента.СуммаДокумента КАК СуммаДокумента,
	    ЗаказКлиента.Ссылка КАК Ссылка
	ИЗ
	    Документ.ЗаказКлиента КАК ЗаказКлиента
	ОБЪЕДИНИТЬ ВСЕ
	ВЫБРАТЬ
	    РасходныйОрдерНаТовары.Номер,
	    РасходныйОрдерНаТовары.Дата,
	    0,
	    0,
	    РасходныйОрдерНаТовары.Ссылка
	ИЗ
	    Документ.РасходныйОрдерНаТовары КАК РасходныйОрдерНаТовары
	УПОРЯДОЧИТЬ ПО
	    Дата
	Task:
	СКД - Разработка отчетов. Создание отчета - фиксированный макет
	Нужно создать отчет остатки товаров, который должен показывать остатки номенклатуры в разрезе в виде таблицы с группировкой по складам
	Task:
	Сначала выведем на форму элемент, который позволит нам показать результат отчета пользователю
	Decision:
	    Конфигурация - Отчеты - добавить - ОстаткиТоваров_Вариант1 - Формы - Форма отчета - открыть - добавить реквизит - ТабДок - Выбрать тип - +Табличный документ - перетаскиваем ТабДок из реквизитов в форму - Положение Заголовка - Нет - Команды - добавить - СформироватьОтчет - Представление - Выбрать картинку - СформироватьОтчет - отображение - Картинка и текст - перетаскиваем СформироватьОтчет из реквизитов в командную панель - форма - использование - положение командной панели - авто - ФормаСформироватьОтчет - основные - +КнопкаПоУмолчанию
	Task:
	Теперь нужно создать макет
	Decision:
	    Конфигурация - Отчеты - ОстаткиТоваров_Вариант1 - Макеты - Добавить - Остатки - тип макета - табличный документ - Склад, Товар, Количество остаток - Склад, Товар, КоличествоОстаток - свойства - Склад, Товар, КоличествоОстаток - макет - Заполнение - Параметр - Выделим первые три строки и макета с полями Склад, Товар, Количество остаток - Таблица - имена - назначить имя - ШапкаТаблицы - Выделим четвертую строку макета с полями Склад, Товар, КоличествоОстаток - Таблица - имена - назначить имя - СтрокаТаблицы
	Task:
	Разработать алгоритм, который позволит вывести нам результат в табличный документ и показать его на форме пользователю
	Decision:
	    Конфигурация - Отчеты - ОстаткиТоваров_Вариант1 - Подсистемы - Продажи - Конфигурация - Отчеты - ОстаткиТоваров_Вариант1 - ФормаОтчета - поле - Сформировать отчет - действия команды - Создать на клиенте и на сервере
	&НаКлиенте
	Процедура СформироватьОтчет(Команда)
	    СформироватьОтчетНаСервере();
	КонецПроцедуры
	&НаСервере
	Процедура СформироватьОтчетНаСервере()
	    ОтчетОбъект= РеквизитФормыВЗначение("Отчет");
	    ОтчетОбъект.СформироватьОтчет(ТабДок);
	КонецПроцедуры
	    Конфигурация - Отчеты - ОстаткиТоваров_Вариант1 - Открыть модуль объекта
	Процедура СформироватьОтчет(ТабДок) Экспорт   
	    //1. Прочитать данные из базы
	КонецПроцедуры
	    Конструктор запроса с обработкой результата - таблицы и поля - РегистрыНакопления - ТоварныеЗапасыОстатки> - Склад, товар, КоличествоОстаток>
	Процедура СформироватьОтчет(ТабДок) Экспорт   
	    ТабДок.Очистить();
	    //1. Прочитать данные из базы
	    Запрос = Новый Запрос;
	    Запрос.Текст =
	        "ВЫБРАТЬ
	        |   ТоварныеЗапасыОстатки.Склад КАК Склад,
	        |   ТоварныеЗапасыОстатки.Товар КАК Товар,
	        |   ТоварныеЗапасыОстатки.КоличествоОстаток КАК КоличествоОстаток
	        |ИЗ
	        |   РегистрНакопления.ТоварныеЗапасы.Остатки КАК ТоварныеЗапасыОстатки";
	    РезультатЗапроса = Запрос.Выполнить();
	    ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
	    Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
	    КонецЦикла;
	КонецПроцедуры
	...
	    РезультатЗапроса = Запрос.Выполнить();
	    Выборка = РезультатЗапроса.Выбрать();
	    //2. Вывод результата в отчет
	    Макет = ПолучитьМакет("Остатки");
	    Область=Макет.ПолучитьОбласть("ШапкаТаблицы");
	    ТабДок.Вывести(Область);
	    Пока Выборка.Следующий() Цикл
	        Область=Макет.ПолучитьОбласть("СтрокаТаблицы");
	        Область.Параметры.Заполнить(Выборка);
	        ТабДок.Вывести(Область);
	    КонецЦикла;
	...
	    Выполнить - продажи - остатки товаров вариант1 - сформировать
	Task:
	Добавить в отчете поля для выбора даты, чтоб на указанную дату рассчитывался остаток
	Decision:
	    Конфигурация - Отчеты - ОстаткиТоваров_Вариант1 - данные - добавить реквизит - ДатаОстатков - тип - дата - форма отчета - перетаскиваем ДатаОстаков из реквизита в форму - Открыть модуль объекта - конструктор запроса - таблицы и поля - таблицы - параметры вирутальной таблицы - период - &ДатаОстатков - таблицы и поля - поля - ТоварныеЗапасыОстатки Склад - изменить текущий элемент - функции языка запросов - функции - прочие запросы - ПредставлениеССылки
	ПРЕДСТАВЛЕНИЕССЫЛКИ(ТоварныеЗапасыОстатки Склад)
	    ТоварныеЗапасыОстатки Товар - изменить текущий элемент - функции языка запросов - функции - прочие запросы - ПредставлениеССылки
	ПРЕДСТАВЛЕНИЕССЫЛКИ(ТоварныеЗапасыОстатки Товар)
	Процедура СформироватьОтчет(ТабДок) Экспорт   
	    ТабДок.Очистить();
	    //1. Прочитать данные из базы
	        //{{КОНСТРУКТОР_ЗАПРОСА_С_ОБРАБОТКОЙ_РЕЗУЛЬТАТА
	    // Данный фрагмент построен конструктором.
	    // При повторном использовании конструктора, внесенные вручную изменения будут утеряны!!!
	    Запрос = Новый Запрос;
	    Запрос.Текст =
	        "ВЫБРАТЬ
	        |   ПРЕДСТАВЛЕНИЕССЫЛКИ(ТоварныеЗапасыОстатки.Склад) КАК Склад,
	        |   ПРЕДСТАВЛЕНИЕССЫЛКИ(ТоварныеЗапасыОстатки.Товар) КАК Товар,
	        |   ТоварныеЗапасыОстатки.КоличествоОстаток КАК КоличествоОстаток
	        |ИЗ
	        |   РегистрНакопления.ТоварныеЗапасы.Остатки(&ДатаОстатков, ) КАК ТоварныеЗапасыОстатки";
	    ВыбраннаяДата=?(ЗначениеЗаполнено(ДатаОстатков), КонецДня(ДатаОстатков)+1, '00010101');
	    Запрос.УстановитьПараметр("ДатаОстатков", ВыбраннаяДата);
	    РезультатЗапроса = Запрос.Выполнить();
	    Выборка = РезультатЗапроса.Выбрать();
	    //2. Вывод результата в отчет
	    Макет = ПолучитьМакет("Остатки");
	    Область=Макет.ПолучитьОбласть("ШапкаТаблицы");
	    ТабДок.Вывести(Область);
	    Пока Выборка.Следующий() Цикл
	        Область=Макет.ПолучитьОбласть("СтрокаТаблицы");
	        Область.Параметры.Заполнить(Выборка);
	        ТабДок.Вывести(Область);
	    КонецЦикла;
	КонецПроцедуры
	    Выполнить - продажи - остатки товаров вариант1 -  выбрать дату - сформировать
	Task:
	Создание отчета - Система компоновки данных (СКД)
	Нужно создать отчет, используя СКД, остатки товаров, который должен показывать остатки номенклатуры в разрезе в виде таблицы с группировкой по складам
	Decision:
	    Конфигурация - Отчеты - добавить - ОстаткиТоваров_Вариант2 - подсистемы - продажи - основные - открыть схему компоновки данных - Добавить набор данных - запрос - конструктор запроса - РегистрыНакопления - ТоварыеЗапасыОстатки> - Склад, товар, КоличествоОстаток>
	ВЫБРАТЬ
	    ТоварныеЗапасыОстатки.Склад КАК Склад,
	    ТоварныеЗапасыОстатки.Товар КАК Товар,
	    ТоварныеЗапасыОстатки.КоличествоОстаток КАК КоличествоОстаток
	ИЗ
	    РегистрНакопления.ТоварныеЗапасы.Остатки КАК ТоварныеЗапасыОстатки
	    Настройки - открыть конструктор запроса - Список - Склад, Товар, КоличествоОстаток> - выполнить - продажи - остатки товаров вариант2
	Task:
	Пользователю нужно указать период
	Decision:
	    Еще - Изменить вариант - Параметры - Период - свойства элемента пользовательских настроек - включать в пользовательские настройки - режим редактирования - быстрый доступ
	Task:
	Консоль отчетов
	Decision:
	    Конфигуратор - сервис - параметры - запуск 1с - +Толстый клиент - Выполнить - файл - открыть - управляемая консоль отчетов - добавить - схему компоновки данных - конструктор - добавить набор данных запрос - конструктор запросов - товарныеЗапросыОстатки>> - ok - Настройки - открыть конструктор запросов - количествоОстаток>> - ок - выполнить - конструктор - сохранить схему в файл
	Task:
	Ресурсы (Поля итога)
	В отчете "Остатки товаров" нужно наастроит расчет итогов по количеству
	Decision:
	    Добавить схему компоновки данных -  конструктор - добавить набор данных запрос - конструктор запроса - регистрыНакопления - товарныеЗапасыОстатки>>-ок-настройки-количествоОстаток>>- ok - выполнить - конструктор - ресурсы - количествоОстаток> - ок - выполнить
	Task:
	Поменяем структуру отчета
	Decision:
	    конструктор - настройки - добавить новую группировку - Склад - детальный записи перетаскимваем в Склад - ок - выполнить
	Task:
	Разработать отчет, который будет показывать информацию о продажах за период, период будет выбирать пользователь
	Decision:
	    Добавить схему компоновки данных - конструктор - добавить набор данных запрос - конструктор запроса - регистрыНакопление-ПродажиОбороты>-покупатель, товар, количествоОборот, суммаОборот> - ресурсы - количествоОборот, суммаОборот> - настройки - открыть конструтор запроса - список - КоличествоОборот>> - ок - выполнить - конструктор запроса - сохранить схему - конфигуратор - Отчеты - Создать - ПродажиТоваров_СКД - подсисема Продажи+ - основные - открыть схему компоновки данных - загрузитьсхему из файла - f5 - продажи - Продажи Товаров СКД - сформировать
	Task:
	Нужно сделать так, чтобы пользователь мог работать с периодом
	Decision:
	    Отчет - ПродажиТоваров_СКД - Натсройки - Начало приода, конец периода - Свойства элементов пользовательских настроек - Включать пользовательские настройки+ - параметры - добавить - Период - тип - Стандартный период+ - Начало, конец период - ограничение доступности+ -  Начало, конец период - вырожение - &Период.ДатаНачала, &Период.ДатаОкончания - Настройки - период - Свойства элементов пользовательских настроек - Включать пользовательские настройки+ -выполнить - продажи - Продажи Товаров СКД - сформировать
	Task:
	Сложные отчеты: список, таблица, диаграмма
	Разработаем отчет, который позволит получить данные оборота по купленным товарам за выбранный пользователем период и узнать количество и сумму купленных  товаров в разреезе товаров, складов, организаций и других полей приходной накладной. Создадим отчет "Отчет о закупках" и добавим новый запрос данных.
	Decision:
	   Конфигурация-отчеты-добавить-имя,синоним:ОтчетОЗакупках-подсистемы-закупки-основные-открыть схему компоновки данных-добавить набор данных:запрос-конструктор запроса БД:документы/поступление товаров/товары,Таблицы:поступлениеТоваров-переименовать-ПрихТовары:Номенклатура/количество/сумма/ссылка-
	Task:
	Отбор и параметры в запросе
	Пользователю можно добаться до даты, имея "Ссылку", или, поставив условие "Отбор", или часть отобров можно прописать явно в запросе. Для этого есть есть предложение "ГДЕ" в закладке "Условия". И тогда написанные нами отборы пользователь не сможет отключить.
	Decision:
	    -условия-прихТовары,ссылка-дата-между-Дата1-Дата2-прихТовары,ссылка-пометкаНаУдаление-флаг-выбрать-НЕ ПрихТовары.Ссылка.ПометкаУдаления-ок-Запрос-
	ВЫБРАТЬ
	    ПрихТовары.Номенклатура,
	    ПрихТовары.Количество,
	    ПрихТовары.Сумма,
	    ПрихТовары.Ссылка
	ИЗ
	    Документ.ПоступлениеТоваров.Товары КАК ПрихТовары
	ГДЕ
	    НЕ ПрихТовары.Ссылка.ПометкаУдаления
	    И ПрихТовары.Ссылка.Дата МЕЖДУ &Дата1 И &Дата2
	    -ок-поля:ссылка-флажок-(переименовать)Документ-
	Task:
	Ресурсы запроса
	Пользователь в отчете наверняка захочет увидет не только все строки всех документов, но и подвести итоги по товару, контрагенту, и другим полям, сколько всего было куплено товаров данного типа. Запрос должен просуммировать поля "количество" и "сумма".
	Decision:
	    -ресурсы-количество,сумма-количество,рассчитывать по-номенклатура-ок-сумма,рассчитывать по - количеству-ок-
	Task:
	Параметры компоновки
	Воспользуемся механизмом стандартного выбора периода, который позволяет осуществлять выбор из списка со стандартными периодами. Для этого добавим новый параметр "период".
	Decision:
	    -Параметры-Добавить-Имя:Пеиод-тип:СтандартныйПериод-
	Task:
	Вариант отчета "список"
	Настроим несколько вариантов отчета для нашего пользователя.
	Decision:
	    -Настройка-Открыть конструктор настроек-список-Номенклатура >, Количество >, Сумма > - Номенклатура > -
	Task:
	Установим период отчета по умолчанию
	Decision:
	    -Настройка-параметры-Флажок на период-Дата окончания: этот год-Другие настройки-Заголовок:Ведомость закупок-отчет-свойства элемента пользовательских настроек-Флажок:выбранные поля,отбор,порядок (обычный),условное оформление (обычный),группировка-Параметры-свойства элемента пользовательских настроек-флажок:включать в пользовательские настройки-ок-
	Task:
	Связанные поля
	Получить отчет пользователю о закупках с отбором по одной организации
	Decision:
	в свойстве отбор - найти там документ (ссылка) - найти орагнанизацию - на нее поставить отбор.
	Task:
	Но можно это сделать за пользователя, чтобы все поля, которые ему нужны будут, были видны на вернем углу списка доступных полей.
	Decision:
	    конфигурация-отчетОЗакупках-схема компоновка даных-набор данных-конструктор запроса-таблицы:организация >,контрагент >,Склад >-В наборе данных-поле-переименуем добавленные нами заголовки-флагСклад:Ссылка.Склад,Организация,Контрагент-
	Task:
	Ограничение поля
	Запретим пользователю залезать внутрь документа ссылки, т.е. убрать плюсик слева от поля "Документ", когда пользователь работает с отбором
	Decision:
	    -Ссылка документ:условие:флаг-
	Task:
	Кросс-таблица
	Теперь когда появились поля Контрагент, организация, склад сделаем отчет типа таблица. Нам нужно изменить только вкладку настройки схемы компоновки данных. Чтобы сэкономить время скопируем наш вариант  отчета
	Decision:
	    -настройки-копируем вариант отчета и переименуем: Шахматка-удаляем группировку номенклатура-добавить новую таблицу-Таблица--Строки-номенклатура-колонки-контрагент-выбранные поля-оставим только сумму-другие настройки-заголовок:Шахматка закупок-отчет-свойства элемента пользовательских настроек-везде поставим галочку кроме группировки, а в режиме редактирования поставим обычный у порядка и условного оформления- в таблице-свойства элемента пользовательских настроек-поставим галочки только в группировки строк и колонок
	Task:
	Функции языка запросов
	Сгруппируем наш отчет о закупках, который мы по умолчанию формируем за 1 год, помесячно
	Decision:
	Для этого нужно довить в текст запроса поле, которое идентифицирует месяц, к которому принадлежит дата документа.
	НАЧАЛАПЕРИОДА- функция, которая, получив от нас дату документа и название периода "месяц", сможет рассчитать дату начала месяца.
	    конфигуратор-отчет о закупках-сехма компоновки данных-конструктор запросов-поля-добавить-функция,функция работы с датами, НАЧАЛОПЕРИОДА(Тащим вниз)-(Заместо дата)поле,все поля,прихтовары,ссылка,дата(Тащим вниз)-(Заместо период)функция,функция работы с датами,Месяц(Тащим вниз)-объединения и псевдонимы-назовем:периодМесяц-ок-набор данных-ПериодМесяц-оформление-формат поля-формат-конструктор фоматной строки-дата-формат даты(флаг)-ММММ.гггг-
	Также если надо не помесячно указать в отчете, а по квартально, тогда нужно в формате данных указать  - к "кв." гггг "г."
	Task:
	Диаграмма
	Управленцам создадим графический вариант отображения данных.
	Decision:
	    конфигуратор-отчет о закупках-сехма компоновки данных-настройки-Скопироуем вариант с Шахматки и назовем его Диаграмма-Удаляем "таблица" полностью-вместо нее добавляем "Диаграмма"-точки:ПериодМесяц-Серии:номенклатура-диаграмма-свойства элемента пользовательских настроек-флажок:Группировки серий, Группировки точек-ок-другие настройки-Заголовок:диаграмма закупок
	Task:
	Внешние отчеты
	Можно с самого начала разрабатывать отчет не как новую ветку в дереве  объектов конфигурации, а используя
	Decision:
	    конфигуратор-файл-новый-внешний отчет-имя:НовыйВнешнийОтчет-файл-сохранить как-1c-Forus-NewExternalReport.erf
	Task:
	открыть для изменения этот отчет
	Decision:
	    конфигуратор-файл-открыть-1c-Forus-NewExternalReport.erf
	Task:
	Программноe выполнение запроса
	В модуле формы документа "Поступление товаров" описан механизм получения цены из элементасправочника Номенклатура. Для этого использовалась объектная модель и обращение  через точку к реквизиту выбранного элемента справочника номенклатуры.
	В функции была одна трока кода и возврат результата:
	&НаСервере
	Функция ПолучитьЦену(Товар)
	    Возврат Товар.Цена;
	КонецФункции
	Но можно сделать это и запросом, чтобы оптимизировать получение данных. Перепишем функцию так, чтобы она получала данные запросом.
	Изменим функцию получитьЦену, удалим строе ее содержимое и напишем алгоритм получения цены с сервра по новому.
	Decision:
	    пр.кн.мыши-конструторзапроса с обработкой результата-обход результата-таблицы и поля,справочники,номенклатура>цена>-Условия,поля,номенклатура,ссылка-перетаскиваем в правое поле-запрос-
	ВЫБРАТЬ
	    Номенклатура.Цена
	ИЗ
	    Справочник.Номенклатура КАК Номенклатура
	ГДЕ
	    Номенклатура.Ссылка = &Ссылка
	    -ок
	Decision:
	&НаКлиенте
	Процедура ТоварыЦенаПриИзменении(Элемент)
	    Стр=Элементы.Товары.ТекущиеДанные;
	    РасчетСтроки(Стр);
	    //Стр=Элементы.Товары.ТекущиеДанные;
	    //ПроцедурыДокументов.РассчетСтроки(Стр);
	КонецПроцедуры
	&НаКлиенте
	Процедура ТоварыКоличествоПриИзменении(Элемент)
	    Стр=Элементы.Товары.ТекущиеДанные;
	    РасчетСтроки(Стр);
	    //Стр=Элементы.Товары.Стр;
	    //ПроцедурыДокументов.РассчетСтроки(Стр);
	КонецПроцедуры
	&НаКлиенте
	Процедура РасчетСтроки(ТекСтр)
	    ТекСтр.Сумма=ТекСтр.Цена*ТекСтр.Количество;
	КонецПроцедуры
	&НаКлиенте
	Процедура ТоварыСуммаПриИзменении(Элемент)
	    Стр=Элементы.Товары.ТекущиеДанные;
	    Если Стр.Количество = 0 Тогда
	        Сообщить("Ошибка");
	    Иначе
	        Стр.Цена=Стр.Сумма/Стр.Количество;
	    КонецЕсли
	КонецПроцедуры
	&НаКлиенте
	Процедура ТоварыНоменклатураПриИзменении(Элемент)
	    Стр=Элементы.Товары.ТекущиеДанные;
	    Стр.Цена=ПолучитьЦену(Стр.Номенклатура);  
	    РасчетСтроки(Стр);
	КонецПроцедуры
	&НаСервереБезКонтекста
	Функция ПолучитьЦену(Товар)
	    //Возврат Товар.Цена;    //{{КОНСТРУКТОР_ЗАПРОСА_С_ОБРАБОТКОЙ_РЕЗУЛЬТАТА
	    // Данный фрагмент построен конструктором.
	    // При повторном использовании конструктора, внесенные вручную изменения будут утеряны!!!         
	    Запрос = Новый Запрос;
	    Запрос.Текст =
	        "ВЫБРАТЬ
	        |    Номенклатура.Цена
	        |ИЗ
	        |    Справочник.Номенклатура КАК Номенклатура
	        |ГДЕ
	        |    Номенклатура.Ссылка = &Ссылка";               
	    Запрос.УстановитьПараметр("Ссылка", Ссылка);            
	    РезультатЗапроса = Запрос.Выполнить();                   
	    ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();        
	    Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
	        // Вставить обработку выборки ВыборкаДетальныеЗаписи
	    КонецЦикла;                                                 
	    //}}КОНСТРУКТОР_ЗАПРОСА_С_ОБРАБОТКОЙ_РЕЗУЛЬТАТА
	КонецФункции
	Task:
	Способы чтения данных из базы
	прочитать какую то информацию из базы, например, товары используя метод объект
	Decision:
	Файл->Внешняя обработка->Имя:СпособыЧтенияДанных->Форма обработки->Команды->Добавить->ОбъектнаяМодель,ТабличнаяМодель->Перетаскиваем команды в командную панель->ОбхектнаяМодель->ДействияКоманды->На клиенте и на сервере
	&НаКлиенте
	Процедура ОбъектнаяМодель(Команда)
	    ОбъектнаяМодельНаСервере();
	КонецПроцедуры
	&НаСервере
	Процедура ОбъектнаяМодельНаСервере()
	    Выборка=Справочники.ТоварныеКатегории.Выбрать();
	    Пока Выборка.Следующий() Цикл
	        Сообщение=Новый СообщениеПользователю;
	        Сообщение.Текст=Выборка.Наименование;
	        Сообщение.Сообщить();
	    КонецЦикла;
	КонецПроцедуры
	Output:
	Объектная модель
	    Женская обувь
	    Кабели
	    Кондиционеры
	    Крупы
	    Масло
	    Мебель
	    Мебель (наборы)
	    Мебель (сборка)
	    Молоко
	    Мужская обувь
	    Соки
	    Спортивная обувь
	    Телевизоры
	    Хлебобулочные изделия
	    Холодильники
	    Электротовары
	    Объектная модель доступа к данным. Ограничения.(1)
	Task:
	Если мы хотим поменять номенклатуру
	Decision:
	...
	Процедура ОбъектнаяМодельНаСервере()
	    Выборка=Справочники.ТоварныеКатегории.Выбрать();
	    Пока Выборка.Следующий() Цикл  
	        ТоварОбъект=Выборка.ПолучитьОбъект();
	        ТоварОбъект.Артикул="21414";
	        ТоварОбъект.Записать();
	        Сообщение=Новый СообщениеПользователю;
	        Сообщение.Текст=Выборка.Наименование;
	        Сообщение.Сообщить();
	    КонецЦикла;
	КонецПроцедуры
	Task:
	Получить данные из двух таблиц
	Decision:
	...
	    Выборка=Справочники.ТоварныеКатегории.Выбрать();
	    ВыборкаЦены=РегистрыСведений.ЦеныНоменклатуры.Выбрать();
	    Пока Выборка.Следующий() Цикл
	...
	Task:
	Попробуем прочитать из таблицы заказов по одному покупателю
	Decision:
	        ...
	    КонецЦикла;    
	    Покупатель=Справочники.Контрагенты.НайтиПоНаименованию("Саймон и Шустер");
	    Отбор=Новый Структура("Партнер", Покупатель);
	    ВыборкаЗаказы=Документы.ЗаказКлиента.Выбрать(,,Отбор);
	КонецПроцедуры
	Task:
	Вывести информацию с помощью табличной модели
	Decision:
	    Табличная модель->Выполнить действия->Клиент,Сервер->Конструктор запроса->Таблицы и поля->Справочник->Товарные категории> -> Наименование>
	&НаКлиенте
	Процедура ТабличнаяМодель(Команда)
	    ТабличнаяМодельНаСервере();
	КонецПроцедуры
	&НаСервере
	Процедура ТабличнаяМодельНаСервере()
	    //{{КОНСТРУКТОР_ЗАПРОСА_С_ОБРАБОТКОЙ_РЕЗУЛЬТАТА
	    // This fragment was built by the wizard.
	    // Warning! All manually made changes will be lost next time you use the wizard.
	    Запрос = Новый Запрос;
	    Запрос.Текст =
	        "ВЫБРАТЬ
	        |   ТоварныеКатегории.Наименование КАК Наименование
	        |ИЗ
	        |   Справочник.ТоварныеКатегории КАК ТоварныеКатегории";
	    РезультатЗапроса = Запрос.Выполнить();
	    ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
	    Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
	        // Insert selected data processing ВыборкаДетальныеЗаписи
	        Сообщение=Новый СообщениеПользователю;
	        Сообщение.Текст=ВыборкаДетальныеЗаписи.Наименование;
	        Сообщение.Сообщить();
	    КонецЦикла;
	    //}}КОНСТРУКТОР_ЗАПРОСА_С_ОБРАБОТКОЙ_РЕЗУЛЬТАТА
	КонецПроцедуры
	Output:
	Табличная модель
	    Молоко
	    Масло
	    Крупы
	    Хлебобулочные изделия
	    Соки
	    Женская обувь
	    Мужская обувь
	    Спортивная обувь
	    Кондиционеры
	    Кабели
	    Мебель (сборка)
	    Мебель (наборы)
	    Телевизоры
	    Холодильники
	    Электротовары
	    Мебель
	Task:
	Консоль запросов
	Decision:
	    1с предприятие->Файл->Открыть->УправляемаяКонсольОтчетов 3.8.9->Текст запроса
	ВЫБРАТЬ * ИЗ Справочник.ТоварныеКатегории
	    Выполнить
	Task:
	Конструктор запросов
	Из справочника ТоварныеКатегории выбрать все наименования товаров
	Decision:
	Конструктор->База данных->Справочники->ТоварныеКатегории>->Таблицы->Наименование>->Ок->Выполнить
	Простые запросы
	Task:
	Самый простой запрос: константные значения в запросе
	Decision:
	ВЫБРАТЬ
	5 КАК ПростоеЧисло,
	"строка" КАК ПростаяСтрока
	Decision:
	    Конструктор->Поле->Добавить->5,"строка"->Объединение Псевдонимы->Поле1,Поле2->ПростоеЧисло,ПростаяСтрока->Ок->Выполнить
	Output:
	    ПростоеЧисло    ПростаяСтрока
	    5               строка
	Task:
	Как прочитать значение константы
	Decision:
	    Добавить запрос->Запрос к константе->Конструктор->База данных->Константы->ВалютаУпрвленческогоУчета>->Таблицы->Значение>->ок->Выполнить
	Decision:
	    Значение
	    USD
	Task:
	Как прочитать данные из справочников
	Decision:
	    Добавить запрос->Запрос к справочнику->Конструктор->База данных->Справочник->Контрагенты>->Наименование, КодПоОКПО,СтранаРегистрации>->ок->Выполнить
	Task:
	Как прочитать данные из документов
	Decision:
	    Добавить запрос->Запрос к документу->Конструктор->База данных->Документ->ЗаказКлиента>->Номер, Дата, Партнер, Склад, Валюта, Автор, СуммаДокумента>->ок->Выполнить
	Task:
	Как прочитать данные из табличных частей
	Decision:
	Добавить запрос->Запрос к табличной части->Конструктор->База данных->ЗаказКлиентаТовары>->НомерСтроки, Номенклатура, Цена, Количество, Сумма>->ок->Выполнить
	Task:
	Разыменование полей в запросе
	Decision:
	Добавить запрос->Запрос к табличной части (разыменование)->Конструктор->База данных->ЗаказКлиентаТовары>->Таблицы->НомерСтроки, Номенклатура, Цена, Количество, Сумма>->Таблицы->Ссылка->Контрагент>->ок->Выполнить
	Фильтр в запросе
	Task:
	Найти контрагента по наименованию
	Decision:
	Добавить запрос->Условие в запросе->Конструктор->База данных->Контрагенты>->Ссылка, Наименование, КодПоОКПО>->Условие->Поля->Наименование>->ок->Параметры->Значение->Бакалея->Выполнить
	Task:
	Выбрать из справочника «Товары» только элементы (без групп)
	Decision:
	Добавить запрос->Товары без групп->Конструктор->База данных->Справочники->ТоварныеКатегории>->Наименование, ЭтоГруппа,Владелец->Условие->Поля->ЭтоГруппа>->ок->Параметры->Значение->Да->Выполнить
	Task:
	Найти товар по наименованию    по точному соответствию
	    по неточному соответствию
	Decision:
	Добавить запрос->Запрос по наименованию (точное соответствие)->Конструктор->База данных->Справочник>->ТоварныеКатегории->Наименование,Владелец>Условие->Условие->Поля->ТоварныеКатегории->Наименование>->ок->Параметры->Значение->Молоко->Выполнить
	Decision:
	Добавить запрос->Запрос по наименованию (не точное соответствие)->Конструктор->База данных->Справочник>->ТоварныеКатегории->Наименование,Владелец>Условие->Условие->Поля->ТоварныеКатегории->Наименование>->ТоварныеКатегории.Наименование ПОДОБНО &Наименование->ок->Параметры->Значение->%Мебель%->Выполнить
	Task:
	Выбрать товар из группы «Электротовары» не включая/включая вложенные группы
	Decision:
	Добавить запрос->Выбор товаров из группы->Конструктор->База данных->Справочник>->ТоварныеКатегории->Наименование,Владелец>Условие->Условие->Поля->ТоварныеКатегории->Родитель>->ок->Параметры->Значение->Электротовары->Выполнить
	Task:
	Найти товары, для которых не заполнен реквизит кода
	Decision:
	Добавить запрос->Поиск товаров без кода->Конструктор запроса->База данных->Справочник>->ТоварныеКатегории->Наименование,код>Условие->Поля->ТоварныеКатегории->код>->ТоварныеКатегории.Владелец.КодОКВЭД = ""->ок->Выполнить
	Task:
	Найти товары, для которых заполнен реквизит код
	Decision:
	Копировать запрос->переименовать->Поиск товаров с кодом>Конструктор запроса->Условие->ТоварныеКатегории.Владелец.КодОКВЭД <> ""->ok->Выполнить
	Группировка
	Task:
	Выбирать данные из всех заказов
	Decision:
	Добавить запрос->Все товары из заказов->Конструктор запроса->База данных->Документы>->ЗаказКлиента->Товары>Количество,Сумма,Номенклатура,Цена>ок->Выполнить
	Decision:
	ВЫБРАТЬ
	    ЗаказКлиентаТовары.Количество КАК Количество,
	    ЗаказКлиентаТовары.Сумма КАК Сумма,
	    ЗаказКлиентаТовары.Номенклатура КАК Номенклатура,
	    ЗаказКлиентаТовары.Цена КАК Цена
	ИЗ
	    Документ.ЗаказКлиента.Товары КАК ЗаказКлиентаТовары
	Task:
	Нужно сделать так, чтобы по каждому товару была только одна запись. То есть мы хотим получить общим общий объем количества товаров и сумму и минимальную цену
	Decision:
	Конструктор запроса->Группировка->Номенклатура>Поле группировки->Количество,Сумма,Цена>Суммарные поля->Цена->Минимум->ок->Выполнить
	Decision:
	ВЫБРАТЬ
	    СУММА(ЗаказКлиентаТовары.Количество) КАК Количество,
	    СУММА(ЗаказКлиентаТовары.Сумма) КАК Сумма,
	    ЗаказКлиентаТовары.Номенклатура КАК Номенклатура,
	    МИНИМУМ(ЗаказКлиентаТовары.Цена) КАК Цена
	ИЗ
	    Документ.ЗаказКлиента.Товары КАК ЗаказКлиентаТовары
	СГРУППИРОВАТЬ ПО
	    ЗаказКлиентаТовары.Номенклатура
	Task:
	Получить сводную информацию о продажах товаров за период по данным документов «РасходныйОрдерНаТовары»
	Decision:
	Добавить запрос->Продажа по документам->Конструктор запроса->База данных->Документы->РасходныйОрдерНаТовары->ТоварыПоРаспоряжениям>->Номенклатура,Количество>->ок->Выполнить
	Decision:
	ВЫБРАТЬ
	    РасходныйОрдерНаТоварыТоварыПоРаспоряжениям.Количество КАК Количество,
	    РасходныйОрдерНаТоварыТоварыПоРаспоряжениям.Номенклатура КАК Номенклатура
	ИЗ
	    Документ.РасходныйОрдерНаТовары.ТоварыПоРаспоряжениям КАК РасходныйОрдерНаТоварыТоварыПоРаспоряжениям
	Decision:
	Конструктор запроса->Группировка->Номенклатура>Поле группировки->Количество>Суммарные поля->ок->Выполнить
	Decision:
	ВЫБРАТЬ
	    СУММА(РасходныйОрдерНаТоварыТоварыПоРаспоряжениям.Количество) КАК Количество,
	    РасходныйОрдерНаТоварыТоварыПоРаспоряжениям.Номенклатура КАК Номенклатура
	ИЗ
	    Документ.РасходныйОрдерНаТовары.ТоварыПоРаспоряжениям КАК РасходныйОрдерНаТоварыТоварыПоРаспоряжениям
	СГРУППИРОВАТЬ ПО
	    РасходныйОрдерНаТоварыТоварыПоРаспоряжениям.Номенклатура
	Task:
	Получить количество продаж в разрезе покупателей
	Decision:
	Добавить запрос->Количество продаж по контрагентам->Конструктор запроса->РасходныйОрдерНаТовары>->Получатель,Ссылка>->
	Decision:
	ВЫБРАТЬ
	    РасходныйОрдерНаТовары.Ссылка КАК Ссылка,
	    РасходныйОрдерНаТовары.Получатель КАК Получатель
	ИЗ
	    Документ.РасходныйОрдерНаТовары КАК РасходныйОрдерНаТовары
	Decision:
	Конструктор запроса->Группировка->Получатель>Поле группировки->Ссылка>Суммарные поля->ок->Выполнить
	Decision:
	ВЫБРАТЬ
	    КОЛИЧЕСТВО(РАЗЛИЧНЫЕ РасходныйОрдерНаТовары.Ссылка) КАК Ссылка,
	    РасходныйОрдерНаТовары.Получатель КАК Получатель
	ИЗ
	    Документ.РасходныйОрдерНаТовары КАК РасходныйОрдерНаТовары  
	СГРУППИРОВАТЬ ПО
	    РасходныйОрдерНаТовары.Получатель
	Task:
	По каждому товару определить максимальное количество
	единиц, которое продавалось за одну продажу
	Decision:
	Добавить запрос->Максимальное количество за одну продажу->Конструктор запроса->База данных->Документы->РасходныйОрдерНаТовары->ТоварыПоРаспоряжениям>->Номенклатура,Количество>->Группировка->Номенклатура>Поле группировки->Количество>Суммарные поля->Максимум->ок->Выполнить
	Decision:
	ВЫБРАТЬ
	    РасходныйОрдерНаТоварыТоварыПоРаспоряжениям.Номенклатура КАК Номенклатура,
	    МИНИМУМ(РасходныйОрдерНаТоварыТоварыПоРаспоряжениям.Количество) КАК Количество
	ИЗ
	    Документ.РасходныйОрдерНаТовары.ТоварыПоРаспоряжениям КАК РасходныйОрдерНаТоварыТоварыПоРаспоряжениям
	СГРУППИРОВАТЬ ПО
	    РасходныйОрдерНаТоварыТоварыПоРаспоряжениям.Номенклатура
	Task:
	Получить среднюю сумму продаж по дням за период
	Decision:
	Добавить запрос->Продажи по документам (сумма)->Конструктор запроса->База данных->Документы->ЗаказКлиента>->Дата,СуммаДокумента>->Группировка->Дата>Поле группировки->СуммаДокумента>Суммарные поля->Среднее->Таблицы и поля->Поле->Дата->Редактировать->Функция языка запросов->Функции->Функции работы с датами->Начало периода->Перетащить его в нижнее поле->НАЧАЛОПЕРИОДА(ЗаказКлиента.Дата, ДЕНЬ)->ок->Выполнить
	Decision:
	ВЫБРАТЬ
	    НАЧАЛОПЕРИОДА(ЗаказКлиента.Дата, ДЕНЬ) КАК Дата,
	    ЗаказКлиента.СуммаДокумента КАК СуммаДокумента
	ИЗ
	    Документ.ЗаказКлиента КАК ЗаказКлиента
	Task:
	Сортировка данных
	Выбрать все документы «Приход товара» в порядке убывания даты
	Decision:
	Добавить запрос->Приходы по убыванию->Конструктор запроса->База данных->Документы->ПриходныйОрдерНаТовары>->Дата,Номер,Склад>->Порядок->Дата->По убыванию->ок->Выполнить
	Decision:
	ВЫБРАТЬ
	    ПриходныйОрдерНаТовары.Дата КАК Дата,
	    ПриходныйОрдерНаТовары.Склад КАК Склад,
	    ПриходныйОрдерНаТовары.Номер КАК Номер
	ИЗ
	    Документ.ПриходныйОрдерНаТовары КАК ПриходныйОрдерНаТовары
	УПОРЯДОЧИТЬ ПО
	    Дата УБЫВ
	Task:
	Определить дату последнего поступления конкретного товара
	Decision:
	Добавить запрос->дата последнего поступления товара->Конструктор запроса->База данных->Документы->ПриходныйОрдерНаТовары->Товары>->Номенклатура,Ссылка,Дата->Порядок->Дата->По убыванию->Дополнительно->Выборка записей->перерыв->1->ок->Выполнить
	Decision:
	ВЫБРАТЬ ПЕРВЫЕ 1
	    ПриходныйОрдерНаТоварыТовары.Номенклатура КАК Номенклатура,
	    ПриходныйОрдерНаТоварыТовары.Ссылка.Дата КАК Дата,
	    ПриходныйОрдерНаТоварыТовары.Ссылка.Ссылка КАК Ссылка
	ИЗ
	    Документ.ПриходныйОрдерНаТовары.Товары КАК ПриходныйОрдерНаТоварыТовары
	Task:
	Итоги в запросе
	Получить сводную информацию о продажах товаров за период по данным документов «Расход товара» в разрезе покупателей и заказов. По
	каждому покупателю нужно вычислять итоговую сумму всех заказов
	Decision:
	Добавить запрос->Итоги по заказам->Конструктор запроса->База данных->Документы->ЗаказКлиента>->Партнер,Ссылка,СуммаДокумента>->Итоги->Партнер>Группировочное поле->СуммаДокумента>Итоговое поле->ок->Выполнить
	Decision:
	ВЫБРАТЬ
	    ЗаказКлиента.Ссылка КАК Ссылка,
	    ЗаказКлиента.СуммаДокумента КАК СуммаДокумента,
	    ЗаказКлиента.Партнер КАК Партнер
	ИЗ
	    Документ.ЗаказКлиента КАК ЗаказКлиента
	ИТОГИ
	    СУММА(СуммаДокумента)
	ПО
	    Партнер
	Task:
	Получить все документы «Приход товара» в хронологическом порядке с подсчетом итогов количества документов за каждый день периода
	Decision:
	Добавить запрос->Приходы с итогами по дням->Конструктор запроса->База данных->Документы->ПриходныйОрдерНаТовары>->Дата,Номер,Ссылка>->Дата->редактировать->Функции языка запросов->Функции->Функции работы с датами->НАЧАЛОПЕРИОДА->перетаскиваем вниз->НАЧАЛОПЕРИОДА(ПриходныйОрдерНаТовары.Дата, ДЕНЬ)->Итоги->дата>Группировочное поле->Ссылка>Итоговое поле->ок->Выполнить
	Decision:
	ВЫБРАТЬ
	    НАЧАЛОПЕРИОДА(ПриходныйОрдерНаТовары.Дата, ДЕНЬ) КАК Поле1,
	    ПриходныйОрдерНаТовары.Номер КАК Номер,
	    ПриходныйОрдерНаТовары.Ссылка КАК Ссылка
	ИЗ
	    Документ.ПриходныйОрдерНаТовары КАК ПриходныйОрдерНаТовары
	ИТОГИ
	    КОЛИЧЕСТВО(РАЗЛИЧНЫЕ Ссылка)
	ПО
	    Поле1
	Task:
	Как сформировать отчет
	Создать отчет Остатки товаров. Пользователь должен иметь возможность выбрать дату получения остатков. Результат должен выглядеть примерно так:
	    Остатки товаров на дату 17.02.2020
	Номенклатура         Остаток
	Молоток                7
	Отвертка крестовая    5
	Шуруповерт            20
	Штукатурка            -6
	Газонокосилка         7
	Итого                33
	Decision:
	    регистры накопления - добавить - ОстаткиТоваров - данные - измерения - номенклатура - Ресурсы - добавить - КоличествоОстаток - документы - добавить - Номенклатура - движение - регистры накопления - +ОстаткиТоваров - Отчет - добавить - ОстатокТоваров_ФиксированныйМакет - данные - реквизиты - добавить - дата - тип - дата - формы - форма отчета - команды - добавить - Сформировать - представление - картинка - отображение - картинка и текст - сформировать - петескиваем команду в командную панель формы - форма - свойства - использование - положение командной панели - авто - кнопка по умолчанию - реквизиты - дооавить - ТабДок - тип - табличный документ - положение заголовки - нет - ок - перетаскиваем в форму - свойства - команды - сформировать - действие - на клиенте и на сервере - конструктор запроса с обработкой результата - вывод в табличный документ - таблицы и поля - регистры накопления - ОстаткиТоваров.Остатки> - параметры виртуальной таблицы - период - &Дата - номенклатура, КоличествоОстатки> - Итоги - количествоОстаток перетскиваем в итоговое поле - ок - модуль
	&НаСервере
	Процедура СформироватьНаСервере()
	    Макет = Отчеты.ОстатокТоваров_ФиксированныйМакет.ПолучитьМакет("Макет");
	    Запрос = Новый Запрос;
	    Запрос.Текст =
	        "ВЫБРАТЬ
	        |    ОстаткиТоваровОстатки.Номенклатура КАК Номенклатура,
	        |    ОстаткиТоваровОстатки.КоличествоОстатокОстаток КАК КоличествоОстатокОстаток
	        |ИЗ
	        |    РегистрНакопления.ОстаткиТоваров.Остатки(&Дата, ) КАК ОстаткиТоваровОстатки";
	    
	    Запрос.УстановитьПараметр("Дата", Дата);    
	    РезультатЗапроса = Запрос.Выполнить();    
	    ОбластьЗаголовок = Макет.ПолучитьОбласть("Заголовок");
	    ОбластьПодвал = Макет.ПолучитьОбласть("Подвал");
	    ОбластьШапкаТаблицы = Макет.ПолучитьОбласть("ШапкаТаблицы");
	    ОбластьПодвалТаблицы = Макет.ПолучитьОбласть("ПодвалТаблицы");
	    ОбластьДетальныхЗаписей = Макет.ПолучитьОбласть("Детали");    
	    ТабДок.Очистить();
	    ТабДок.Вывести(ОбластьЗаголовок);
	    ТабДок.Вывести(ОбластьШапкаТаблицы);
	    ТабДок.НачатьАвтогруппировкуСтрок();    
	    ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();    
	    Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
	        ОбластьДетальныхЗаписей.Параметры.Заполнить(ВыборкаДетальныеЗаписи);
	        ТабДок.Вывести(ОбластьДетальныхЗаписей, ВыборкаДетальныеЗаписи.Уровень());
	    КонецЦикла;    
	    ТабДок.ЗакончитьАвтогруппировкуСтрок();
	    ТабДок.Вывести(ОбластьПодвалТаблицы);
	    ТабДок.Вывести(ОбластьПодвал);
	КонецПроцедуры
	&НаКлиенте
	Процедура Сформировать(Команда)
	    СформироватьНаСервере();
	КонецПроцедуры
	Task:
	Поменяем макет
	Decision:
	    Макет -Заголовок - ячейка - свойства - макет - заполнение - шаблон
	    Остатки товаров на дату: [Дата]
	    модуль
	    ...
	    //Запрос.УстановитьПараметр("Дата", Дата);
	    Запрос.УстановитьПараметр("Дата", Отчет.Дата);
	    ..
	    ТабДок.Очистить();  
	    ОбластьЗаголовок.Параметры.Дата = Формат(Отчет.Дата, )
	    ТабДок.Вывести(ОбластьЗаголовок);
	    ..
	    Конструктор форматной строки - дата - формат даты - выбираем - ок
	    ...
	    ТабДок.Очистить();  
	    ОбластьЗаголовок.Параметры.Дата = Формат(Отчет.Дата, "ДФ=dd.MM.yyyy");
	    ТабДок.Вывести(ОбластьЗаголовок);
	    ТабДок.Вывести(ОбластьШапкаТаблицы);
	    ТабДок.НачатьАвтогруппировкуСтрок();      
	    //ВыборкаОбщийИтог=РезультатЗапроса.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
	    //ВыборкаОбщийИтог.Следующий();
	    //ОбластьОбщийИтог.Параметры.Заполнить(ВыборкаОбщийИтог);    
	    ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();    
	    Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
	        ОбластьДетальныхЗаписей.Параметры.Заполнить(ВыборкаДетальныеЗаписи);
	        ТабДок.Вывести(ОбластьДетальныхЗаписей, ВыборкаДетальныеЗаписи.Уровень());
	    КонецЦикла;
	    //ТабДок.Вывести(ОбластьОбщийИтог, ВыборкаОбщийИтог.Уровень());
	    ТабДок.ЗакончитьАвтогруппировкуСтрок();
	    //ТабДок.Вывести(ОбластьПодвалТаблицы);
	    //ТабДок.Вывести(ОбластьПодвал);
	    ...
	    запустить
	Task:
	Сделать такой отчет с помощью СКД
	Decision:
	    Отчет - добавить - открыть схему компоновки данных - ок - добавить набор данных - запрос - конструктор запроса - Регистрация накопления - ОстаткиТоваров.Остатки> - номенклатура, КоличествоОстаток> - ок - параметры - Ресурсы - КоличествоОстатокОстаток> - Настройки - открыть конструктор настроек - список - номенклатура, КоличествоОстаток> - ок - параметры - период - пр.кн. - свой элемента пользвательских настроек - *Включать в пользовательские настройки - ок - запустить
	Документ "поступление товаров"
	Task:
	Для регистрации события покупки материальных ценностей создадим документ "поступление товаров"
	Decision:
	    Конфигурация-документы-добавить-имя, синоним: Постпуление товаров-подсистема-закупки
	    Данные-реквизиты:добавить-имя:организация-тип:справочникСсылка.Организация-проверка заполнения:выдать ошибки-так же с контрагентом-табличные части:добавить табличную часть-имя,синоним:товары-табличные части:добавить реквизит таблицы-имя:Номенклатура-тип:справочникСсылка.Номенклатура-проверка заполнения:выдать ошибки-табличные части:добавить реквизит таблицы-имя:Цена-тип:число-точность:2-также с количеством (точность оставить 0) и суммой
	Task:
	Копирование объектов конфигурации
	Сделаем документ реализация товаров, скопировав и вставив объект поступление товаров.
	Decision:
	    Конфигурация-ctrl+c"поступление товаров"-ctrl+v"поступление товаров"-переименуем имя на "реализация товаров"-подсистема-Продажи
	Task:
	Выяснилось, что наше предприятие имеет несколько складов. Пjэтому нужно еще ввести список складов, который должен быть доступен из раздела "общее", при поступлении и продаже товаров нужно указывать склад, причем, при покупке товаров все товары одной накладной приходуются на один склад, то есть реквизит склад должен располагаться в "шапке" документа под контрагентом, а при продаже польователь должен иметь возможность выбора склада и в "шапке" и таблчиной части документа. т. е. если все товары продаются с одного склада, пользователь укажет склад как в приходной накладной, а если товары в разных строках продаются с разных складов, значит пользователь укажет склады в каждой строке документа.
	Task:
	Поле ввода и удобное заполнение реквизитов
	Decision:
	    Конфигурация-справочники-контрагенты-поле ввода
	Создание при вводе
	Task:
	при заполнении приходной накладной, выясняется, что это первый документ от контрагента "Крутой поставщик" и такого в справочнике еще нет.
	Decision:
	    Пользователь нажмет на педальку выбора из правочника, ему покажут последние, которые он выбирал, можно также создать новый
	    Пользоавтель начнет выбирать наименование элемента, подкажут, что такого нет, и предложать опять новый создать.
	Task:
	Новые реквизиты для поиска по строке
	Наименования контрагентов часто повторяются, а ИНН должно быть уникальным.
	Decision:
	    Конфигурация-справочники-контрагенты-данные-ИНН-индексировать:индексировать-поле ввода-ввод по строке-ИНН > - Код
	Способ поиска строки
	Decision:
	    Конфигурация-справочники-контрагенты-поле ввода-способ поиска строки:любой части
	Task:
	История выбора
	Decision:
	    Конфигурация-справочники-контрагенты-поле ввода-история выбора при вводе:авто
	Decision:
	При выборе истории выбора - Авто, сначала открывается список выбранных пользователем ранее элементов, а затем команда "показать все" и "добавить"
	Дополнительные реквизиты, тип данных
	Task:
	Для элемента справочника номенклатуры лучше хранить цену и изготовителя, а для контрагентов - инн и адрес. Для этого нужно добавить реквизиты.
	Decision:
	    Конфигуратор - справочники - контрагенты - данные - реквизиты - создать - имя и синоним: адрес - неограниченная длина - ок - создать - имя и синоним: ИНН - длина: 12 - ок
	Task:
	Примитивные типы данных
	Добавим в справчник номенклатура реквизит цена
	Decision:
	>    Справочник - номенклатура - данные - реквизиты - создать - имя и синоним: Цена - тип: число - длина: 10 - точность: 2 - неотрицательное
	Task:
	Ссылочные типы данных
	Для каждого товара из номенклатуры мы хотим помнить изготовителя (контрагент, который выпускает этот товар, оказывает эту услугу). Поэтому нужно один раз ввести справочник "Контрагенты" того самого изготовителя и многократно выбирать его в разных элементах справочника "Номенклатура"
	Decision:
	    Справочники - номенклатура - данные - реквизиты - создать - имя и синоним: Изготовитель - тип: редактор - справочникСсылка - контрагенты

	Линейные справочники
	Task:
	Наше предприятие может состоять из нескольких самостоятельных юридических лиц и/или обособленных и выделенных на отдельный баланс подразделений. Список этих самостоятельных бизнес-единиц нужно где-то хранить. Создадим справочник "Организация"
	Decision:
	Создадим справочник "Организация"- В закладке данные мы можем упралять длиной стандартных реквизитов "Код" и "Наименование"
	Внутренний      Код                 Наименование
	Идентификатор
	ID              Строка 3 символа    Строка 25 символов
	Включение справочника в управляемый интерфейс
	Task:
	Чтобы пользователь мог открыть справочни, команда открытия его списка должна быть включена в глобальный командный интерфейс конфигурации.
	Нужно предоставить пользователю  возможность открыть справочник для просмотра и заполнения. Для эттого нужно подключить подсистему.
	Decision:
	    Подсистемы - Общее -
	И у него должно быть включено использование стандартных команд
	    Команды - Использовать стандартные команды
	Переименуем элемент "Основная оргаизация" в "Фабрика" - создадим еще элемент "Торговый дом".
	В режиме "Версия 8.2" /Сервис/Параметры/Формы в отдельных закладках выглядит это так:
	Task:
	Включение в интерфейс обычного приложения
	Decision:
	    Конфигуратор - Общее - Интерфейсы - Интерфейс1 - Общее - Новая - Действие - Объект метаданных:Справочники - Организация - Действие: Открыть справочник организация - ОК
	Decision:
	Запустив через "толстый клиент обычное приложение":
	Task:
	Иерархические справочники
	Для хранеия списка справочника, разбитого на группы, создается иерархический справочник. Удобно разбить справочник на группы по видам ценностей: товары, материалы, продукция.
	Создадим справочник номенкатура.
	Decision:
	    Конфигуратор - Справочник - Номенклатура - Подсистема - Общее - иерархия - иерархический справочник
	Decision:
	Таблица иерархического справочника:
	Ссылка  Это     Код     Наименование    Родитель
	        группа
	...     Истина  01      Группа          <Пусто>
	...     Ложь    02      Элемент         Ссылка группы
	Task:
	Стандартные реквезиты
	Свойство "Родитель" может быть не понятно пользователю. Изменить его нужно:
	    Данные - Стандартные реквизиты - Стандартные реквизиты: Родитель - Синоним: Группа
	Task:
	Чтобы определить, какой режим будет основным, и будут ли возможны переключения между разными вариантами интерфейса
	Decision:
	откройте свойство корня дерева конфигурации "Конфигурация"-Выберем режим совместимости "Такси-Разрешить Версия 8.2". То есть по умолчанию будет использоваться вариант интерфейса "такси", но можно переключиться в предыдущий вариаант режима.
	Разделы управляемого интерфейса
	Создание разделов.
	Task:
	Создадим 4 подсистемы. Общее - включает все справочники, закупки - что нужно пользователю для оформления покупки товаров, продажи - для оформления продажи, сервис - служебные функции программы. Чтоб кнопки разделов программа выстроила на панели не по алфавиту, а так как мы это заводили, нужно в окне командный интерфейс выбрать нужный нам порядок.
	Decision:
	конфигурация-общее-подсистемы-сервис-основные-командный интерфейс
	Task:
	Настройка положения панелей "Такси"
	Изменим положение по умолчанию панелей
	Decision:
	Конфигурация-открыть интерфес клиентского приложения - -меняем положения разделов-
	Task:
	Можно в пользовательском интерфейсе это сделать
	Decision:
	вид-настройка панелей-меняем положения
	Управяемый интерфейс "Версия 8.2"
	Task:
	Посмотрим результаты нашей работы в интерфейсе "Версия 8.2".
	Decision:
	Сервис-Параметры-+формы в отдельных окнах
	Task:
	Интерфейс обычного приложения
	запустить программу в режиме обычного приложения
	Decision:
	поставить галочку в управляемое приложение и обычное приложение в Конфигуратор-сервис-параметры -запустить через - откладка - начало откладки - толстый клиент (обычное приложение) - начать откладку
	Decision:
	https://github.com/David138it/MyPortfolio/tree/main/TaskDecision/1c-Evrisoft/
	Source:
	1. Практическое пособие разработчика М.Г. Радченко, Е.Ю. Хрусталева
	2. https://www.youtube.com/channel/UC124tAuP11GlaGpK3YGHzlw
	Task:
	Установка 1с в Ubuntu 20.04
	Decision:
	:~$ tar xvzf training_8_3_19_1150.deb64.tar.gz
	  1c-enterprise-8.3.19.1150-training-nls_8.3.19-1150_amd64.deb
	  1c-enterprise-8.3.19.1150-training_8.3.19-1150_amd64.deb
	  1c-enterprise-license-tools-0.14.3+7-linux-x86_64.tar.gz
	:~$ sudo apt -y install libwebkitgtk-3.0-0
	  Reading package lists... Done
	  Building dependency tree       
	  Reading state information... Done
	  Package libwebkitgtk-3.0-0 is not available, but is referred to by another package.
	  This may mean that the package is missing, has been obsoleted, or
	  is only available from another source
	  E: Package 'libwebkitgtk-3.0-0' has no installation candidate
	:~$ sudo cat /etc/apt/sources.list
	# deb cdrom:[Ubuntu 20.04.2.0 LTS _Focal Fossa_ - Release amd64 (20210209.1)]/ focal main restricted
	deb-src http://archive.ubuntu.com/ubuntu focal main restricted #Added by software-properties
	# See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to
	# newer versions of the distribution.
	deb http://us.archive.ubuntu.com/ubuntu/ focal main restricted
	deb-src http://us.archive.ubuntu.com/ubuntu/ focal multiverse universe main restricted #Added by software-properties
	## Major bug fix updates produced after the final release of the
	## distribution.
	deb http://us.archive.ubuntu.com/ubuntu/ focal-updates main restricted
	deb-src http://us.archive.ubuntu.com/ubuntu/ focal-updates multiverse universe main restricted #Added by software-properties
	## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu
	## team. Also, please note that software in universe WILL NOT receive any
	## review or updates from the Ubuntu security team.
	deb http://us.archive.ubuntu.com/ubuntu/ focal universe
	# deb-src http://us.archive.ubuntu.com/ubuntu/ focal universe
	deb http://us.archive.ubuntu.com/ubuntu/ focal-updates universe
	# deb-src http://us.archive.ubuntu.com/ubuntu/ focal-updates universe
	## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu
	## team, and may not be under a free licence. Please satisfy yourself as to
	## your rights to use the software. Also, please note that software in
	## multiverse WILL NOT receive any review or updates from the Ubuntu
	## security team.
	deb http://us.archive.ubuntu.com/ubuntu/ focal multiverse
	# deb-src http://us.archive.ubuntu.com/ubuntu/ focal multiverse
	deb http://us.archive.ubuntu.com/ubuntu/ focal-updates multiverse
	# deb-src http://us.archive.ubuntu.com/ubuntu/ focal-updates multiverse
	## N.B. software from this repository may not have been tested as
	## extensively as that contained in the main release, although it includes
	## newer versions of some applications which may provide useful features.
	## Also, please note that software in backports WILL NOT receive any review
	## or updates from the Ubuntu security team.
	deb http://us.archive.ubuntu.com/ubuntu/ focal-backports main restricted universe multiverse
	deb-src http://us.archive.ubuntu.com/ubuntu/ focal-backports main restricted universe multiverse #Added by software-properties
	## Uncomment the following two lines to add software from Canonical's
	## 'partner' repository.
	## This software is not part of Ubuntu, but is offered by Canonical and the
	## respective vendors as a service to Ubuntu users.
	# deb http://archive.canonical.com/ubuntu focal partner
	# deb-src http://archive.canonical.com/ubuntu focal partner
	deb http://security.ubuntu.com/ubuntu focal-security main restricted
	deb-src http://security.ubuntu.com/ubuntu focal-security multiverse universe main restricted #Added by software-properties
	deb http://security.ubuntu.com/ubuntu focal-security universe
	# deb-src http://security.ubuntu.com/ubuntu focal-security universe
	deb http://security.ubuntu.com/ubuntu focal-security multiverse
	# deb-src http://security.ubuntu.com/ubuntu focal-security multiverse
	# This system was installed using small removable media
	# (e.g. netinst, live or single CD). The matching "deb cdrom"
	# entries were disabled at the end of the installation process.
	# For information about how to configure apt package sources,
	# see the sources.list(5) manual.
	:~$ sudo vim /etc/apt/sources.list
	:~$ cat /etc/apt/sources.list
	# deb cdrom:[Ubuntu 20.04.2.0 LTS _Focal Fossa_ - Release amd64 (20210209.1)]/ focal main restricted
	deb-src http://archive.ubuntu.com/ubuntu focal main restricted #Added by software-properties
	# See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to
	# newer versions of the distribution.
	deb http://us.archive.ubuntu.com/ubuntu/ focal main restricted
	deb-src http://us.archive.ubuntu.com/ubuntu/ focal multiverse universe main restricted #Added by software-properties
	## Major bug fix updates produced after the final release of the
	## distribution.
	deb http://us.archive.ubuntu.com/ubuntu/ focal-updates main restricted
	deb-src http://us.archive.ubuntu.com/ubuntu/ focal-updates multiverse universe main restricted #Added by software-properties
	## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu
	## team. Also, please note that software in universe WILL NOT receive any
	## review or updates from the Ubuntu security team.
	deb http://us.archive.ubuntu.com/ubuntu/ focal universe
	# deb-src http://us.archive.ubuntu.com/ubuntu/ focal universe
	deb http://us.archive.ubuntu.com/ubuntu/ focal-updates universe
	# deb-src http://us.archive.ubuntu.com/ubuntu/ focal-updates universe
	## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu
	## team, and may not be under a free licence. Please satisfy yourself as to
	## your rights to use the software. Also, please note that software in
	## multiverse WILL NOT receive any review or updates from the Ubuntu
	## security team.
	deb http://us.archive.ubuntu.com/ubuntu/ focal multiverse
	# deb-src http://us.archive.ubuntu.com/ubuntu/ focal multiverse
	deb http://us.archive.ubuntu.com/ubuntu/ focal-updates multiverse
	# deb-src http://us.archive.ubuntu.com/ubuntu/ focal-updates multiverse
	## N.B. software from this repository may not have been tested as
	## extensively as that contained in the main release, although it includes
	## newer versions of some applications which may provide useful features.
	## Also, please note that software in backports WILL NOT receive any review
	## or updates from the Ubuntu security team.
	deb http://us.archive.ubuntu.com/ubuntu/ focal-backports main restricted universe multiverse
	deb-src http://us.archive.ubuntu.com/ubuntu/ focal-backports main restricted universe multiverse #Added by software-properties
	## Uncomment the following two lines to add software from Canonical's
	## 'partner' repository.
	## This software is not part of Ubuntu, but is offered by Canonical and the
	## respective vendors as a service to Ubuntu users.
	# deb http://archive.canonical.com/ubuntu focal partner
	# deb-src http://archive.canonical.com/ubuntu focal partner
	deb http://security.ubuntu.com/ubuntu focal-security main restricted
	deb-src http://security.ubuntu.com/ubuntu focal-security multiverse universe main restricted #Added by software-properties
	deb http://security.ubuntu.com/ubuntu focal-security universe
	# deb-src http://security.ubuntu.com/ubuntu focal-security universe
	deb http://security.ubuntu.com/ubuntu focal-security multiverse
	# deb-src http://security.ubuntu.com/ubuntu focal-security multiverse
	# This system was installed using small removable media
	# (e.g. netinst, live or single CD). The matching "deb cdrom"
	# entries were disabled at the end of the installation process.
	# For information about how to configure apt package sources,
	# see the sources.list(5) manual.
	deb http://ru.archive.ubuntu.com/ubuntu/ bionic main universe
	:~$ sudo apt-get update
	:~$ sudo apt -y install libwebkitgtk-3.0-0
	:~$ sudo apt -y install ./1c-enterprise-8.3.19.1150-training_8.3.19-1150_amd64.deb
	Task:
	Во время установки 1C 8.3 в Ubuntu 20.04 выходят такие ошибки:
	:~$ sudo apt -y install libwebkitgtk-3.0-0
	  Reading package lists... Done
	  Building dependency tree       
	  Reading state information... Done
	  Package libwebkitgtk-3.0-0 is not available, but is referred to by another package.
	  This may mean that the package is missing, has been obsoleted, or
	  is only available from another source
	  E: Package 'libwebkitgtk-3.0-0' has no installation candidate
	Decision:
	:~$ sudo cat /etc/apt/sources.list
	# deb cdrom:[Ubuntu 20.04.2.0 LTS _Focal Fossa_ - Release amd64 (20210209.1)]/ focal main restricted
	deb-src http://archive.ubuntu.com/ubuntu focal main restricted #Added by software-properties
	# See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to
	# newer versions of the distribution.
	deb http://us.archive.ubuntu.com/ubuntu/ focal main restricted
	deb-src http://us.archive.ubuntu.com/ubuntu/ focal multiverse universe main restricted #Added by software-properties
	## Major bug fix updates produced after the final release of the
	## distribution.
	deb http://us.archive.ubuntu.com/ubuntu/ focal-updates main restricted
	deb-src http://us.archive.ubuntu.com/ubuntu/ focal-updates multiverse universe main restricted #Added by software-properties
	## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu
	## team. Also, please note that software in universe WILL NOT receive any
	## review or updates from the Ubuntu security team.
	deb http://us.archive.ubuntu.com/ubuntu/ focal universe
	# deb-src http://us.archive.ubuntu.com/ubuntu/ focal universe
	deb http://us.archive.ubuntu.com/ubuntu/ focal-updates universe
	# deb-src http://us.archive.ubuntu.com/ubuntu/ focal-updates universe
	## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu
	## team, and may not be under a free licence. Please satisfy yourself as to
	## your rights to use the software. Also, please note that software in
	## multiverse WILL NOT receive any review or updates from the Ubuntu
	## security team.
	deb http://us.archive.ubuntu.com/ubuntu/ focal multiverse
	# deb-src http://us.archive.ubuntu.com/ubuntu/ focal multiverse
	deb http://us.archive.ubuntu.com/ubuntu/ focal-updates multiverse
	# deb-src http://us.archive.ubuntu.com/ubuntu/ focal-updates multiverse
	## N.B. software from this repository may not have been tested as
	## extensively as that contained in the main release, although it includes
	## newer versions of some applications which may provide useful features.
	## Also, please note that software in backports WILL NOT receive any review
	## or updates from the Ubuntu security team.
	deb http://us.archive.ubuntu.com/ubuntu/ focal-backports main restricted universe multiverse
	deb-src http://us.archive.ubuntu.com/ubuntu/ focal-backports main restricted universe multiverse #Added by software-properties
	## Uncomment the following two lines to add software from Canonical's
	## 'partner' repository.
	## This software is not part of Ubuntu, but is offered by Canonical and the
	## respective vendors as a service to Ubuntu users.
	# deb http://archive.canonical.com/ubuntu focal partner
	# deb-src http://archive.canonical.com/ubuntu focal partner
	deb http://security.ubuntu.com/ubuntu focal-security main restricted
	deb-src http://security.ubuntu.com/ubuntu focal-security multiverse universe main restricted #Added by software-properties
	deb http://security.ubuntu.com/ubuntu focal-security universe
	# deb-src http://security.ubuntu.com/ubuntu focal-security universe
	deb http://security.ubuntu.com/ubuntu focal-security multiverse
	# deb-src http://security.ubuntu.com/ubuntu focal-security multiverse
	# This system was installed using small removable media
	# (e.g. netinst, live or single CD). The matching "deb cdrom"
	# entries were disabled at the end of the installation process.
	# For information about how to configure apt package sources,
	# see the sources.list(5) manual.
	:~$ sudo vim /etc/apt/sources.list
	:~$ cat /etc/apt/sources.list
	# deb cdrom:[Ubuntu 20.04.2.0 LTS _Focal Fossa_ - Release amd64 (20210209.1)]/ focal main restricted
	deb-src http://archive.ubuntu.com/ubuntu focal main restricted #Added by software-properties
	# See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to
	# newer versions of the distribution.
	deb http://us.archive.ubuntu.com/ubuntu/ focal main restricted
	deb-src http://us.archive.ubuntu.com/ubuntu/ focal multiverse universe main restricted #Added by software-properties
	## Major bug fix updates produced after the final release of the
	## distribution.
	deb http://us.archive.ubuntu.com/ubuntu/ focal-updates main restricted
	deb-src http://us.archive.ubuntu.com/ubuntu/ focal-updates multiverse universe main restricted #Added by software-properties
	## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu
	## team. Also, please note that software in universe WILL NOT receive any
	## review or updates from the Ubuntu security team.
	deb http://us.archive.ubuntu.com/ubuntu/ focal universe
	# deb-src http://us.archive.ubuntu.com/ubuntu/ focal universe
	deb http://us.archive.ubuntu.com/ubuntu/ focal-updates universe
	# deb-src http://us.archive.ubuntu.com/ubuntu/ focal-updates universe
	## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu
	## team, and may not be under a free licence. Please satisfy yourself as to
	## your rights to use the software. Also, please note that software in
	## multiverse WILL NOT receive any review or updates from the Ubuntu
	## security team.
	deb http://us.archive.ubuntu.com/ubuntu/ focal multiverse
	# deb-src http://us.archive.ubuntu.com/ubuntu/ focal multiverse
	deb http://us.archive.ubuntu.com/ubuntu/ focal-updates multiverse
	# deb-src http://us.archive.ubuntu.com/ubuntu/ focal-updates multiverse
	## N.B. software from this repository may not have been tested as
	## extensively as that contained in the main release, although it includes
	## newer versions of some applications which may provide useful features.
	## Also, please note that software in backports WILL NOT receive any review
	## or updates from the Ubuntu security team.
	deb http://us.archive.ubuntu.com/ubuntu/ focal-backports main restricted universe multiverse
	deb-src http://us.archive.ubuntu.com/ubuntu/ focal-backports main restricted universe multiverse #Added by software-properties
	## Uncomment the following two lines to add software from Canonical's
	## 'partner' repository.
	## This software is not part of Ubuntu, but is offered by Canonical and the
	## respective vendors as a service to Ubuntu users.
	# deb http://archive.canonical.com/ubuntu focal partner
	# deb-src http://archive.canonical.com/ubuntu focal partner
	deb http://security.ubuntu.com/ubuntu focal-security main restricted
	deb-src http://security.ubuntu.com/ubuntu focal-security multiverse universe main restricted #Added by software-properties
	deb http://security.ubuntu.com/ubuntu focal-security universe
	# deb-src http://security.ubuntu.com/ubuntu focal-security universe
	deb http://security.ubuntu.com/ubuntu focal-security multiverse
	# deb-src http://security.ubuntu.com/ubuntu focal-security multiverse
	# This system was installed using small removable media
	# (e.g. netinst, live or single CD). The matching "deb cdrom"
	# entries were disabled at the end of the installation process.
	# For information about how to configure apt package sources,
	# see the sources.list(5) manual.
	deb http://ru.archive.ubuntu.com/ubuntu/ bionic main universe
	:~$ sudo apt-get update
	:~$ sudo apt -y install libwebkitgtk-3.0-0
	Task:
	Создать внешнюю печатную форму
	Decision:
	файл->новый->внешняя обработка->Имя:ЗаказВнешний->Действие->открыть модуль объекта
	Функция СведенияОВнешнейОбработке() Экспорт
	    ПараметрыРегистрации = Новый Структура;
	    МассивНазначений = Новый Массив;
	    МассивНазначений.Добавить("Документ.РеализацияТоваровУслуг"); //Указываем документ к которому делаем внешнюю печ. форму
	    ПараметрыРегистрации.Вставить("Вид", "ПечатнаяФорма"); //может быть - ПечатнаяФорма, ЗаполнениеОбъекта, ДополнительныйОтчет, СозданиеСвязанныхОбъектов...
	    ПараметрыРегистрации.Вставить("Назначение", МассивНазначений);
	    ПараметрыРегистрации.Вставить("Наименование", "Заказ для реализации товаров"); //имя под которым обработка будет зарегестрирована в справочнике внешних обработок
	    ПараметрыРегистрации.Вставить("БезопасныйРежим", ЛОЖЬ);
	    ПараметрыРегистрации.Вставить("Версия", "1.0");
	    ПараметрыРегистрации.Вставить("Информация", "Эту ВПФ мы сделали для того что бы посмотреть возможности БСП ");
	    ТаблицаКоманд = ПолучитьТаблицуКоманд();
	    ДобавитьКоманду(ТаблицаКоманд, "Заказ внешний", "ЗаказВнешний", "ВызовСерверногоМетода", Истина, "ПечатьMXL");
	    ПараметрыРегистрации.Вставить("Команды", ТаблицаКоманд);
	    Возврат ПараметрыРегистрации;
	КонецФункции // СведенияОВнешнейОбработке()
	Функция ПолучитьТаблицуКоманд()
	    Команды = Новый ТаблицаЗначений;
	    Команды.Колонки.Добавить("Представление", Новый ОписаниеТипов("Строка"));//как будет выглядеть описание печ.формы для пользователя
	    Команды.Колонки.Добавить("Идентификатор", Новый ОписаниеТипов("Строка")); //имя макета печ.формы
	    Команды.Колонки.Добавить("Использование", Новый ОписаниеТипов("Строка")); //ВызовСерверногоМетода
	    Команды.Колонки.Добавить("ПоказыватьОповещение", Новый ОписаниеТипов("Булево"));
	    Команды.Колонки.Добавить("Модификатор", Новый ОписаниеТипов("Строка"));
	    Возврат Команды;
	КонецФункции
	Процедура ДобавитьКоманду(ТаблицаКоманд, Представление, Идентификатор, Использование, ПоказыватьОповещение = Ложь, Модификатор = "")
	    НоваяКоманда = ТаблицаКоманд.Добавить();
	    НоваяКоманда.Представление = Представление;
	    НоваяКоманда.Идентификатор = Идентификатор;
	    НоваяКоманда.Использование = Использование;
	    НоваяКоманда.ПоказыватьОповещение = ПоказыватьОповещение;
	    НоваяКоманда.Модификатор = Модификатор;
	КонецПроцедуры
	Процедура Печать(МассивОбъектов, КоллекцияПечатныхФорм, ОбъектыПечати, ПараметрыВывода) Экспорт
	    УправлениеПечатью.ВывестиТабличныйДокументВКоллекцию(
	        КоллекцияПечатныхФорм,
	        "ЗаказВнешний",
	        "Заказ внешний",
	        СформироватьПечатнуюФорму(МассивОбъектов[0], ОбъектыПечати));
	КонецПроцедуры // Печать()
	Функция СформироватьПечатнуюФорму(СсылкаНаОбъект, ОбъектПечати)
	КонецФункции // СформироватьПечатнуюФорму(СсылкаНаОбъект, ОбъектПечати)()

	Макеты->Добавить->Имя: МакетЗаказа->Выделить область->Объединить

	    Заказ на товар № [НомерРеализации] от [ДатаРеализации]

	Свойства->макет->заполнение:шаблон

	    Товар,Количество,Цена,Сумма

	Выделить заполненные ячейки->Таблица->Имя->Назначить имя->Шапка->Скопируем:Товар,Количество,Цена,Сумма->Свойства->Макет->Заполнение->Параметр->Выделить заполненные ячейки->Таблица->Имя->Назначить имя->СтрокаТЧ

	    Итого:, СуммаИтого, Ответственный,Ответственный

	Выделить: СуммаИтого->Свойства->Макет->Заполнение->Параметр->Выделить:Ответственный->Свойства->Макет->Заполнение->Параметр->Выделить заполненные ячейки->Таблица->Имя->Назначить имя->Подвал

	Функция СформироватьПечатнуюФорму(СсылкаНаОбъект, ОбъектПечати)  
	    ТабличныйДокумент = Новый ТабличныйДокумент;
	    МакетОбработки=ПолучитьМакет("МакетЗаказа");
	    ОбластьШапки=МакетОбработки.ПолучитьОбласть("Шапка");
	    ОбластьШапки.Параметры.НомерРеализации=СсылкаНаОбъект.Номер;
	    ОбластьШапки.Параметры.ДатаРеализации=Формат(СсылкаНаОбъект.Дата, )
	КонецФункции

	Конструктор форматной строки->Дата->Локальный формат даты+->Проверим товары,цена,сумма,количество,ответственный в конфигураторе документы->РеализацияТоваровУслуг->Табличные части->Таблицы->товары,цена,сумма,количество->Реквизиты->->Контрагент->Находим объекты

	Функция СформироватьПечатнуюФорму(СсылкаНаОбъект, ОбъектПечати)  
	    ТабличныйДокумент = Новый ТабличныйДокумент;
	    МакетОбработки=ПолучитьМакет("МакетЗаказа");
	    ОбластьШапки=МакетОбработки.ПолучитьОбласть("Шапка");
	    ОбластьШапки.Параметры.НомерРеализации=СсылкаНаОбъект.Номер;
	    ОбластьШапки.Параметры.ДатаРеализации=Формат(СсылкаНаОбъект.Дата, "ДЛФ=DD");
	    ТабличныйДокумент.Вывести(ОбластьШапки);
	    ОбластьСтроки=МакетОбработки.ПолучитьОбласть("СтрокаТЧ");
	    Для каждого ТекущаяСтрока Из СсылкаНаОбъект.Товары Цикл
	        ОбластьСтроки.Параметры.Товар=ТекущаяСтрока.Номенклатура;
	        ОбластьСтроки.Параметры.Цена=ТекущаяСтрока.Цена;
	        ОбластьСтроки.Параметры.Количество=ТекущаяСтрока.Количество;
	        ОбластьСтроки.Параметры.Сумма=ТекущаяСтрока.Сумма;
	        ТабличныйДокумент.Вывести(ОбластьСтроки);   
	    КонецЦикла;
	    ОбластьПодвала=МакетОбработки.ПолучитьОбласть("Подвал");
	    ОбластьПодвала.Параметры.Ответственный=СсылкаНаОбъект.Контрагент;
	    //ОбластьПодвала.Параметры.СуммаИтого=СсылкаНаОбъект.Товары.Итог(Сумма);
	    ТабличныйДокумент.Вывести(ОбластьПодвала);
	    Возврат ТабличныйДокумент;  
	КонецФункции
	Decision:
	НСИ и Администрирование->Печатные формы, отчеты и обработки->Дополнительные отчеты и обработки->Создать->ЗаказВнешний->Записать и закрыть->Продажи->Документ продажи->Печать->ЗаказВнешний
	Source:
	1. https://programmist1s.ru/vneshnie-pechatnyie-formyi-v-1s/
	Task:
	Как хранить картинки
	Для каждого товара, который хранится в справочнике номенклатура, нужно хранить его изображение. То есть пользователь должен иметь возможность в форме нажать на кнопку и выбрать картинку и в резльтате картинка должна отобразиться на форме.
	Decision:
	    Справчоник-номенклатура-реквизиты-добавить-имя-изображение-тип данных - хранилище значений - ок - формы - форма элемента - реквизит - добавить - Имя - адресКартинки - ок - перетаскиваем в группу - вид - поле картинки - гиберссылка + - оформление - размер картинки - пропорциональный - использованиен - текстНе выбраннойКартинки - Нажмите для выбора карнтинки - ок - свойства -адрес Картинки - события - нажатие - на клиенте
	&НаКлиенте
	Процедура АдресКартинкиНажатие(Элемент, СтандартнаяОбработка)
	    //добавляем картинку
	    Оповещение  =  Новый ОписаниеОповещения("АдресКартинкиНажатиеЗавершение", ЭтотОбъект);
	    НачатьПомещениеФайла(Оповещение,,,Истина, УникальныйИдентификатор);
	    СтандартнаяОбработка = Ложь;
	КонецПроцедуры    
	&НаКлиенте
	Процедура АдресКартинкиНажатиеЗавершение(Результат, Адрес, ПомещаемыйФайл, ДополнительныеПараметры) Экспорт
	    Если НЕ Результат Тогда
	        Возврат;
	    КонецЕсли;
	    АдресКартинки=Адрес;
	    Модифицированность=Истина;
	КонецПроцедуры

	Запуск

	    формы - форма элемента - формы - свойства - события - ПередЗаписьюНаСервере

	&НаСервере
	Процедура ПередЗаписьюНаСервере(Отказ, ТекущийОбъект, ПараметрыЗаписи)
	    Если ЭтоАдресВременногоХранилища(АдресКартинки) Тогда
	        ТекущийОбъект.Изображение=Новый ХранилищеЗначения(ПолучитьИзВременногоХранилища(АдресКартинки));
	    КонецЕсли;
	КонецПроцедуры

	    формы - форма элемента - формы - свойства - собыия - ПриСозданииНаСервере

	&НаСервере
	Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
	    АдресКартинки=ПолучитьНавигационнуюСсылку(Объект.Ссылка, "Изображение");
	КонецПроцедуры

	Запуск

	    формы - форма элемента - добавить команду - ОчиститьИзображение - представление - выбрать картинку - отображение - картинка - ок - перетаскиваем в форму - действие команды - на клиенте

	&НаСервере
	Процедура ПередЗаписьюНаСервере(Отказ, ТекущийОбъект, ПараметрыЗаписи)
	    Если ЭтоАдресВременногоХранилища(АдресКартинки) Тогда
	        ТекущийОбъект.Изображение=Новый ХранилищеЗначения(ПолучитьИзВременногоХранилища(АдресКартинки));
	    КонецЕсли;     
	    Если ПустаяСтрока(АдресКартинки) Тогда
	        ТекущийОбъект.Изображение = Неопределено;
	    КонецЕсли;
	КонецПроцедуры
	&НаСервере
	Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
	    АдресКартинки=ПолучитьНавигационнуюСсылку(Объект.Ссылка, "Изображение");
	КонецПроцедуры
	&НаКлиенте
	Процедура ОчиститьИзображение(Команда)
	    АдресКартинки="";
	    Модифицированность=Истина;
	КонецПроцедуры
	Task:
	Загрузить данные из внешнего файла в справочник контрагенты.
	Decision:
	Для запуска можно установить 1с учебную версию: online.1c.ru - добавить новую базу - запустить конфигуратор - Администрирование -загрузить базу, выбрав файл с расширением *.dt - запустить
	Обработка-создать-загрузка данных из файла-подсистема--данные-реквизит-добавить-ПутьКФайлу,ФорматФайла-длина строки-256,3-табличная часть-добавить-данные файла-добавить реквизит-наименование,полное наименование,унп-длина строки-150,150,9-формы-добавить форму обработки-везде+, кроме номер строки-ок-камндная панель-свойства--атозаполнение-данные файла-свойства-использование--изменить состав строк-путь к файлу-сфойства-использование-кнопка выбора-да-формат файла-свойства-использование-список выбора-значение-TXT,CSV,XLS,DBF,XML-Основные-Вид-Полеперключателя-Вид переключателя-Тумблер-ок-команды-добавить-ПрочитатьФайл,ЗаписатьДанные-перетаскиваем в командную панель таблицы ДанныеФайла-путь к Файлу-свойства-события-началов выбора-на клиенте

	&НаКлиенте
	Процедура ПутьКФайлуНачалоВыбора(Элемент, ДанныеВыбора, СтандартнаяОбработка)
	    Проводник=Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.Открытие);
	    Проводник.Заголовок="Выберитефайл с контрагентами";
	    Если Объект.ФорматФайла="TXT" Тогда
	        Фильтр="Текстовый документ (*.txt)|*.txt";
	    ИначеЕсли Объект.ФорматФайла="CSV" Тогда
	        Фильтр="Текстовый документ (*.csv)|*.csv";
	    ИначеЕсли Объект.ФорматФайла="XLS" Тогда
	        Фильтр="Файл ЕКСЕЛЬ (*.xls)|*.xls";
	    ИначеЕсли Объект.ФорматФайла="DBF" Тогда
	        Фильтр="Таблица DBF (*.dbf)|*.dbf";
	    ИначеЕсли Объект.ФорматФайла="XML" Тогда
	        Фильтр="XML-файл (*.xml)|*.xml";
	    Иначе
	        Возврат;
	    КонецЕсли;
	    Проводник.Фильтр=Фильтр;
	    Оповещение=Новый ОписаниеОповещения("ПослеВыбораФайла", ЭтотОбъект);
	    Проводник.Показать(Оповещение);
	КонецПроцедуры  

	&НаКлиенте
	Процедура ПослеВыбораФайла(ВыбранныеФайлы, ДополнительныеПараметры) Экспорт
	    Если ВыбранныеФайлы=Неопределено Тогда
	        Возврат;
	    КонецЕсли;
	    Объект.ПутьКФайлу=ВыбранныеФайлы[0];
	КонецПроцедуры  
	Task:
	Как вывести штрихкод в печатную форму
	Decision:
	        установить элемент управления «1С: Печать штрихкодов» - its.1c.ru - ок - открыть обработку - макеты - Макет_ТолстыйКлиент - выделить поля от 2 до 8 - таблица -имена - назначить - Штрихкод - таблица - рисунки - вставить объект - мышкой выделяем нужную область в виде прямоугольника - элемент управления - 1сV8 печать штрихкодов - ок на добавленный фрагмент - свойства - КартинкаШтрихкода - оформление - линия - нет линий - ок - формы - ФормаОбычная - вывести штрихкод - ВывестиШтрихкод -

	Процедура ВывестиШтрихкод(Кнопка)    
	        ЭлементыФормы.ТабДок.Очистить(); //1 выполним очистку документа    
	        Макет = ПолучитьМакет("Макет_ТолстыйКлиент"); //2 Получить макет
	        Область = Макет.ПолучитьОбласть("Штрихкод"); //3 получить область макета
	        Область.Рисунки.КартинкаШтрихкода.Объект.ТипКода = 4; //4 обратимся к элементу управления
	        Область.Рисунки.КартинкаШтрихкода.Объект.Сообщение = Штрихкод; //5 необходимо вывести область сообщение
	        ЭлементыФормы.ТабДок.Вывести(Область); //6
	КонецПроцедуры

	        запустить у ее нужно в режиме толстый клиент - сервис - параметры - запуск 1с предприятия - +толстый клиент обычное приложение - ок - запуск
	Task:
	Вывод штрихкода в печатную форму 1С. Тонкий клиент.
	Decision:
	        Загрузить внешнюю компоненту печати штрихкодов в общий макет - its.1c.ru - после установки создать новую информационную базу - общие - общие макеты - копируем в нашу конфигурацию 4 макета (КомпонентаПечатиШтрихкодов....) - смотрим также код в демо конфе справчоник - товары - открыть модуль команды - копируем в нашу конифгурацию код:
	Функция ПолучитьКартинкуШтрихкода()
	        // В зависимости от типа платформы подключим соответствующую внешнюю компоненту
	        ИнформацияОСистеме = Новый СистемнаяИнформация;
	        Если ИнформацияОСистеме.ТипПлатформы = ТипПлатформы.Windows_x86 Тогда
	                ПодключитьВнешнююКомпоненту("ОбщийМакет.КомпонентаПечатиШтрихкодовWindows32", "КартинкаШтрихкода", ТипВнешнейКомпоненты.Native);
	        ИначеЕсли ИнформацияОСистеме.ТипПлатформы = ТипПлатформы.Windows_x86_64 Тогда
	                ПодключитьВнешнююКомпоненту("ОбщийМакет.КомпонентаПечатиШтрихкодовWindows64", "КартинкаШтрихкода", ТипВнешнейКомпоненты.Native);
	        ИначеЕсли ИнформацияОСистеме.ТипПлатформы = ТипПлатформы.Linux_x86 Тогда
	                ПодключитьВнешнююКомпоненту("ОбщийМакет.КомпонентаПечатиШтрихкодовLinux32", "КартинкаШтрихкода", ТипВнешнейКомпоненты.Native);          
	        Иначе
	                ПодключитьВнешнююКомпоненту("ОбщийМакет.КомпонентаПечатиШтрихкодовLinux64", "КартинкаШтрихкода", ТипВнешнейКомпоненты.Native);
	        КонецЕсли;
	        // Создадим объект внешней компоненты
	        Компонент = Новый("AddIn.КартинкаШтрихкода.Barcode");
	        // Если нет возможности рисовать
	        Если НЕ Компонент.ГрафикаУстановлена Тогда
	                // То картинку сформировать не сможем
	                Возврат Неопределено;
	        КонецЕсли;
	        // Если в системе установлен шрифт Tahoma
	        Если Компонент.НайтиШрифт("Tahoma") = Истина Тогда
	                // Выбираем его как шрифт для формирования картинки
	                Компонент.Шрифт = "Tahoma";
	        Иначе
	                // Шрифт Tahoma в системе отсутствует
	                // Обойдем все доступные компоненте шрифты
	                Для Сч = 0 По Компонент.КоличествоШрифтов -1 Цикл
	                        // Получим очередной шрифт, доступный компоненте
	                        ТекущийШрифт = Компонент.ШрифтПоИндексу(Сч);
	                        // Если шрифт доступен
	                        Если ТекущийШрифт <> Неопределено Тогда
	                                // Они и будет шрифтом для формирования штрихкода
	                                Компонент.Шрифт = ТекущийШрифт;
	                                Прервать;
	                        КонецЕсли;
	                КонецЦикла;
	        КонецЕсли;
	        // Установим размер шрифта
	        Компонент.РазмерШрифта = 12;
	        // Зададим размер картинки
	        Компонент.Ширина = 100;
	        Компонент.Высота = 90;
	        // Разрешим компоненте самой определять тип кода
	        Компонент.АвтоТип = Истина;
	        // ИЛИ установим код EAN-13
	        // Компонент.ТипКода = 1;
	        //
	        // Тип смотрим в документации на внешнюю компоненту
	        // Если код содержит контрольный символ, обязательно указываем
	        Компонент.СодержитКС = СтрДлина(ЭтотОбъект.Штрихкод) = 13;
	        // Если отображать контрольный символ не нужно
	        // Компонент.ВидимостьКС = Ложь;
	        // Формируем картинку штрихкода
	        Компонент.ЗначениеКода = ЭтотОбъект.Штрихкод;
	        // Если установленная нами ширина меньше минимально допустимой для этого штрихкода
	        Если Компонент.Ширина < Компонент.МинимальнаяШиринаКода Тогда
	                // Скорректируем ширину
	                Компонент.Ширина = Компонент.МинимальнаяШиринаКода + 10;
	        КонецЕсли;
	        // Сформируем картинку
	        ДвоичныеДанныеКартинки = Компонент.ПолучитьШтрихкод();
	        // Если картинка сформировалась
	        Если НЕ ДвоичныеДанныеКартинки = Неопределено Тогда
	                // Формируем из двоичных данных
	                Возврат Новый Картинка(ДвоичныеДанныеКартинки);
	        КонецЕсли;
	        Возврат Неопределено;
	КонецФункции

	        вставим ее в обработку ВыводШтрихкодаВПечатнуюФорму с директивыой &НаСервере - формы - ФормаУправляемая - Макеты - Макет_ТонкийКлиент - выделим область полей с 2 до 8 - таблица -имена - назначить имя - Штрихкод - наводим на поле - таблица - рисунки - картинка - выбираем картинку с .пнг - свойства картинки - КартинкаШтрихкода - оформление - линия - формы - форма управляемая

	&НаСервере
	Процедура ВывестиШтрихкодНаСервере()
	        ТабДок.Очистить();
	        Макет = РеквизитФормыВЗначение("Объект").ПолучитьМакет("Макет_ТонкийКлиент");
	        Область = Макет.ПолучитьОбласть("Штрихкод");
	        КартинкаШтрихкода = ПолучитьКартинкуШтрихкода(Штрихкод);
	        Если КартинкаШтрихкода <> Неопределено Тогда
	                Область.Рисунки.КартинкаШтрихкода.Картинка = КартинкаШтрихкода;
	        КонецЕсли;
	        ТабДок.Вывести(Область);
	КонецПроцедуры
	&НаКлиенте
	Процедура ВывестиШтрихкод(Команда)
	        ВывестиШтрихкодНаСервере();
	КонецПроцедуры

	        в Функции изменить строку и вместо ЭтотШтрихкод заменить Штрихкод:

	//Функция ПолучитьКартинкуШтрихкода()
	Функция ПолучитьКартинкуШтрихкода(Штрихкод)
	        ...
	        // Формируем картинку штрихкода
	        //Компонент.ЗначениеКода = ЭтотОбъект.Штрихкод;
	        Компонент.ЗначениеКода = Штрихкод;

	        ок - запустить у ее нужно в режиме тонкий клиент - сервис - параметры - запуск 1с предприятия - +Выбрать автоматически - ок - запуск

Sql, База данных "Курьерская служба"
	Task:
	There is a company delivering orders - a Courier Service.
	The order table contains information about the order that the courier will deliver.
	FIO –recipient's full name;
	address – delivery address;
	courier – code of the employee who delivered the shipment, null by default;
	price –delivery cost;
	The order tracking trace table contains the history of various order statuses.
	state – order status code: 1 – new; 2– accepted at the warehouse; 3– delivered; 4–not delivered
	datetime– date and time of the status;
	The courier table contains information about employees (couriers and managers).
	FIO – Full name of the courier
	manager – the courier contains the manager code, null by default
	Decision:
	# sudo -i -u postgres
	[postgres@i6 ~]$ psql
	postgres=# CREATE DATABASE CourierService;
	CREATE DATABASE
	postgres=# \c courierservice
	Вы подключены к базе данных "courierservice" как пользователь "postgres".
	courierservice=# CREATE TABLE employees (
	 id SERIAL PRIMARY KEY,
	 manager_id INT REFERENCES employees(id),
	 full_name VARCHAR,
	 address VARCHAR,
	 phone VARCHAR,
	 hired_at TIMESTAMP,
	 fired_at TIMESTAMP
	 );
	CREATE TABLE
	courierservice=# CREATE TABLE order_states (
	 id SERIAL PRIMARY KEY,
	 state VARCHAR
	 );
	CREATE TABLE
	courierservice=# CREATE TABLE orders (
	 id SERIAL PRIMARY KEY,
	 customer VARCHAR,
	 address VARCHAR,
	 courier_id INT REFERENCES employees(id),
	 price NUMERIC
	 );
	CREATE TABLE
	courierservice=# CREATE TABLE trace (
	 id BIGSERIAL PRIMARY KEY,
	 state_id INT REFERENCES order_states(id),
	 order_id INT REFERENCES orders(id),
	 updated_at TIMESTAMP
	 );
	CREATE TABLE
	courierservice=# INSERT INTO employees (manager_id, full_name, address, phone, hired_at, fired_at)
	 VALUES ('1', 'Иванов Иван Иванович', 'Невский проспект, 11', '+790865454', '2022-05-04 12:10:57', '2022-05-006 13:10:57'),
	 ('2', 'Иванова Анна Ивановна', 'Набережная реки Мойки, 48', '+790865454', '2022-05-04 12:10:57', '2022-05-006 13:10:57');
	INSERT 0 2
	courierservice=# SELECT * FROM employees;
	 id | manager_id |       full_name       |          address          |   phone    |      hired_at       |      fired_at       
	----+------------+-----------------------+---------------------------+------------+---------------------+---------------------
	  1 |          1 | Иванов Иван Иванович  | Невский проспект, 11      | +790865454 | 2022-05-04 12:10:57 | 2022-05-06 13:10:57
	  2 |          2 | Иванова Анна Ивановна | Набережная реки Мойки, 48 | +790865454 | 2022-05-04 12:10:57 | 2022-05-06 13:10:57
	(2 строки)
	courierservice=# INSERT INTO order_states (state)
	 VALUES ('новый'),
	 ('в доставке'),
	 ('доставлен'),
	 ('отменен');
	INSERT 0 4
	courierservice=# SELECT * FROM order_states;
	 id |   state    
	----+------------
	  1 | новый
	  2 | в доставке
	  3 | доставлен
	  4 | отменен
	(4 строки)
	courierservice=# INSERT INTO orders (customer, address, courier_id, price)
	 VALUES ('Иванов Алесандр Иванович', 'Баумана, 121', '2', '150'),
	 ('Иванов Андрей Иванович', 'Ленина, 122', '2', '200'),
	 ('Иванов Михаил Иванович', 'Ленина, 122', '1', '150');
	INSERT 0 3
	courierservice=# SELECT * FROM orders;
	 id |         customer         |   address    | courier_id | price
	----+--------------------------+--------------+------------+-------
	  1 | Иванов Алесандр Иванович | Баумана, 121 |          2 |   150
	  2 | Иванов Андрей Иванович   | Ленина, 122  |          2 |   200
	  3 | Иванов Михаил Иванович   | Ленина, 122  |          1 |   150
	(3 строки)
	courierservice=# INSERT INTO trace (state_id, order_id, updated_at)
	 VALUES ('4', '3', '2022-06-06 13:20:57'),
	 ('2', '2', '2022-07-07 13:20:58'),
	 ('3', '1', '2022-05-05 14:02:07');
	INSERT 0 3
	courierservice=# INSERT INTO trace (state_id, order_id, updated_at)
	 VALUES ('4', '3', '2022-06-06 13:20:57'),
	 ('4', '3', '2022-07-05 13:25:28'),
	 ('1', '3', '2022-06-05 14:01:07');
	INSERT 0 3
	courierservice=# SELECT * FROM trace;
	 id | state_id | order_id |     updated_at      
	----+----------+----------+---------------------
	  1 |        4 |        3 | 2022-06-06 13:20:57
	  2 |        2 |        2 | 2022-07-07 13:20:58
	  3 |        3 |        1 | 2022-05-05 14:02:07
	  4 |        4 |        3 | 2022-06-06 13:20:57
	  5 |        4 |        3 | 2022-07-05 13:25:28
	  6 |        1 |        3 | 2022-06-05 14:01:07
	(6 строк)
	Task:
	Выведите все доставленные заказы, которые не были приняты на склад.
	Decision:
	courierservice=# SELECT * FROM order_states;
	 id |   state    
	----+------------
	  1 | новый
	  2 | в доставке
	  3 | доставлен
	  4 | отменен
	(4 строки)
	courierservice=# SELECT * FROM orders;
	 id |         customer         |   address    | courier_id | price
	----+--------------------------+--------------+------------+-------
	  1 | Иванов Алесандр Иванович | Баумана, 121 |          2 |   150
	  2 | Иванов Андрей Иванович   | Ленина, 122  |          2 |   200
	  3 | Иванов Михаил Иванович   | Ленина, 122  |          1 |   150
	(3 строки)
	courierservice=# SELECT * FROM trace;
	 id | state_id | order_id |     updated_at      
	----+----------+----------+---------------------
	  1 |        4 |        3 | 2022-06-06 13:20:57
	  2 |        2 |        2 | 2022-07-07 13:20:58
	  3 |        3 |        1 | 2022-05-05 14:02:07
	(3 строки)
	courierservice=# SELECT orders.*
	 FROM orders
	 JOIN trace t ON t.order_id=orders.id AND t.state_id=3
	 LEFT JOIN trace t2 ON t2.order_id=orders.id AND t2.state_id=2
	 WHERE t2.id IS NULL;
	 id |         customer         |   address    | courier_id | price
	----+--------------------------+--------------+------------+-------
	  1 | Иванов Алесандр Иванович | Баумана, 121 |          2 |   150
	(1 строка)
	Task:
	Выведите курьеров доставивших больше заказов, чем их менеджеры.
	Decision:
	courierservice=# SELECT * FROM employees;
	 id | manager_id |       full_name       |          address          |   phone    |      hired_at       |      fired_at       
	----+------------+-----------------------+---------------------------+------------+---------------------+---------------------
	  1 |          1 | Иванов Иван Иванович  | Невский проспект, 11      | +790865454 | 2022-05-04 12:10:57 | 2022-05-06 13:10:57
	  2 |          2 | Иванова Анна Ивановна | Набережная реки Мойки, 48 | +790865454 | 2022-05-04 12:10:57 | 2022-05-06 13:10:57
	(2 строки)
	courierservice=# SELECT * FROM orders;
	 id |         customer         |   address    | courier_id | price
	----+--------------------------+--------------+------------+-------
	  1 | Иванов Алесандр Иванович | Баумана, 121 |          2 |   150
	  2 | Иванов Андрей Иванович   | Ленина, 122  |          2 |   200
	  3 | Иванов Михаил Иванович   | Ленина, 122  |          1 |   150
	(3 строки)
	courierservice=# SELECT * FROM trace;
	 id | state_id | order_id |     updated_at      
	----+----------+----------+---------------------
	  1 |        4 |        3 | 2022-06-06 13:20:57
	  2 |        2 |        2 | 2022-07-07 13:20:58
	  3 |        3 |        1 | 2022-05-05 14:02:07
	(3 строки)
	courierservice=# SELECT k.*
	FROM employees k
	WHERE k.manager_id
	IS NOT NULL AND
	(SELECT COUNT(*)
	    FROM orders
	    WHERE courier_id=k.id) >
	(SELECT COUNT(*)
	    FROM orders
	    WHERE courier_id=k.manager_id);
	Task:
	Выведите менеджеров и стоимость всех доставленных их курьерами заказов, за последний месяц.
	Decision:
	courierservice=# SELECT * FROM trace;
	 id | state_id | order_id |     updated_at      
	----+----------+----------+---------------------
	  1 |        4 |        3 | 2022-06-06 13:20:57
	  2 |        2 |        2 | 2022-07-07 13:20:58
	  3 |        3 |        1 | 2022-05-05 14:02:07
	(3 строки)
	courierservice=# SELECT * FROM orders;
	 id |         customer         |   address    | courier_id | price
	----+--------------------------+--------------+------------+-------
	  1 | Иванов Алесандр Иванович | Баумана, 121 |          2 |   150
	  2 | Иванов Андрей Иванович   | Ленина, 122  |          2 |   200
	  3 | Иванов Михаил Иванович   | Ленина, 122  |          1 |   150
	(3 строки)
	courierservice=# SELECT * FROM employees;
	 id | manager_id |       full_name       |          address          |   phone    |      hired_at       |      fired_at       
	----+------------+-----------------------+---------------------------+------------+---------------------+---------------------
	  1 |          1 | Иванов Иван Иванович  | Невский проспект, 11      | +790865454 | 2022-05-04 12:10:57 | 2022-05-06 13:10:57
	  2 |          2 | Иванова Анна Ивановна | Набережная реки Мойки, 48 | +790865454 | 2022-05-04 12:10:57 | 2022-05-06 13:10:57
	(2 строки)
	courierservice=# SELECT k2.*, SUM(o.price) AS price
	FROM trace t
	JOIN orders o ON o.id=t.order_id
	JOIN employees k ON k.id=o.courier_id
	JOIN employees k2 ON k2.id=k.manager_id
	WHERE t.state_id = 3 AND
	    t.updated_at>date_sub(current_date(), INTERVAL 1 MONTH)
	GROUP BY k2.id;
	Task:
	Выведите менеджеров, у которых не более трех курьеров.
	Decision:
	courierservice=# SELECT k.*, COUNT(k2.id)
	 FROM employees k
	 LEFT JOIN employees k2 ON k2.manager_id = k.id
	 WHERE k.manager_id IS NULL
	 GROUP BY k.id
	 HAVING COUNT(k2.id) < 4;
	Task:
	Выведите заказы и последний установленный у него статус. Оставить в отчете только статусы: новый и принят на склад.
	Decision:
	courierservice=# SELECT * FROM orders;
	 id |         customer         |   address    | courier_id | price
	----+--------------------------+--------------+------------+-------
	  1 | Иванов Алесандр Иванович | Баумана, 121 |          2 |   150
	  2 | Иванов Андрей Иванович   | Ленина, 122  |          2 |   200
	  3 | Иванов Михаил Иванович   | Ленина, 122  |          1 |   150
	(3 строки)
	courierservice=# SELECT * FROM trace;
	 id | state_id | order_id |     updated_at      
	----+----------+----------+---------------------
	  1 |        4 |        3 | 2022-06-06 13:20:57
	  2 |        2 |        2 | 2022-07-07 13:20:58
	  3 |        3 |        1 | 2022-05-05 14:02:07
	(3 строки)
	courierservice=# SELECT o.*,
	    (SELECT state_id
	    FROM trace WHERE order_id=o.id
	    ORDER BY updated_at DESC LIMIT 1) AS status
	FROM orders o
	HAVING status IN (1, 2);
	Decision:
	https://github.com/David138it/MyPortfolio/tree/main/TaskDecision/Engineer-Isu/Sql/
	Source:
	1. https://www.asozykin.ru/?ysclid=lk9eaatbqj18673257

Sql, База данных "Staff"
	Task:
	Сотрудники зарабатывают больше, чем их менеджеры
	Task:
	Table: Employee
	+-------------+---------+
	| Column Name | Type    |
	+-------------+---------+
	| id          | int     |
	| name        | varchar |
	| salary      | int     |
	| managerId   | int     |
	+-------------+---------+
	Напишите SQL-запрос, чтобы найти сотрудников, которые зарабатывают больше, чем их менеджеры. Верните таблицу результатов в любом порядке.
	Decision:
	postgres=# DROP TABLE IF EXISTS Employee;
	    ЗАМЕЧАНИЕ:  таблица "employee" не существует, пропускается
	    DROP TABLE
	postgres=# CREATE TABLE Employee(
	postgres(#   id INT,
	postgres(#   name VARCHAR,
	postgres(#   salary INT,
	postgres(#   managerid INT
	postgres(# );
	    CREATE TABLE
	postgres=# SELECT * FROM Employee;
	     id | name | salary | managerid
	    ----+------+--------+-----------
	    (0 строк)
	postgres=# INSERT INTO Employee(id, name, salary, managerid) VALUES (1, 'Joe', 70000, 3);
	    INSERT 0 1
	postgres=# INSERT INTO Employee(id, name, salary, managerid) VALUES (2, 'Henry', 80000, 4);
	    INSERT 0 1
	postgres=# INSERT INTO Employee(id, name, salary) VALUES (3, 'Sam', 60000);
	    INSERT 0 1
	postgres=# INSERT INTO Employee(id, name, salary) VALUES (4, 'Max', 90000);
	    INSERT 0 1
	postgres=# SELECT * FROM Employee;
	     id | name  | salary | managerid
	    ----+-------+--------+-----------
	      1 | Joe   |  70000 |         3
	      2 | Henry |  80000 |         4
	      3 | Sam   |  60000 |
	      4 | Max   |  90000 |
	    (4 строки)
	postgres=# SELECT * FROM Employee AS e JOIN Employee AS m
	postgres-# ON e.managerid = m.id;
	     id | name  | salary | managerid | id | name | salary | managerid
	    ----+-------+--------+-----------+----+------+--------+-----------
	      1 | Joe   |  70000 |         3 |  3 | Sam  |  60000 |
	      2 | Henry |  80000 |         4 |  4 | Max  |  90000 |
	    (2 строки)
	postgres=# SELECT * FROM Employee AS e JOIN Employee AS m
	ON e.managerid = m.id
	postgres-# WHERE e.salary > m.salary;
	     id | name | salary | managerid | id | name | salary | managerid
	    ----+------+--------+-----------+----+------+--------+-----------
	      1 | Joe  |  70000 |         3 |  3 | Sam  |  60000 |
	    (1 строка)
	postgres=# SELECT e.name FROM Employee AS e JOIN Employee AS m
	ON e.managerid = m.id
	WHERE e.salary > m.salary;
	     name
	    ------
	     Joe
	    (1 строка)
	postgres=# SELECT e.name AS Employee FROM Employee AS e JOIN Employee AS m
	ON e.managerid = m.id
	WHERE e.salary > m.salary;
	     employee
	    ----------
	     Joe
	    (1 строка)
	Task:
	Самая высокая зарплата в отделе
	Task:
	Table: Employee
	+--------------+---------+
	| Column Name  | Type    |
	+--------------+---------+
	| id           | int     |
	| name         | varchar |
	| salary       | int     |
	| departmentId | int     |
	+--------------+---------+
	Table: Department
	+-------------+---------+
	| Column Name | Type    |
	+-------------+---------+
	| id          | int     |
	| name        | varchar |
	+-------------+---------+
	Напишите SQL-запрос, чтобы найти сотрудников с самой высокой зарплатой в каждом из отделов.
	Верните таблицу результатов в любом порядке.
	Decision:
	postgres=# DROP TABLE IF EXISTS Employee;
	TE TABLE Employee(
	    Id INT,
	    Name VARCHAR,
	    Salary INT,
	    DepartmentId INT
	);
	    DROP TABLE IF EXISTS DROP TABLE
	postgres=# CREATE TABLE Employee(
	postgres(#     Id INT,
	postgres(#     Name VARCHAR,
	postgres(#     Salary INT,
	postgres(#     DepartmentId INT
	postgres(# );
	CREATE TABLE Department(
	    Id Int,
	    Name VARCHAR
	);
	    INSERT INCREATE TABLE
	postgres=# DROP TABLE IF EXISTS Department;
	    DROP TABLE
	postgres=# CREATE TABLE Department(
	postgres(#     Id Int,
	postgres(#     Name VARCHAR
	postgres(# );
	    CREATE TABLE
	postgres=# INSERT INTO Employee(Id, Name, Salary, DepartmentId) VALUES(1, 'Joe', 70000, 1);
	    ERT INSERT 0 1
	postgres=# INSERT INTO Employee(Id, Name, Salary, DepartmentId) VALUES(2, 'Jim', 90000, 1);
	    NSERINSERT 0 1
	postgres=# INSERT INTO Employee(Id, Name, Salary, DepartmentId) VALUES(3, 'Henry', 80000, 2);
	    O EmplINSERT 0 1
	postgres=# INSERT INTO Employee(Id, Name, Salary, DepartmentId) VALUES(4, 'Sam', 60000, 2);
	    INSERT 0 1
	postgres=# INSERT INTO Employee(Id, Name, Salary, DepartmentId) VALUES(5, 'Max', 90000, 1);
	    NSERINSERT 0 1
	postgres=# INSERT INTO Department(Id, Name) VALUES (1, 'IT');
	    INSERT INTO DepartmINSERT 0 1
	postgres=# INSERT INTO Department(Id, Name) VALUES (2, 'Sales');
	    INSERT 0 1
	postgres=# SELECT * FROM Employee;
	     id | name  | salary | departmentid
	    ----+-------+--------+--------------
	      1 | Joe   |  70000 |            1
	      2 | Jim   |  90000 |            1
	      3 | Henry |  80000 |            2
	      4 | Sam   |  60000 |            2
	      5 | Max   |  90000 |            1
	    (5 строк)
	postgres=# SELECT * FROM Department;
	     id | name
	    ----+-------
	      1 | IT
	      2 | Sales
	    (2 строки)
	postgres=# SELECT MAX(salary), departmentid FROM Employee GROUP BY departmentid;
	      max  | departmentid
	    -------+--------------
	     80000 |            2
	     90000 |            1
	    (2 строки)
	postgres=# SELECT d.name, m.max_salary
	FROM Department AS d
	JOIN (SELECT MAX(salary) AS max_salary, departmentid FROM Employee GROUP BY departmentid) AS m
	ON d.id=m.departmentid;
	     name  | max_salary
	    -------+------------
	     IT    |      90000
	     Sales |      80000
	    (2 строки)
	postgres=# SELECT d.name, e.name, m.max_salary
	postgres-# FROM Department AS d
	postgres-# JOIN (SELECT MAX(salary) AS max_salary, departmentid FROM Employee GROUP BY departmentid) AS m
	postgres-# ON d.id=m.departmentid
	postgres-# JOIN Employee AS e
	postgres-# ON e.salary=m.max_salary;
	     name  | name  | max_salary
	    -------+-------+------------
	     Sales | Henry |      80000
	     IT    | Jim   |      90000
	     IT    | Max   |      90000
	    (3 строки)
	postgres=# SELECT d.name AS Department, e.name AS Employee, m.max_salary AS Salary
	postgres-# FROM Department AS d
	IN (Spostgres-# JOIN (SELECT MAX(salary) AS max_salary, departmentid FROM EmploROUP BY departmentid) AS m
	postgres-# ON d.id=m.departmentid
	postgres-# JOIN Employee AS e
	postgres-# ON e.salary=m.max_salary;
	     department | employee | salary
	    ------------+----------+--------
	     Sales      | Henry    |  80000
	     IT         | Jim      |  90000
	     IT         | Max      |  90000
	    (3 строки)
	postgres=# SELECT d.name AS Department, e.name AS Employee, m.max_salary AS Salary
	postgres-# FROM Department AS d
	postgres-# JOIN (SELECT MAX(salary) AS max_salary, departmentid FROM Employee GROUP BY departmentid) AS m
	postgres-# ON d.id=m.departmentid
	postgres-# JOIN Employee AS e
	postgres-# ON e.salary=m.max_salary AND e.departmentid=m.departmentid;
	     department | employee | salary
	    ------------+----------+--------
	     IT         | Max      |  90000
	     IT         | Jim      |  90000
	     Sales      | Henry    |  80000
	    (3 строки)
	Decision:
	https://github.com/David138it/MyPortfolio/tree/main/TaskDecision/Engineer-Isu/Sql/
	Source:
	1. https://www.asozykin.ru/?ysclid=lk9eaatbqj18673257

Sql, База данных "Online School"
	Task:
	Вставить данные в таблицу
	Decision:
	testbd=> CREATE TABLE superheroes(       
	id SERIAL PRIMARY KEY,
	name VARCHAR(100),
	align VARCHAR(30),
	eye VARCHAR(30),
	hair VARCHAR(30),
	gender VARCHAR(30),
	appearances INT,
	year INT,
	universe VARCHAR(10)
	);
	    CREATE TABLE
	testbd=> SELECT * FROM superheroes;
	     id | name | align | eye | hair | gender | appearances | year | universe
	    ----+------+-------+-----+------+--------+-------------+------+----------
	    (0 rows)
	testbd=> INSERT INTO superheroes(name, appearances, universe)
	testbd-> VALUES ('Spider-Man', 4043,'marvel');
	    INSERT 0 1
	testbd=> SELECT * FROM superheroes;
	     id |    name    | align | eye | hair | gender | appearances | year | universe
	    ----+------------+-------+-----+------+--------+-------------+------+----------
	      1 | Spider-Man |       |     |      |        |        4043 |      | marvel
	    (1 row)
	testbd=> INSERT INTO superheroes(name, align, eye, hair,   
	testbd(> gender, appearances, year, universe)
	testbd-> VALUES ('Spider-Man (Peter Parker)', 'Good
	testbd'> Characters', 'Hazel Eyes', 'Brown Hair',
	testbd(> 'Male Characters', 4043, 1962, 'marvel');
	    INSERT 0 1
	testbd=> SELECT * FROM superheroes;
	     id |           name            |   align    |    eye     |    hair    |     gender      | appearances | year | universe
	    ----+---------------------------+------------+------------+------------+-----------------+-------------+------+----------
	      1 | Spider-Man                |            |            |            |                 |        4043 |      | marvel
	      2 | Spider-Man (Peter Parker) | Good      +| Hazel Eyes | Brown Hair | Male Characters |        4043 | 1962 | marvel
	        |                           | Characters |            |            |                 |             |      |
	    (2 rows)
	testbd=> INSERT INTO superheroes(id, name, align, eye, hair,   
	gender, appearances, year, universe)
	VALUES (5, 'Spider-Man (Peter Parker)', 'Good
	Characters', 'Hazel Eyes', 'Brown Hair',
	'Male Characters', 4043, 1962, 'marvel');
	    INSERT 0 1
	testbd=> SELECT * FROM superheroes;
	     id |           name            |   align    |    eye     |    hair    |     gender      | appearances | year | universe
	    ----+---------------------------+------------+------------+------------+-----------------+-------------+------+----------
	      1 | Spider-Man                |            |            |            |                 |        4043 |      | marvel
	      2 | Spider-Man (Peter Parker) | Good      +| Hazel Eyes | Brown Hair | Male Characters |        4043 | 1962 | marvel
	        |                           | Characters |            |            |                 |             |      |
	      3 | Spider-Man (Peter Parker) | Good      +| Hazel Eyes | Brown Hair | Male Characters |        4043 | 1962 | marvel
	        |                           | Characters |            |            |                 |             |      |
	      5 | Spider-Man (Peter Parker) | Good      +| Hazel Eyes | Brown Hair | Male Characters |        4043 | 1962 | marvel
	        |                           | Characters |            |            |                 |             |      |
	    (4 rows)
	Task:
	Изменить данные в таблице
	Decision:
	testbd=> UPDATE superheroes
	SET name='Batman',
	universe='dc'
	WHERE id=1;
	UPDATE 1
	testbd=> SELECT * FROM superheroes;
	     id |  name  |   align    |    eye     |    hair    |     gender      | appearances | year | universe
	    ----+--------+------------+------------+------------+-----------------+-------------+------+----------
	      1 | Batman | Good      +| Hazel Eyes | Brown Hair | Male Characters |        4043 | 1962 | dc
	        |        | Characters |            |            |                 |             |      |
	    (1 row)
	testbd=> UPDATE superheroes
	SET gender='Man'
	WHERE gender='Male Characters';
	UPDATE 1
	testbd=> SELECT * FROM superheroes;
	     id |  name  |   align    |    eye     |    hair    | gender | appearances | year | universe
	    ----+--------+------------+------------+------------+--------+-------------+------+----------
	      1 | Batman | Good      +| Hazel Eyes | Brown Hair | Man    |        4043 | 1962 | dc
	        |        | Characters |            |            |        |             |      |
	    (1 row)
	Task:
	Удалить данные из таблицы
	Decision:
	testbd=> INSERT INTO superheroes(id, name, align, eye, hair,   
	gender, appearances, year, universe)
	VALUES (2, 'Spider-Man (Peter Parker)', 'Good
	Characters', 'Hazel Eyes', 'Brown Hair',
	'Male Characters', 4043, 1962, 'marvel');
	INSERT 0 1
	testbd=> SELECT * FROM superheroes;
	     id |           name            |   align    |    eye     |    hair    |     gender      | appearances | year | universe
	    ----+---------------------------+------------+------------+------------+-----------------+-------------+------+----------
	      1 | Batman                    | Good      +| Hazel Eyes | Brown Hair | Man             |        4043 | 1962 | dc
	        |                           | Characters |            |            |                 |             |      |
	      2 | Spider-Man (Peter Parker) | Good      +| Hazel Eyes | Brown Hair | Male Characters |        4043 | 1962 | marvel
	        |                           | Characters |            |            |                 |             |      |
	    (2 rows)
	testbd=> DELETE FROM superheroes
	WHERE id=2;
	DELETE 1
	testbd=> SELECT * FROM superheroes;
	     id |  name  |   align    |    eye     |    hair    | gender | appearances | year | universe
	    ----+--------+------------+------------+------------+--------+-------------+------+----------
	      1 | Batman | Good      +| Hazel Eyes | Brown Hair | Man    |        4043 | 1962 | dc
	        |        | Characters |            |            |        |             |      |
	    (1 row)
	testbd=> INSERT INTO superheroes(id, name, align, eye, hair,   
	gender, appearances, year, universe)
	VALUES (2, 'Spider-Man (Peter Parker)', 'Good
	Characters', 'Hazel Eyes', 'Brown Hair',
	'Male Characters', 4043, 1962, 'marvel');
	    INSERT 0 1
	testbd=> DELETE FROM superheroes
	WHERE gender='Male Characters';
	DELETE 1
	testbd=> SELECT * FROM superheroes;
	     id |  name  |   align    |    eye     |    hair    | gender | appearances | year | universe
	    ----+--------+------------+------------+------------+--------+-------------+------+----------
	      1 | Batman | Good      +| Hazel Eyes | Brown Hair | Man    |        4043 | 1962 | dc
	        |        | Characters |            |            |        | &
	Task:
	Удалить все данные
	Decision:
	testbd=> DELETE FROM superheroes;
	    DELETE 1
	testbd=> SELECT * FROM superheroes;
	     id | name | align | eye | hair | gender | appearances | year | universe
	    ----+------+-------+-----+------+--------+-------------+------+----------
	    (0 rows)
	Task:
	Удаление дубликатов email
	Decision:
	Table: Person
	+-------------+---------+
	| Column Name | Type    |
	+-------------+---------+
	| id          | int     |
	| email       | varchar |
	+-------------+---------+
	Task:
	Напишите SQL-запрос, чтобы удалить все дубликаты электронных писем, сохранив только одно уникальное электронное письмо с наименьшим идентификатором.
	Верните таблицу результатов в любом порядке.
	Decision:
	postgres=# CREATE TABLE person(
	postgres(#     id INT,
	postgres(#     email VARCHAR
	postgres(# );
	INSERT INTO person(id, email) VALUES (1, 'john@example.com');
	INSERT INTO person(id, email) VALUES (2, 'bob@example.com');
	INSERT INTO person(id, email) VALUES (3, 'john@example.com');
	    CREATE TABLE
	postgres=# INSERT INTO person(id, email) VALUES (1, 'john@example.com');
	postgres=# INSERT INTO person(id, email) VALUES (2, 'bob@example.com');
	postgres=# INSERT INTO person(id, email) VALUES (3, 'john@example.com');
	postgres=# INSERT INTO person(id, email) VALUES (1, 'john@example.com');
	    INSERT 0 1
	postgres=# INSERT INTO person(id, email) VALUES (2, 'bob@example.com');
	    INSERT 0 1
	postgres=# INSERT INTO person(id, email) VALUES (3, 'john@example.com');
	    INSERT 0 1
	postgres=# SELECT * FROM Person;
	     id |      email
	    ----+------------------
	      1 | john@example.com
	      2 | bob@example.com
	      3 | john@example.com
	    (3 строки)
	postgres=# SELECT MIN(id), email FROM person GROUP BY email;
	     min |      email
	    -----+------------------
	       2 | bob@example.com
	       1 | john@example.com
	    (2 строки)
	postgres=# SELECT MIN(id) FROM person GROUP BY email;
	    min
	    -----
	       2
	       1
	    (2 строки)
	postgres=# DELETE FROM person WHERE id NOT IN (SELECT MIN(id) FROM person GROUP BY email);
	    DELETE 1
	Task:
	Группировка
	Decision:
	testbd=> SELECT * FROM superheroes;
	     id | name | align | eye | hair | gender | appearances | year | universe
	    ----+------+-------+-----+------+--------+-------------+------+----------
	    (0 rows)
	testbd=> INSERT INTO superheroes(id, name, align, eye, hair,   
	gender, appearances, year, universe)
	VALUES (2, 'Spider-Man (Peter Parker)', 'Good
	Characters', 'Hazel Eyes', 'Brown Hair',
	'Male Characters', 4043, 1962, 'marvel');
	    INSERT 0 1
	testbd=> SELECT gender, COUNT(*) FROM superheroes
	testbd-> GROUP BY gender;
	         gender      | count
	    -----------------+-------
	     Male Characters |     1
	    (1 row)
	testbd=> SELECT * FROM superheroes;
	     id |           name            |   align    |    eye     |    hair    |     gender      | appearances | year | universe
	    ----+---------------------------+------------+------------+------------+-----------------+-------------+------+----------
	      2 | Spider-Man (Peter Parker) | Good      +| Hazel Eyes | Brown Hair | Male Characters |        4043 | 1962 | marvel
	        |                           | Characters |            |            |                 |             |      |
	    (1 row)
	testbd=> SELECT align, COUNT(*) FROM superheroes
	testbd-> GROUP BY align;
	       align    | count
	    ------------+-------
	     Good      +|     1
	     Characters |
	    (1 row)
	Task:
	Многоуровневая группировка данных
	Decision:
	estbd=> SELECT universe, align, COUNT(*) FROM superheroes
	GROUP BY universe, align;
	     universe |   align    | count
	    ----------+------------+-------
	     marvel   | Good      +|     1
	              | Characters |
	    (1 row)
	Task:
	Фильтрация, группировка, сортировка и лимит
	Decision:
	testbd=> SELECT hair, COUNT(*) FROM superheroes
	WHERE gender='Male Characters'
	GROUP BY hair;
	        hair    | count
	    ------------+-------
	     Brown Hair |     1
	    (1 row)
	Decision:
	testbd=> SELECT hair, COUNT(*) FROM superheroes
	WHERE gender='Male Characters'
	GROUP BY hair
	ORDER BY count(*) DESC;
	        hair    | count
	    ------------+-------
	     Brown Hair |     1
	    (1 row)
	Decision:
	testbd=> SELECT hair, COUNT(*) FROM superheroes
	WHERE gender='Male Characters'
	GROUP BY hair
	ORDER BY count(*) DESC
	LIMIT 5;
	        hair    | count
	    ------------+-------
	     Brown Hair |     1
	    (1 row)
	Task:
	Использование агрегатных функций
	Decision:
	testbd=> SELECT * FROM superheroes;
	      id  |                                 name                                  |       align        |       eye       |         hair          |         gender         | appearances | year | universe
	    ------+-----------------------------------------------------------------------+--------------------+-----------------+-----------------------+------------------------+-------------+------+----------
	        1 | Spider-Man (Peter Parker)                                             | Good Characters    | Hazel Eyes      | Brown Hair            | Male Characters        |        4043 | 1962 | marvel
	        2 | Captain America (Steven Rogers)                                       | Good Characters    | Blue Eyes       | White Hair            | Male Characters        |        3360 | 1941 | marvel
	        3 | Wolverine (James \"Logan\" Howlett)                                   | Neutral Characters | Blue Eyes       | Black Hair            | Male Characters        |        3061 | 1974 | marvel
	        4 | Iron Man (Anthony \"Tony\" Stark)                                     | Good Characters    | Blue Eyes       | Black Hair            | Male Characters        |        2961 | 1963 | marvel
	        5 | Thor (Thor Odinson)                                                   | Good Characters    | Blue Eyes       | Blond Hair            | Male Characters        |        2258 | 1950 | marvel
	        6 | Benjamin Grimm (Earth-616)                                            | Good Characters    | Blue Eyes       | No Hair               | Male Characters        |        2255 | 1961 | marvel
	        7 | Reed Richards (Earth-616)                                             | Good Characters    | Brown Eyes      | Brown Hair            | Male Characters        |        2072 | 1961 | marvel
	        8 | Hulk (Robert Bruce Banner)                                            | Good Characters    | Brown Eyes      | Brown Hair            | Male Characters        |        2017 | 1962 | marvel
	        9 | Scott Summers (Earth-616)                                             | Neutral Characters | Brown Eyes      | Brown Hair            | Male Characters        |        1955 | 1963 | marvel
	       10 | Jonathan Storm (Earth-616)                                            | Good Characters    | Blue Eyes       | Blond Hair            | Male Characters        |        1934 | 1961 | marvel
	       11 | Henry McCoy (Earth-616)                                               | Good Characters    | Blue Eyes       | Blue Hair             | Male Characters        |        1825 | 1963 | marvel
	       12 | Susan Storm (Earth-616)                                               | Good Characters    | Blue Eyes       | Blond Hair            | Female Characters      |        1713 | 1961 | marvel
	       13 | Ororo Munroe (Earth-616)                                              | Good Characters    | Blue Eyes       | White Hair            | Female Characters      |        1512 | 1975 | marvel
	       14 | Clinton Barton (Earth-616)                                            | Good Characters    | Blue Eyes       | Blond Hair            | Male Characters        |        1394 | 1964 | marvel
	       15 | Matthew Murdock (Earth-616)                                           | Good Characters    | Blue Eyes       | Red Hair              | Male Characters        |        1338 | 1964 | marvel
	testbd=> SELECT align, COUNT(*), SUM(appearances)
	testbd-> FROM superheroes
	testbd-> GROUP BY align;
	           align        | count |  sum   
	    --------------------+-------+--------
	     Bad Characters     |   489 |  29478
	     Good Characters    |   773 | 125961
	     Neutral Characters |   249 |  30513
	    (3 rows)
	Task:
	Выражения с агрегатными функциями
	Decision:
	testbd=> SELECT align, AVG(appearances),
	testbd-> SUM(appearances)/COUNT(*) AS average
	testbd-> FROM superheroes
	testbd-> GROUP BY align;
	           align        |         avg          | average
	    --------------------+----------------------+---------
	     Bad Characters     |  60.2822085889570552 |      60
	     Good Characters    | 162.9508408796895213 |     162
	     Neutral Characters | 122.5421686746987952 |     122
	    (3 rows)
	Task:
	Использование агрегатных функций
	Decision:
	testbd=> SELECT year, MIN(appearances), MAX(appearances)
	testbd-> FROM superheroes
	testbd-> GROUP BY year;
	     year | min | max  
	    ------+-----+------
	     1964 |  20 | 1394
	     1969 |  17 |  558
	     2008 |  19 |  200
	     1989 |  19 |  408
	     1991 |  18 |  500
	     1945 |  81 |   81
	     1974 |  18 | 3061
	     1943 |  34 |  140
	     1971 |  17 |  368
	     1977 |  17 |  471
	     1956 |  25 |  114
	     1940 |  17 |  373
	     1983 |  18 |  245
	     1984 |  18 |  348
	     2009 |  18 |   98
	     1958 |  25 |   25
	     2005 |  18 |  325
	     1973 |  17 |  323
	     2013 |  18 |   53
	     2003 |  18 |  238
	     1993 |  18 |  147
	     1990 |  18 |  636
	     1953 |  37 |  141
	     2002 |  20 |  171
	     1979 |  18 |  525
	     1997 |  18 |   97
	     2004 |  18 |  265
	     1980 |  19 |  886
	     1986 |  18 |  612
	     1970 |  20 |  787
	     1975 |  17 | 1512
	     1982 |  17 |  657
	testbd=> SELECT year, MIN(appearances), MAX(appearances)
	testbd-> FROM superheroes
	testbd-> GROUP BY year
	testbd-> ORDER BY year;
	     year | min | max  
	    ------+-----+------
	     1939 |  18 |  548
	     1940 |  17 |  373
	     1941 |  17 | 3360
	     1942 |  19 |   28
	     1943 |  34 |  140
	     1944 |  30 |  550
	     1945 |  81 |   81
	     1946 |  99 |   99
	     1947 | 139 |  139
	     1948 |  17 |  106
	     1949 |  26 |  532
	     1950 |  70 | 2258
	     1951 |  18 |  223
	     1953 |  37 |  141
	     1954 |  19 |   72
	     1955 |  44 |   65
	     1956 |  25 |  114
	     1958 |  25 |   25
	     1960 |  26 |  237
	     1961 |  21 | 2255
	     1962 |  21 | 4043
	     1963 |  20 | 2961
	     1964 |  20 | 1394
	     1965 |  17 | 1304
	     1966 |  17 |  696
	     1967 |  17 |  752
	     1968 |  17 | 1007
	     1969 |  17 |  558
	     1970 |  20 |  787
	     1971 |  17 |  368
	     1972 |  19 |  856
	     1973 |  17 |  323
	testbd=> SELECT year, MIN(appearances), MAX(appearances)
	testbd-> FROM superheroes
	testbd-> GROUP BY year
	testbd-> ORDER BY MAX(appearances) DESC;
	     year | min | max  
	    ------+-----+------
	     1962 |  21 | 4043
	     1941 |  17 | 3360
	     1974 |  18 | 3061
	     1963 |  20 | 2961
	     1950 |  70 | 2258
	testbd=> SELECT year, MIN(appearances),
	testbd-> MAX(appearances) AS max_ap
	testbd-> FROM superheroes
	testbd-> GROUP BY year
	testbd-> ORDER BY max_ap DESC;
	     year | min | max_ap
	    ------+-----+--------
	     1962 |  21 |   4043
	     1941 |  17 |   3360
	     1974 |  18 |   3061
	     1963 |  20 |   2961
	     1950 |  70 |   2258
	testbd=> SELECT year, MIN(appearances),
	testbd-> MAX(appearances) AS max_ap
	testbd-> FROM superheroes
	testbd-> GROUP BY year
	testbd-> ORDER BY max_ap DESC
	testbd-> LIMIT 5;
	     year | min | max_ap
	    ------+-----+--------
	     1962 |  21 |   4043
	     1941 |  17 |   3360
	     1974 |  18 |   3061
	     1963 |  20 |   2961
	     1950 |  70 |   2258
	    (5 rows)
	Task:
	Агрегатные функции без группировки
	Decision:
	testbd=> SELECT COUNT(*),
	testbd-> MIN(appearances),
	testbd-> MAX(appearances),
	testbd-> SUM(appearances),
	testbd-> AVG(appearances)
	testbd-> FROM superheroes;
	     count | min | max  |  sum   |         avg          
	    -------+-----+------+--------+----------------------
	      1511 |  17 | 4043 | 185952 | 123.0655195234943746
	    (1 row)
	Task:
	Группировка данных
	Decision:
	testbd=> SELECT hair, COUNT(*) FROM superheroes
	WHERE gender='Female Characters'
	GROUP BY hair;
	             hair          | count
	    -----------------------+-------
	     Strawberry Blond Hair |    11
	     Bald                  |     2
	     Green Hair            |     9
	     Silver Hair           |     5
	     Red Hair              |    40
	Task:
	Фильтрация групповых результатов
	Decision:
	testbd=> SELECT hair, COUNT(*) FROM superheroes
	testbd-> WHERE gender='Female Characters'
	testbd-> AND COUNT(*) > 10
	testbd-> GROUP BY hair;
	    ERROR:  aggregate functions are not allowed in WHERE
	    LINE 3: AND COUNT(*) > 10
	                ^
	testbd=> SELECT hair, COUNT(*) FROM superheroes
	testbd-> WHERE gender='Female Characters'
	testbd-> GROUP BY hair
	testbd-> HAVING COUNT(*) > 10;
	             hair          | count
	    -----------------------+-------
	     Strawberry Blond Hair |    11
	     Red Hair              |    40
	     White Hair            |    15
	     Black Hair            |   176
	     Blond Hair            |   110
	testbd=> SELECT hair, COUNT(*) FROM superheroes
	WHERE gender='Female Characters'
	GROUP BY hair
	HAVING COUNT(*) BETWEEN 50 AND 300;
	        hair    | count
	    ------------+-------
	     Black Hair |   176
	     Blond Hair |   110
	     Brown Hair |    63
	    (3 rows)
	Task:
	Запрос данных из нескольких таблиц
	Decision:
	testbd=> SELECT * FROM products;
	     id |                             name                              | type_id | price
	    ----+---------------------------------------------------------------+---------+-------
	      1 | Основы искусственного интеллекта                              |       1 | 15000
	      2 | Технологии обработки больших данных                           |       1 | 50000
	      3 | Программирование глубоких нейронных сетей                     |       1 | 30000
	      4 | Нейронные сети для анализа текстов                            |       1 | 50000
	      5 | Нейронные сети для анализа изображений                        |       1 | 50000
	      6 | Инженерия искусственного интеллекта                           |       1 | 60000
	      7 | Как стать DataScientist'ом                                    |       2 |     0
	      8 | Планирование карьеры в DataScience                            |       2 |  2000
	      9 | Области применения нейросетей: в какой развивать экспертность |       2 |  4000
	     10 | Программирование глубоких нейронных сетей на Python           |       3 |  1000
	     11 | Математика для DataScience                                    |       3 |  2000
	     12 | Основы визуализации данных                                    |       3 |   500
	     13 | Анализ временных рядов                                        |         | 30000
	    (13 rows)
	testbd=> SELECT * FROM product_types;
	     id |  type_name   
	    ----+--------------
	      1 | Онлайн-курс
	      2 | Вебинар
	      3 | Книга
	      4 | Консультация
	    (4 rows)
	Task:
	Объединение данных из нескольких таблиц в SELECT
	Decision:
	testbd=> SELECT products.name, product_types.type_name
	testbd-> FROM products JOIN product_types
	testbd-> ON products.type_id = product_types.id;
	                                 name                              |  type_name  
	    ---------------------------------------------------------------+-------------
	     Основы искусственного интеллекта                              | Онлайн-курс
	     Технологии обработки больших данных                           | Онлайн-курс
	     Программирование глубоких нейронных сетей                     | Онлайн-курс
	     Нейронные сети для анализа текстов                            | Онлайн-курс
	     Нейронные сети для анализа изображений                        | Онлайн-курс
	     Инженерия искусственного интеллекта                           | Онлайн-курс
	     Как стать DataScientist'ом                                    | Вебинар
	     Планирование карьеры в DataScience                            | Вебинар
	     Области применения нейросетей: в какой развивать экспертность | Вебинар
	     Программирование глубоких нейронных сетей на Python           | Книга
	     Математика для DataScience                                    | Книга
	     Основы визуализации данных                                    | Книга
	    (12 rows)
	Task:
	Псевдонимы таблиц
	Decision:
	testbd=> SELECT p.name, t.type_name
	testbd-> FROM products AS p JOIN product_types AS t
	testbd-> ON p.type_id = t.id;
	                                 name                              |  type_name  
	    ---------------------------------------------------------------+-------------
	     Основы искусственного интеллекта                              | Онлайн-курс
	     Технологии обработки больших данных                           | Онлайн-курс
	     Программирование глубоких нейронных сетей                     | Онлайн-курс
	     Нейронные сети для анализа текстов                            | Онлайн-курс
	     Нейронные сети для анализа изображений                        | Онлайн-курс
	     Инженерия искусственного интеллекта                           | Онлайн-курс
	     Как стать DataScientist'ом                                    | Вебинар
	     Планирование карьеры в DataScience                            | Вебинар
	     Области применения нейросетей: в какой развивать экспертность | Вебинар
	     Программирование глубоких нейронных сетей на Python           | Книга
	     Математика для DataScience                                    | Книга
	     Основы визуализации данных                                    | Книга
	    (12 rows)
	Task:
	Псевдонимы таблиц и столбцов
	Decision:
	testbd=> SELECT p.name AS product_name,
	testbd-> t.type_name AS product_type,
	testbd-> p.price AS product_price
	testbd-> FROM products AS p JOIN product_types AS t
	testbd-> ON p.type_id = t.id;
	                             product_name                          | product_type | product_price
	    ---------------------------------------------------------------+--------------+---------------
	     Основы искусственного интеллекта                              | Онлайн-курс  |         15000
	     Технологии обработки больших данных                           | Онлайн-курс  |         50000
	     Программирование глубоких нейронных сетей                     | Онлайн-курс  |         30000
	     Нейронные сети для анализа текстов                            | Онлайн-курс  |         50000
	     Нейронные сети для анализа изображений                        | Онлайн-курс  |         50000
	     Инженерия искусственного интеллекта                           | Онлайн-курс  |         60000
	     Как стать DataScientist'ом                                    | Вебинар      |             0
	     Планирование карьеры в DataScience                            | Вебинар      |          2000
	     Области применения нейросетей: в какой развивать экспертность | Вебинар      |          4000
	     Программирование глубоких нейронных сетей на Python           | Книга        |          1000
	     Математика для DataScience                                    | Книга        |          2000
	     Основы визуализации данных                                    | Книга        |           500
	    (12 rows)
	Task:
	Фильтрация данных из нескольких таблиц
	Decision:
	testbd=> SELECT p.name AS product_name,
	testbd-> t.type_name AS product_type,
	testbd-> p.price AS product_price
	testbd-> FROM products AS p JOIN product_types AS t
	testbd-> ON p.type_id = t.id
	testbd-> WHERE t.type_name='Онлайн-курс';
	                   product_name                | product_type | product_price
	    -------------------------------------------+--------------+---------------
	     Основы искусственного интеллекта          | Онлайн-курс  |         15000
	     Технологии обработки больших данных       | Онлайн-курс  |         50000
	     Программирование глубоких нейронных сетей | Онлайн-курс  |         30000
	     Нейронные сети для анализа текстов        | Онлайн-курс  |         50000
	     Нейронные сети для анализа изображений    | Онлайн-курс  |         50000
	     Инженерия искусственного интеллекта       | Онлайн-курс  |         60000
	    (6 rows)
	testbd=> SELECT p.name AS product_name,
	testbd-> t.type_name AS product_type,
	testbd-> p.price AS product_price
	testbd-> FROM products AS p JOIN product_types AS t
	testbd-> ON p.type_id = t.id
	testbd-> WHERE t.type_name = 'Вебинар'
	testbd-> AND p.price = 0;
	            product_name        | product_type | product_price
	    ----------------------------+--------------+---------------
	     Как стать DataScientist'ом | Вебинар      |             0
	    (1 row)
	Task:
	Сортировка данных из нескольких таблиц
	Decision:
	testbd=> SELECT p.name AS product_name,
	testbd-> t.type_name AS product_type,
	testbd-> p.price AS product_price
	testbd-> FROM products AS p JOIN product_types AS t
	testbd-> ON p.type_id = t.id
	testbd-> WHERE t.type_name='Онлайн-курс'
	testbd-> ORDER BY p.price DESC;
	                   product_name                | product_type | product_price
	    -------------------------------------------+--------------+---------------
	     Инженерия искусственного интеллекта       | Онлайн-курс  |         60000
	     Технологии обработки больших данных       | Онлайн-курс  |         50000
	     Нейронные сети для анализа текстов        | Онлайн-курс  |         50000
	     Нейронные сети для анализа изображений    | Онлайн-курс  |         50000
	     Программирование глубоких нейронных сетей | Онлайн-курс  |         30000
	     Основы искусственного интеллекта          | Онлайн-курс  |         15000
	    (6 rows)
	Task:
	Типы JOIN
	Decision:
	testbd=> SELECT * FROM products;
	     id |                             name                              | type_id | price
	    ----+---------------------------------------------------------------+---------+-------
	      1 | Основы искусственного интеллекта                              |       1 | 15000
	      2 | Технологии обработки больших данных                           |       1 | 50000
	      3 | Программирование глубоких нейронных сетей                     |       1 | 30000
	      4 | Нейронные сети для анализа текстов                            |       1 | 50000
	      5 | Нейронные сети для анализа изображений                        |       1 | 50000
	      6 | Инженерия искусственного интеллекта                           |       1 | 60000
	      7 | Как стать DataScientist'ом                                    |       2 |     0
	      8 | Планирование карьеры в DataScience                            |       2 |  2000
	      9 | Области применения нейросетей: в какой развивать экспертность |       2 |  4000
	     10 | Программирование глубоких нейронных сетей на Python           |       3 |  1000
	     11 | Математика для DataScience                                    |       3 |  2000
	     12 | Основы визуализации данных                                    |       3 |   500
	     13 | Анализ временных рядов                                        |         | 30000
	    (13 rows)
	testbd=> SELECT * FROM product_types;
	     id |  type_name   
	    ----+--------------
	      1 | Онлайн-курс
	      2 | Вебинар
	      3 | Книга
	      4 | Консультация
	    (4 rows)
	Task:
	Объединение таблиц в запросе
	Decision:
	testbd=> SELECT products.name, product_types.type_name
	testbd-> FROM products JOIN product_types
	testbd-> ON products.type_id = product_types.id;
	                                 name                              |  type_name  
	    ---------------------------------------------------------------+-------------
	     Основы искусственного интеллекта                              | Онлайн-курс
	     Технологии обработки больших данных                           | Онлайн-курс
	     Программирование глубоких нейронных сетей                     | Онлайн-курс
	     Нейронные сети для анализа текстов                            | Онлайн-курс
	     Нейронные сети для анализа изображений                        | Онлайн-курс
	     Инженерия искусственного интеллекта                           | Онлайн-курс
	     Как стать DataScientist'ом                                    | Вебинар
	     Планирование карьеры в DataScience                            | Вебинар
	     Области применения нейросетей: в какой развивать экспертность | Вебинар
	     Программирование глубоких нейронных сетей на Python           | Книга
	     Математика для DataScience                                    | Книга
	     Основы визуализации данных                                    | Книга
	    (12 rows)
	Task:
	Внутреннее объединение
	Decision:
	testbd=> SELECT products.name, product_types.type_name
	testbd-> FROM products INNER JOIN product_types
	testbd-> ON products.type_id = product_types.id;
	                                 name                              |  type_name  
	    ---------------------------------------------------------------+-------------
	     Основы искусственного интеллекта                              | Онлайн-курс
	     Технологии обработки больших данных                           | Онлайн-курс
	     Программирование глубоких нейронных сетей                     | Онлайн-курс
	     Нейронные сети для анализа текстов                            | Онлайн-курс
	     Нейронные сети для анализа изображений                        | Онлайн-курс
	     Инженерия искусственного интеллекта                           | Онлайн-курс
	     Как стать DataScientist'ом                                    | Вебинар
	     Планирование карьеры в DataScience                            | Вебинар
	     Области применения нейросетей: в какой развивать экспертность | Вебинар
	     Программирование глубоких нейронных сетей на Python           | Книга
	     Математика для DataScience                                    | Книга
	     Основы визуализации данных                                    | Книга
	    (12 rows)
	Task:
	Левое внешнее объединение
	Decision:
	testbd=> SELECT products.name, product_types.type_name
	testbd-> FROM products LEFT OUTER JOIN product_types
	testbd-> ON products.type_id = product_types.id;
	                                 name                              |  type_name  
	    ---------------------------------------------------------------+-------------
	     Основы искусственного интеллекта                              | Онлайн-курс
	     Технологии обработки больших данных                           | Онлайн-курс
	     Программирование глубоких нейронных сетей                     | Онлайн-курс
	     Нейронные сети для анализа текстов                            | Онлайн-курс
	     Нейронные сети для анализа изображений                        | Онлайн-курс
	     Инженерия искусственного интеллекта                           | Онлайн-курс
	     Как стать DataScientist'ом                                    | Вебинар
	     Планирование карьеры в DataScience                            | Вебинар
	     Области применения нейросетей: в какой развивать экспертность | Вебинар
	     Программирование глубоких нейронных сетей на Python           | Книга
	     Математика для DataScience                                    | Книга
	     Основы визуализации данных                                    | Книга
	     Анализ временных рядов                                        |
	    (13 rows)
	Task:
	Правое внешнее объединение
	Decision:
	testbd=> SELECT products.name, product_types.type_name
	testbd-> FROM products RIGHT OUTER JOIN product_types
	testbd-> ON products.type_id = product_types.id;
	                                 name                              |  type_name   
	    ---------------------------------------------------------------+--------------
	     Основы искусственного интеллекта                              | Онлайн-курс
	     Технологии обработки больших данных                           | Онлайн-курс
	     Программирование глубоких нейронных сетей                     | Онлайн-курс
	     Нейронные сети для анализа текстов                            | Онлайн-курс
	     Нейронные сети для анализа изображений                        | Онлайн-курс
	     Инженерия искусственного интеллекта                           | Онлайн-курс
	     Как стать DataScientist'ом                                    | Вебинар
	     Планирование карьеры в DataScience                            | Вебинар
	     Области применения нейросетей: в какой развивать экспертность | Вебинар
	     Программирование глубоких нейронных сетей на Python           | Книга
	     Математика для DataScience                                    | Книга
	     Основы визуализации данных                                    | Книга
	                                                                   | Консультация
	    (13 rows)
	Task:
	Полное внешнее объединение
	Decision:
	testbd=> SELECT products.name, product_types.type_name
	testbd-> FROM products FULL OUTER JOIN product_types
	testbd-> ON products.type_id = product_types.id;
	                                 name                              |  type_name   
	    ---------------------------------------------------------------+--------------
	     Основы искусственного интеллекта                              | Онлайн-курс
	     Технологии обработки больших данных                           | Онлайн-курс
	     Программирование глубоких нейронных сетей                     | Онлайн-курс
	     Нейронные сети для анализа текстов                            | Онлайн-курс
	     Нейронные сети для анализа изображений                        | Онлайн-курс
	     Инженерия искусственного интеллекта                           | Онлайн-курс
	     Как стать DataScientist'ом                                    | Вебинар
	     Планирование карьеры в DataScience                            | Вебинар
	     Области применения нейросетей: в какой развивать экспертность | Вебинар
	     Программирование глубоких нейронных сетей на Python           | Книга
	     Математика для DataScience                                    | Книга
	     Основы визуализации данных                                    | Книга
	     Анализ временных рядов                                        |
	                                                                   | Консультация
	    (14 rows)
	Task:
	Перекрестное объединение
	Decision:
	testbd=> SELECT products.name, product_types.type_name
	testbd-> FROM products CROSS JOIN product_types;
	                                 name                              |  type_name   
	    ---------------------------------------------------------------+--------------
	     Основы искусственного интеллекта                              | Онлайн-курс
	     Технологии обработки больших данных                           | Онлайн-курс
	     Программирование глубоких нейронных сетей                     | Онлайн-курс
	     Нейронные сети для анализа текстов                            | Онлайн-курс
	     Нейронные сети для анализа изображений                        | Онлайн-курс
	     Инженерия искусственного интеллекта                           | Онлайн-курс
	     Как стать DataScientist'ом                                    | Онлайн-курс
	     Планирование карьеры в DataScience                            | Онлайн-курс
	     Области применения нейросетей: в какой развивать экспертность | Онлайн-курс
	     Программирование глубоких нейронных сетей на Python           | Онлайн-курс
	     Математика для DataScience                                    | Онлайн-курс
	     Основы визуализации данных                                    | Онлайн-курс
	     Анализ временных рядов                                        | Онлайн-курс
	     Основы искусственного интеллекта                              | Вебинар
	     Технологии обработки больших данных                           | Вебинар
	     Программирование глубоких нейронных сетей                     | Вебинар
	     Нейронные сети для анализа текстов                            | Вебинар
	     Нейронные сети для анализа изображений                        | Вебинар
	     Инженерия искусственного интеллекта                           | Вебинар
	     Как стать DataScientist'ом                                    | Вебинар
	     Планирование карьеры в DataScience                            | Вебинар
	     Области применения нейросетей: в какой развивать экспертность | Вебинар
	     Программирование глубоких нейронных сетей на Python           | Вебинар
	     Математика для DataScience                                    | Вебинар
	     Основы визуализации данных                                    | Вебинар
	     Анализ временных рядов                                        | Вебинар
	     Основы искусственного интеллекта                              | Книга
	     Технологии обработки больших данных                           | Книга
	     Программирование глубоких нейронных сетей                     | Книга
	     Нейронные сети для анализа текстов                            | Книга
	     Нейронные сети для анализа изображений                        | Книга
	     Инженерия искусственного интеллекта                           | Книга
	Task:
	Объединить две таблицы
	Decision:
	Table: Person
	+-------------+---------+
	| Column Name | Type    |
	+-------------+---------+
	| personId    | int     |
	| lastName    | varchar |
	| firstName   | varchar |
	+-------------+---------+
	Table: Address
	+-------------+---------+
	| Column Name | Type    |
	+-------------+---------+
	| addressId   | int     |
	| personId    | int     |
	| city        | varchar |
	| state       | varchar |
	+-------------+---------+
	Напишите SQL-запрос, чтобы сообщить имя, фамилию, город и состояние каждого человека в таблице Person. Если адрес идентификатора человека отсутствует в таблице адресов, вместо этого сообщите null.
	Верните таблицу результатов в любом порядке.
	Input:
	Person table:
	+----------+----------+-----------+
	| personId | lastName | firstName |
	+----------+----------+-----------+
	| 1        | Wang     | Allen     |
	| 2        | Alice    | Bob       |
	+----------+----------+-----------+
	Address table:
	+-----------+----------+---------------+------------+
	| addressId | personId | city          | state      |
	+-----------+----------+---------------+------------+
	| 1         | 2        | New York City | New York   |
	| 2         | 3        | Leetcode      | California |
	+-----------+----------+---------------+------------+
	Output:
	+-----------+----------+---------------+----------+
	| firstName | lastName | city          | state    |
	+-----------+----------+---------------+----------+
	| Allen     | Wang     | Null          | Null     |
	| Bob       | Alice    | New York City | New York |
	+-----------+----------+---------------+----------+
	Decision:
	SELECT p.FirstName, p.LastName, a.City, a.State
	FROM Person AS p LEFT OUTER JOIN Address AS a
	ON p.PersonId = a.PersonId;
	    personId    lastName    firstName
	0   1           Wang        Allen
	1   2           Alice       Bob
	    addressId   personId    city            state
	0   1           2           New York City   New York
	1   2           3           Leetcode        California
	Task:
	JOIN нескольких таблиц
	Task:
	В какие города летал Bruce Willis
	Decision:
	SELECT id FROM Passenger WHERE name = 'Bruce Willis';
	SELECT trip FROM Pass_in_trip WHERE passenger = 1 OR passenger = 31;
	SELECT town_to FROM Trip WHERE id IN (1100, 1123, 1181);
	SELECT town_to
	FROM Trip JOIN Pass_in_trip
	ON Trip.id=Pass_in_trip.trip
	JOIN Passenger
	ON Pass_in_trip.passenger=Passenger.id
	WHERE Passenger.name='Bruce Willis';
	SELECT town_to
	FROM Trip JOIN Pass_in_trip
	ON Trip.id=Pass_in_trip.trip
	JOIN Passenger
	ON Pass_in_trip.passenger=Passenger.id
	JOIN Company
	ON Trip.company=Company.id
	WHERE Passenger.name='Bruce Willis';
	Task:
	Схема базы данных
	Decision:
	testbd=> SELECT * FROM products;
	     id |                             name                              | type_id | price
	    ----+---------------------------------------------------------------+---------+-------
	      1 | Основы искусственного интеллекта                              |       1 | 15000
	      2 | Технологии обработки больших данных                           |       1 | 50000
	      3 | Программирование глубоких нейронных сетей                     |       1 | 30000
	      4 | Нейронные сети для анализа текстов                            |       1 | 50000
	      5 | Нейронные сети для анализа изображений                        |       1 | 50000
	      6 | Инженерия искусственного интеллекта                           |       1 | 60000
	      7 | Как стать DataScientist'ом                                    |       2 |     0
	      8 | Планирование карьеры в DataScience                            |       2 |  2000
	      9 | Области применения нейросетей: в какой развивать экспертность |       2 |  4000
	     10 | Программирование глубоких нейронных сетей на Python           |       3 |  1000
	     11 | Математика для DataScience                                    |       3 |  2000
	     12 | Основы визуализации данных                                    |       3 |   500
	     13 | Анализ временных рядов                                        |         | 30000
	    (13 rows)
	testbd=> SELECT * FROM product_types;
	     id |  type_name   
	    ----+--------------
	      1 | Онлайн-курс
	      2 | Вебинар
	      3 | Книга
	      4 | Консультация
	    (4 rows)
	testbd=> SELECT * FROM customers;
	     id |      name       |         email          
	    ----+-----------------+------------------------
	      1 | Иван Петров     | petrov@mail.ru
	      2 | Петр Иванов     | ivanov@gmail.com
	      3 | Тимофей Сергеев | ts@gmail.com
	      4 | Даша Корнеева   | dasha.korneeva@mail.ru
	      5 | Иван Иван       | petrov@mail.ru
	      6 | Сергей Щербаков | user156@yandex.ru
	      7 | Катя Самарина   | kate@mail.ru
	      8 | Андрей Котов    | a.kotoff@yandex.ru
	    (8 rows)
	testbd=> SELECT * FROM orders;
	     id | order_date | customer_id
	    ----+------------+-------------
	      1 | 2021-01-11 |           1
	      2 | 2021-01-15 |           3
	      3 | 2021-01-20 |           4
	      4 | 2021-01-12 |           2
	      5 | 2021-01-25 |           8
	      6 | 2021-01-30 |           1
	    (6 rows)
	testbd=> SELECT * FROM sales;
	     product_id | order_id | quantity
	    ------------+----------+----------
	              3 |        1 |        1
	              4 |        6 |        1
	             10 |        2 |        2
	             11 |        2 |        2
	              3 |        3 |        1
	              4 |        3 |        1
	              5 |        3 |        1
	              1 |        4 |        1
	              6 |        5 |        1
	    (9 rows)
	Task:
	Продукты в заказе
	Decision:
	testbd=> SELECT p.id,
	testbd-> p.name,
	testbd-> p.price,
	testbd-> s.quantity,
	testbd-> p.price * s.quantity AS total
	testbd-> FROM products AS p JOIN sales AS s
	testbd-> ON p.id = s.product_id
	testbd-> WHERE s.order_id=2;
	     id |                        name                         | price | quantity | total
	    ----+-----------------------------------------------------+-------+----------+-------
	     10 | Программирование глубоких нейронных сетей на Python |  1000 |        2 |  2000
	     11 | Математика для DataScience                          |  2000 |        2 |  4000
	    (2 rows)
	Task:
	Все покупки заказчика
	Decision:
	testbd=> SELECT p.id,
	testbd-> p.name,
	testbd-> p.price,
	testbd-> s.quantity,
	testbd-> p.price * s.quantity AS total
	testbd-> FROM products AS p JOIN sales AS s
	testbd-> ON p.id = s.product_id
	testbd-> JOIN orders AS o
	testbd-> ON o.id = s.order_id
	testbd-> WHERE o.customer_id=1;
	     id |                   name                    | price | quantity | total
	    ----+-------------------------------------------+-------+----------+-------
	      3 | Программирование глубоких нейронных сетей | 30000 |        1 | 30000
	      4 | Нейронные сети для анализа текстов        | 50000 |        1 | 50000
	    (2 rows)
	Task:
	Подзапросы
	Decision:
	postgres=# SELECT * FROM products;
	     id |                             name                              | type_id | price
	    ----+---------------------------------------------------------------+---------+-------
	      1 | Основы искусственного интеллекта                              |       1 | 15000
	      2 | Технологии обработки больших данных                           |       1 | 50000
	      3 | Программирование глубоких нейронных сетей                     |       1 | 30000
	      4 | Нейронные сети для анализа текстов                            |       1 | 50000
	      5 | Нейронные сети для анализа изображений                        |       1 | 50000
	      6 | Инженерия искусственного интеллекта                           |       1 | 60000
	      7 | Как стать DataScientist'ом                                    |       2 |     0
	      8 | Планирование карьеры в DataScience                            |       2 |  2000
	      9 | Области применения нейросетей: в какой развивать экспертность |       2 |  4000
	     10 | Программирование глубоких нейронных сетей на Python           |       3 |  1000
	     11 | Математика для DataScience                                    |       3 |  2000
	     12 | Основы визуализации данных                                    |       3 |   500
	     13 | Анализ временных рядов                                        |         | 30000
	    (13 строк)
	postgres=# SELECT id, name, price
	postgres-# FROM products
	postgres-# WHERE price = (SELECT MAX(price)
	postgres(# FROM products);
	     id |                name                 | price
	    ----+-------------------------------------+-------
	      6 | Инженерия искусственного интеллекта | 60000
	    (1 строка)
	postgres=# SELECT MAX(price) FROM products;
	      max
	    -------
	     60000
	    (1 строка)
	postgres=# SELECT id, name, price
	postgres-# FROM products
	postgres-# WHERE price = 60000;
	     id |                name                 | price
	    ----+-------------------------------------+-------
	      6 | Инженерия искусственного интеллекта | 60000
	    (1 строка)
	Task:
	Вывести информацию о самом дорогом продукте
	Decision:
	postgres=# SELECT id, name, price
	postgres-# FROM products
	postgres-# WHERE price = (SELECT MAX(price)
	postgres(# FROM products);
	     id |                name                 | price
	    ----+-------------------------------------+-------
	      6 | Инженерия искусственного интеллекта | 60000
	    (1 строка)
	Task:
	Вывести информацию о продуктах, которые были проданы хотя бы 1 раз
	Decision:
	postgres=# SELECT id, name, price
	postgres-# FROM products
	postgres-# WHERE id IN (SELECT product_id
	postgres(# FROM sales);
	     id |                        name                         | price
	    ----+-----------------------------------------------------+-------
	      1 | Основы искусственного интеллекта                    | 15000
	      3 | Программирование глубоких нейронных сетей           | 30000
	      4 | Нейронные сети для анализа текстов                  | 50000
	      5 | Нейронные сети для анализа изображений              | 50000
	      6 | Инженерия искусственного интеллекта                 | 60000
	     10 | Программирование глубоких нейронных сетей на Python |  1000
	     11 | Математика для DataScience                          |  2000
	    (7 строк)
	postgres=# SELECT * FROM sales;
	     product_id | order_id | quantity
	    ------------+----------+----------
	              3 |        1 |        1
	              4 |        6 |        1
	             10 |        2 |        2
	             11 |        2 |        2
	              3 |        3 |        1
	              4 |        3 |        1
	              5 |        3 |        1
	              1 |        4 |        1
	              6 |        5 |        1
	    (9 строк)
	postgres=# SELECT product_id FROM sales;
	     product_id
	    ------------
	              3
	              4
	             10
	             11
	              3
	              4
	              5
	              1
	              6
	    (9 строк)
	postgres=# SELECT id, name, price
	postgres-# FROM products
	postgres-# WHERE id IN (3, 4, 10, 11, 3, 4, 5, 1, 6);
	     id |                        name                         | price
	    ----+-----------------------------------------------------+-------
	      1 | Основы искусственного интеллекта                    | 15000
	      3 | Программирование глубоких нейронных сетей           | 30000
	      4 | Нейронные сети для анализа текстов                  | 50000
	      5 | Нейронные сети для анализа изображений              | 50000
	      6 | Инженерия искусственного интеллекта                 | 60000
	     10 | Программирование глубоких нейронных сетей на Python |  1000
	     11 | Математика для DataScience                          |  2000
	    (7 строк)
	Task:
	Индексы
	Decision:
	postgres=# SELECT * FROM superheroes;
	      id  |                                 name                                  |       align        |        eye         |         hair          |         gender         | appearances | year | universe
	    ------+-----------------------------------------------------------------------+--------------------+--------------------+-----------------------+------------------------+-------------+------+----------
	        1 | Spider-Man (Peter Parker)                                             | Good Characters    | Hazel Eyes         | Brown Hair            | Male Characters        |        4043 | 1962 | marvel
	        2 | Captain America (Steven Rogers)                                       | Good Characters    | Blue Eyes          | White Hair            | Male Characters        |        3360 | 1941 | marvel
	        3 | Wolverine (James \"Logan\" Howlett)                                   | Neutral Characters | Blue Eyes          | Black Hair            | Male Characters        |        3061 | 1974 | marvel
	        4 | Iron Man (Anthony \"Tony\" Stark)                                     | Good Characters    | Blue Eyes          | Black Hair            | Male Characters        |        2961 | 1963 | marvel
	        5 | Thor (Thor Odinson)                                                   | Good Characters    | Blue Eyes          | Blond Hair            | Male Characters        |        2258 | 1950 | marvel
	        6 | Benjamin Grimm (Earth-616)                                            | Good Characters    | Blue Eyes          | No Hair               | Male Characters        |        2255 | 1961 | marvel
	        7 | Reed Richards (Earth-616)                                             | Good Characters    | Brown Eyes         | Brown Hair            | Male Characters        |        2072 | 1961 | marvel
	        8 | Hulk (Robert Bruce Banner)                                            | Good Characters    | Brown Eyes         | Brown Hair            | Male Characters        |        2017 | 1962 | marvel
	        9 | Scott Summers (Earth-616)                                             | Neutral Characters | Brown Eyes         | Brown Hair            | Male Characters        |        1955 | 1963 | marvel
	       10 | Jonathan Storm (Earth-616)                                            | Good Characters    | Blue Eyes          | Blond Hair            | Male Characters        |        1934 | 1961 | marvel
	       11 | Henry McCoy (Earth-616)                                               | Good Characters    | Blue Eyes          | Blue Hair             | Male Characters        |        1825 | 1963 | marvel
	       12 | Susan Storm (Earth-616)                                               | Good Characters    | Blue Eyes          | Blond Hair            | Female Characters      |        1713 | 1961 | marvel
	       13 | Ororo Munroe (Earth-616)                                              | Good Characters    | Blue Eyes          | White Hair            | Female Characters      |        1512 | 1975 | marvel
	       14 | Clinton Barton (Earth-616)                                            | Good Characters    | Blue Eyes          | Blond Hair            | Male Characters        |        1394 | 1964 | marvel
	       15 | Matthew Murdock (Earth-616)                                           | Good Characters    | Blue Eyes          | Red Hair              | Male Characters        |        1338 | 1964 | marvel
	       16 | Stephen Strange (Earth-616)                                           | Good Characters    | Grey Eyes          | Black Hair            | Male Characters        |        1307 | 1963 | marvel
	       17 | Mary Jane Watson (Earth-616)                                          | Good Characters    | Green Eyes         | Red Hair              | Female Characters      |        1304 | 1965 | marvel
	       18 | John Jonah Jameson (Earth-616)                                        | Neutral Characters | Blue Eyes          | Black Hair            | Male Characters        |        1266 | 1963 | marvel
	       19 | Robert Drake (Earth-616)                                              | Good Characters    | Brown Eyes         | Brown Hair            | Male Characters        |        1265 | 1963 | marvel
	       20 | Henry Pym (Earth-616)                                                 | Good Characters    | Blue Eyes          | Blond Hair            | Male Characters       
	Task:
	Запрос на поиск данных
	Decision:
	postgres=# SELECT * FROM superheroes;
	postgres=# SELECT name, appearances, eye, hair
	postgres-# FROM superheroes
	postgres-# WHERE name = 'Iron Man (Anthony \"Tony\" Stark)';
	                   name                | appearances |    eye    |    hair
	    -----------------------------------+-------------+-----------+------------
	     Iron Man (Anthony \"Tony\" Stark) |        2961 | Blue Eyes | Black Hair
	    (1 строка)
	Task:
	Создание индекса
	Decision:
	postgres=# CREATE INDEX superheroes_name_idx
	postgres-# ON superheroes(name);
	    CREATE INDEX
	Task:
	Использование индекса при запросе
	Decision:
	postgres=# SELECT name, appearances, eye, hair
	postgres-# FROM superheroes
	postgres-# WHERE name = 'Iron Man (Anthony \"Tony\" Stark)';
	                   name                | appearances |    eye    |    hair
	    -----------------------------------+-------------+-----------+------------
	     Iron Man (Anthony \"Tony\" Stark) |        2961 | Blue Eyes | Black Hair
	    (1 строка)
	Task:
	Порядок сортировки данных в индексе
	Decision:
	postgres=# CREATE INDEX superheroes_appearances_idx
	postgres-# ON superheroes(appearances DESC);
	    CREATE INDEX
	Task:
	Ограничения
	Decision:
	postgres=# CREATE TABLE superheroes1(
	id INT PRIMARY KEY,
	name VARCHAR(100),
	align VARCHAR(30),
	eye VARCHAR(30),
	hair VARCHAR(30),
	gender VARCHAR(30),
	appearances INT,
	year INT,
	universe VARCHAR(10)
	);
	    CREATE TABLE
	postgres=# SELECT * FROM superheroes1;
	     id | name | align | eye | hair | gender | appearances | year | universe
	    ----+------+-------+-----+------+--------+-------------+------+----------
	    (0 строк)
	Task:
	Непустые значения
	Decision:
	postgres=# CREATE TABLE superheroes2(
	id INT PRIMARY KEY,
	name VARCHAR(100) NOT NULL,
	align VARCHAR(30),
	eye VARCHAR(30),
	hair VARCHAR(30),
	gender VARCHAR(30),
	appearances INT,
	year INT,
	universe VARCHAR(10)
	);
	    CREATE TABLE    
	postgres=# SELECT * FROM superheroes2;
	     id | name | align | eye | hair | gender | appearances | year | universe
	    ----+------+-------+-----+------+--------+-------------+------+----------
	    (0 строк)
	Task:
	Уникальные значения
	Decision:
	postgres=# CREATE TABLE superheroes3(
	postgres(# id INT PRIMARY KEY,
	postgres(# name VARCHAR(100) UNIQUE,
	postgres(# align VARCHAR(30),
	postgres(# eye VARCHAR(30),
	postgres(# hair VARCHAR(30),
	postgres(# gender VARCHAR(30),
	postgres(# appearances INT,
	postgres(# year INT,
	postgres(# universe VARCHAR(10)
	postgres(# );
	CREATE TABLE
	postgres=# SELECT * FROM superheroes3;
	     id | name | align | eye | hair | gender | appearances | year | universe
	    ----+------+-------+-----+------+--------+-------------+------+----------
	    (0 строк)
	Task:
	Уникальные непустые значения
	Decision:
	postgres=# CREATE TABLE superheroes4(
	postgres(# id INT PRIMARY KEY,
	postgres(# name VARCHAR(100) UNIQUE NOT NULL,
	postgres(# align VARCHAR(30),
	postgres(# eye VARCHAR(30),
	postgres(# hair VARCHAR(30),
	postgres(# gender VARCHAR(30),
	postgres(# appearances INT,
	postgres(# year INT,
	postgres(# universe VARCHAR(10)
	postgres(# );
	    CREATE TABLE
	postgres=# SELECT * FROM superheroes4;
	     id | name | align | eye | hair | gender | appearances | year | universe
	    ----+------+-------+-----+------+--------+-------------+------+----------
	    (0 строк)
	Task:
	Первичный ключ из нескольких полей
	Decision:
	postgres=# CREATE TABLE sales1(
	postgres(# product_id INT,
	postgres(# order_id INT,
	postgres(# quantity INT,
	postgres(# PRIMARY KEY(product_id, order_id)
	postgres(# );
	    CREATE TABLE
	postgres=# SELECT * FROM sales1;
	     product_id | order_id | quantity
	    ------------+----------+----------
	    (0 строк)
	Task:
	Первичный и внешний ключи
	Decision:
	postgres=# CREATE TABLE sales2(
	product_id INT REFERENCES products(id),
	order_id INT REFERENCES orders(id),
	quantity INT,
	PRIMARY KEY(product_id, order_id)
	);
	    CREATE TABLE
	postgres=# SELECT * FROM sales2;
	     product_id | order_id | quantity
	    ------------+----------+----------
	    (0 строк)
	Task:
	Представления с данными из нескольких таблиц
	Decision:
	postgres=# SELECT * FROM products;
	     id |                             name                              | type_id | price
	    ----+---------------------------------------------------------------+---------+-------
	      1 | Основы искусственного интеллекта                              |       1 | 15000
	      2 | Технологии обработки больших данных                           |       1 | 50000
	      3 | Программирование глубоких нейронных сетей                     |       1 | 30000
	      4 | Нейронные сети для анализа текстов                            |       1 | 50000
	      5 | Нейронные сети для анализа изображений                        |       1 | 50000
	      6 | Инженерия искусственного интеллекта                           |       1 | 60000
	      7 | Как стать DataScientist'ом                                    |       2 |     0
	      8 | Планирование карьеры в DataScience                            |       2 |  2000
	      9 | Области применения нейросетей: в какой развивать экспертность |       2 |  4000
	     13 | Анализ временных рядов                                        |         | 30000
	     10 | Программирование глубоких нейронных сетей на Python           |       3 |  1500
	     11 | Математика для DataScience                                    |       3 |  2500
	     12 | Основы визуализации данных                                    |       3 |  1000
	    (13 строк)
	postgres=# CREATE VIEW products_v
	postgres-# AS SELECT p.id AS id,
	postgres-# p.name AS product_name,
	postgres-# t.type_name AS product_type,
	postgres-# p.price AS product_price
	postgres-# FROM products AS p JOIN product_types AS t
	postgres-# ON p.type_id = t.id;
	    CREATE VIEW
	postgres=# SELECT * FROM products_v;
	     id |                         product_name                          | product_type | product_price
	    ----+---------------------------------------------------------------+--------------+---------------
	      1 | Основы искусственного интеллекта                              | Онлайн-курс  |         15000
	      2 | Технологии обработки больших данных                           | Онлайн-курс  |         50000
	      3 | Программирование глубоких нейронных сетей                     | Онлайн-курс  |         30000
	      4 | Нейронные сети для анализа текстов                            | Онлайн-курс  |         50000
	      5 | Нейронные сети для анализа изображений                        | Онлайн-курс  |         50000
	      6 | Инженерия искусственного интеллекта                           | Онлайн-курс  |         60000
	      7 | Как стать DataScientist'ом                                    | Вебинар      |             0
	      8 | Планирование карьеры в DataScience                            | Вебинар      |          2000
	      9 | Области применения нейросетей: в какой развивать экспертность | Вебинар      |          4000
	     10 | Программирование глубоких нейронных сетей на Python           | Книга        |          1500
	     11 | Математика для DataScience                                    | Книга        |          2500
	     12 | Основы визуализации данных                                    | Книга        |          1000
	    (12 строк)
	Task:
	Материализованные представления
	Decision:
	postgres=# CREATE MATERIALIZED VIEW products_v1
	AS SELECT p.id AS id,
	p.name AS product_name,
	t.type_name AS product_type,
	p.price AS product_price
	FROM products AS p JOIN product_types AS t
	ON p.type_id = t.id;
	    SELECT 12
	postgres=# SELECT * FROM products_v1;
	     id |                         product_name                          | product_type | product_price
	    ----+---------------------------------------------------------------+--------------+---------------
	      1 | Основы искусственного интеллекта                              | Онлайн-курс  |         15000
	      2 | Технологии обработки больших данных                           | Онлайн-курс  |         50000
	      3 | Программирование глубоких нейронных сетей                     | Онлайн-курс  |         30000
	      4 | Нейронные сети для анализа текстов                            | Онлайн-курс  |         50000
	      5 | Нейронные сети для анализа изображений                        | Онлайн-курс  |         50000
	      6 | Инженерия искусственного интеллекта                           | Онлайн-курс  |         60000
	      7 | Как стать DataScientist'ом                                    | Вебинар      |             0
	      8 | Планирование карьеры в DataScience                            | Вебинар      |          2000
	      9 | Области применения нейросетей: в какой развивать экспертность | Вебинар      |          4000
	     10 | Программирование глубоких нейронных сетей на Python           | Книга        |          1500
	     11 | Математика для DataScience                                    | Книга        |          2500
	     12 | Основы визуализации данных                                    | Книга        |          1000
	    (12 строк)
	Task:
	Обновление материализованных представлений
	Decision:
	postgres=# REFRESH MATERIALIZED VIEW products_v1;
	    REFRESH MATERIALIZED VIEW
	postgres=# SELECT * FROM products_v1;
	     id |                         product_name                          | product_type | product_price
	    ----+---------------------------------------------------------------+--------------+---------------
	      1 | Основы искусственного интеллекта                              | Онлайн-курс  |         15000
	      2 | Технологии обработки больших данных                           | Онлайн-курс  |         50000
	      3 | Программирование глубоких нейронных сетей                     | Онлайн-курс  |         30000
	      4 | Нейронные сети для анализа текстов                            | Онлайн-курс  |         50000
	      5 | Нейронные сети для анализа изображений                        | Онлайн-курс  |         50000
	      6 | Инженерия искусственного интеллекта                           | Онлайн-курс  |         60000
	      7 | Как стать DataScientist'ом                                    | Вебинар      |             0
	      8 | Планирование карьеры в DataScience                            | Вебинар      |          2000
	      9 | Области применения нейросетей: в какой развивать экспертность | Вебинар      |          4000
	     10 | Программирование глубоких нейронных сетей на Python           | Книга        |          1500
	     11 | Математика для DataScience                                    | Книга        |          2500
	     12 | Основы визуализации данных                                    | Книга        |          1000
	    (12 строк)
	Task:
	Удаление представлений
	Decision:
	postgres=# DROP VIEW products_v;
	    DROP VIEW
	postgres=# SELECT * FROM products_v;
	    ОШИБКА:  отношение "products_v" не существует
	    СТРОКА 1: SELECT * FROM products_v;
	                        ^
	Task:
	Удаление материализованных представлений
	Decision:
	postgres=# DROP MATERIALIZED VIEW products_v1;
	    DROP MATERIALIZED VIEW
	postgres=# SELECT * FROM products_v1;
	    ОШИБКА:  отношение "products_v1" не существует
	    СТРОКА 1: SELECT * FROM products_v1;
	Decision:
	https://github.com/David138it/MyPortfolio/tree/main/TaskDecision/Engineer-Isu/Sql/
	Source:
	1. https://www.asozykin.ru/?ysclid=lk9eaatbqj18673257

Sql, Isu University Structure
	Task:
	Перечень работ
	1. Разработка проекта БД и реализация его в реляционной СУБД
	2. Создание и модификация БД, занесение  и редактирование данных
	3. Работа с данными
	4. Разработка прикладных программ
	5. Создание меню для пользователя
	Состав проекта БД по предметной области
	1. Графическая диаграмма объектов – связей
	2. Спецификации атрибутов (тип, размер, область допустимых значений (ОДЗ))
	3. Среди типов связей обязательно присутствие типа 1:М
	4. Среди значений ОДЗ должны присутствовать ограничения на числовые атрибуты и значения двух числовых атрибутов
	5. Структура таблиц по БД
	Перечень индивидуальных заданий на развитие программы
	1. Модифицировать программу для поиска по номеру записи.
	2. Модифицировать программу для поиска по числовым полям
	3. Модифицировать программу для поиска по полям типа «дата»
	4. Модифицировать программу для поиска с помощью индексных файлов по символьным полям
	5. Модифицировать программу для поиска с помощью индексных файлов по числовым полям
	6. Модифицировать программу для поиска с помощью индексных файлов по полям типа «дата»
	7. Модифицировать программу для одновременного выбора группы записей, удовлетворяющих критерию на числовые поля
	8. Модифицировать программу для одновременного выбора группы записей, удовлетворяющих критерию на символьные поля
	9. Модифицировать программу для одновременного выбора группы записей, удовлетворяющих критерию на поля тип «дата»
	Перечень индивидуальных заданий по модификации меню
	1. При выборе файла данных предоставить возможность сделать резервную копию
	2. Реализовать разветвленный просмотр файла: всего и группы записей
	3. Удаление данных: группы записей и отдельные записи
	4. Удаление данных: отдельной записи и первой записи
	5. Удаление данных: группы записей, последней записи
	6, 7, 8 Разветвленное редактирование
	9. Удаление данных: пометка к удалению и фактическое удаление
	10. 13. Факультет: кадры
	Фамилии, дом. адреса, телефоны преподавателей и студентов, номера учебных групп студентов с указанием количества студентов в группах, из них – обучаемых с ДОУ; для преподавателей – наименование кафедры и должность. По кафедрам сведения о количестве преподавателей, их должностях, ученых званиях, фамилия и.о. заведующего кафедрой. Для работников деканата выделить  должность и номер рабочего телефона
	В примечаниях: номер аудитории деканата, часы приема заведующего кафедрой, декана и заместителя декана
	Добавляются: по вспомогательному персоналу – фамилии, должности, кафедры.
	Убира.тся: номера телефонов заменяются на 11-значные
	13. Факультет: кадры
	Фамилии, дом. адреса, телефоны преподавателей и студентов, номера учебных групп студентов с указанием количества студентов в группах, из них – обучаемых с ДОУ; для преподавателей – наименование кафедры и должность. По кафедрам сведения о количестве преподавателей, их должностях, ученых званиях, фамилия и.о. заведующего кафедрой. Для работников деканата выделить  должность и номер рабочего телефона
	В примечаниях: номер аудитории деканата, часы приема заведующего кафедрой, декана и заместителя декана
	Добавляются: по вспомогательному персоналу – фамилии, должности, кафедры.
	Убира.тся: номера телефонов заменяются на 11-значные
	13. Факультет: кадры
	Фамилии, дом. адреса, телефоны преподавателей и студентов, номера учебных групп студентов с указанием количества студентов в группах, из них – обучаемых с ДОУ; для преподавателей – наименование кафедры и должность. По кафедрам сведения о количестве преподавателей, их должностях, ученых званиях, фамилия и.о. заведующего кафедрой. Для работников деканата выделить  должность и номер рабочего телефона
	В примечаниях: номер аудитории деканата, часы приема заведующего кафедрой, декана и заместителя декана
	Добавляются: по вспомогательному персоналу – фамилии, должности, кафедры.
	Убираются: номера телефонов заменяются на 11-значные
	14. Аудиторные занятия. Учебный процесс
	Фамилии, дом. адреса, телефоны студентов, номера учебных групп с количеством студентов в них, в том числе обучающихся на условиях ПВЗ, наименования дисциплин с количеством часов, из них лекционных, практических, лабораторных. Для преподавателей также кафедра и должность, ч указанием дисциплин, которые он ведет. Для групп указать, какие  дисциплины ведутся, в каком семестре, номер аудитории
	В примечаниях: список литературы по дисциплинам
	Добавляются: перечень лабораторных работ по дисциплинам с лабораторным практикумами, номер учебной лаборатории
	Убираются: номер аудитории.
	14. Аудиторные занятия. Учебный процесс
	Фамилии, дом. адреса, телефоны студентов, номера учебных групп с количеством студентов в них, в том числе обучающихся на условиях ПВЗ, наименования дисциплин с количеством часов, из них лекционных, практических, лабораторных. Для преподавателей также кафедра и должность, ч указанием дисциплин, которые он ведет. Для групп указать, какие  дисциплины ведутся, в каком семестре, номер аудитории
	В примечаниях: список литературы по дисциплинам
	Добавляются: перечень лабораторных работ по дисциплинам с лабораторным практикумами, номер учебной лаборатории
	Убираются: номер аудитории.
	14. Аудиторные занятия. Учебный процесс
	Фамилии, дом. адреса, телефоны студентов, номера учебных групп с количеством студентов в них, в том числе обучающихся на условиях ПВЗ, наименования дисциплин с количеством часов, из них лекционных, практических, лабораторных. Для преподавателей также кафедра и должность, ч указанием дисциплин, которые он ведет. Для групп указать, какие  дисциплины ведутся, в каком семестре, номер аудитории
	В примечаниях: список литературы по дисциплинам
	Добавляются: перечень лабораторных работ по дисциплинам с лабораторным практикумами, номер учебной лаборатории
	Убираются: номер аудитории.

Sql, Data Engineer Interview
	Task:
	Создайте таблицу de13ma.XXXX_SALARY_HIST, где XXXX - ваш идентификатор. В таблице должна быть SCD2 версия таблицы de.HISTGROUP (поля PERSON, CLASS, SALARY, EFFECTIVE_FROM, EFFECTIVE_TO). Возьмите в работу таблицы
	de13ma.XXXX_SALARY_HIST и de.SALARY_PAYMENTS. Напишите SQL скрипт, выводящий таблицу платежей сотрудникам. В таблице должны быть поля PAYMENT_DT, PERSON, PAYMENT, MONTH_PAID, MONTH_REST. Результат выполнения сохраните в таблицу de13ma.XXXX_SALARY_LOG.
	1. MONTH_PAID - суммарно выплачено в месяце,
	2. MONTH_REST - осталось выплатить за месяц.
	Проверяется в первую очередь понимание как соединять фактовую таблицу с SCD2 таблицей (нельзя все расчеты сделать над DE.SALARY_PAYMENTS, ведь работнику могут недоплатить или переплатить).
	В ответе приложите SQL-скрипт, таблица de13ma.XXXX_SALARY_LOG должна быть заполнена.
	Decision:
	$ cat Sql-Gabn_SALARY_LOG6.sql
	create table de13ma.gabn_SALARY_HIST as (
		select 
			PERSON,
			CLASS,
			SALARY,
			dt as effective_from,
			coalesce((
				lead(dt) 
				over (
					partition by person 
					order by dt) - interval '1 day')::date,  
				to_date('9999-12-31', 'YYYY-MM-DD')) as effective_to
		from de.HISTGROUP);
	--select * from de13ma.gabn_SALARY_HIST;
	--select * from de.SALARY_PAYMENTS;
	create table de13ma.gabn_SALARY_LOG as (
		select --*--,
			dgsh.person as PERSON,
			dsp.dt as PAYMENT_DT,
			dsp.payment as PAYMENT,
			--sum(dsp2.payment) as MONTH_PAID,
			--sum(dsp.payment) over (order by dsp.dt between dgsh.effective_from and dgsh.effective_to) as MONTH_PAID,
			sum(dsp.payment) over (partition by dsp.payment order by dsp.dt) as MONTH_PAID,
			dgsh.salary-sum(dsp.payment) as MONTH_REST--,
			--dgsh.salary
		from de13ma.GABN_SALARY_HIST as dgsh
		inner join de.SALARY_PAYMENTS as dsp 
			on dgsh.person=dsp.person 
		--inner join de.SALARY_PAYMENTS as dsp2 
		--	on dsp.dt >= dsp2.dt
		where dsp.dt between dgsh.effective_from and dgsh.effective_to
		group by dgsh.person,
			dsp.dt,
			dsp.payment,
			dgsh.salary--,
			--dgsh.effective_from,
			--dgsh.effective_to
		order by dgsh.person,
			dsp.dt);
	select * from de13ma.gabn_SALARY_LOG;
	Task:
	На основании таблиц DE.LOG и DE.IP постройте структурированную таблицу посещений DE13MA.XXXX_LOG ( DT DATE, LINK VARCHAR( 50 ), USER_AGENT VARCHAR( 200 ), REGION VARCHAR( 30 ) ). Также постройте отчет DE13MA.XXXX_LOG_REPORT ( REGION VARCHAR( 30 ), BROWSER VARCHAR( 10 ) ) – в каких областях какой браузер является наиболее используемым.
	Под USER_AGENT подразумевается вся строка описания клиента, под BROWSER – только название браузера (Opera, Safari…). XXXX означает ваши 4 уникальные буквы.
	Важные замечания (вплоть до причины незачета задания):
	1. Не используйте регулярные выражения там, где можно обойтись без них.
	2. То, что вы видите в выводе клиента – это не всегда именно то, что содержится в базе данных.
	Decision:
	$ cat Sql-Gabn_LOG3.sql
	create table DE13MA.GABN_LOG as (
		select 
			to_date (substring (dl.data from '\d{8}'), 'YYYYMMDD') as DT,
			cast (split_part (substring (replace (substring (dl.data, strpos (dl.data, 'http://')), chr(9), '+'), 1, strpos (replace (substring (dl.data, strpos(dl.data, 'http://')), chr(9), '|'), '/5.0') -1), '+', 1) as VARCHAR(50)) LINK,
			cast (split_part (replace (substring (dl.data from 1), chr(9), '+'), '+', 8 ) as VARCHAR(200)) USER_AGENT,
			cast (split_part (di.data, chr(9), 2) as VARCHAR(30)) REGION
		from de.log as dl
		left join de.ip as di
		on
			substring (dl.data, 1, strpos (dl.data, chr(9))) = 
				substring (di.data, 1, strpos (di.data, chr(9))));
	select * from DE13MA.GABN_LOG;
	$ cat Sql-Gabn_LOG_REPORTS3.sql
	create table DE13MA.GABN_LOG_REPORT as (SELECT
			region, 
			browser--, 
			--cnt
		FROM (select
			t1.* , 
			ROW_NUMBER() OVER (PARTITION BY region ORDER BY cnt DESC) as numb
		FROM (select 
				cast (split_part (di.data, chr(9), 2) as VARCHAR(30)) REGION, 
				cast (split_part (substring (replace (substring (dl.data, strpos(dl.data, 'http://')), chr(9), '+'), 1, strpos (replace (substring (dl.data, strpos (dl.data, 'http://')), chr(9), '|'), '/5.0') -1), '+', 4) as VARCHAR(10)) BROWSER,
				count(1) as cnt
			from de.log as dl
			--order by dl.data
			left join de.ip as di
			--on dl.data=di.data;
			on 
				substring (dl.data, 1, strpos (dl.data, chr(9))) =
					substring (di.data, 1, strpos (di.data, chr(9)))	
			--order by region
			group by region, browser) 
			as t1)
		as t2
		WHERE numb = 1);
	select * from DE13MA.GABN_LOG_REPORT;
	Task:
	Создайте структуру базы данных по одной из предложенных тематик.
	К базе данных предъявляются следующие требования:
	1. должно быть не менее 4 сущностей (включая технические объекты);
	2. должна быть хотя бы одна связь один-ко-многим
	3. должна быть хотя бы одна связь многие-ко-многим;
	4. все отношения приведены к 3НФ.
	Предметная область:
	1. Продажа автомобилей.
	2. Приют для животных.
	3. Железнодорожные перевозки.
	4. Служба доставки.
	5. Организация марафона.
	Требования к оформлению:
	ER-диаграмму необходимо составлять на app.dbdesigner.net, на проверку нужно присылать ссылку на диаграмму. Также необходимо сделать таблицу в Google Sheets с примерами данных в таблицах.
	Возьмите в работу ER-диаграмму, разработанную вами. Разработайте DDL для нее. Создайте файл Sql-Ddl2.sql, в котором должно быть:
	1. DDL создания всех таблиц, с правильным указанием имен, типов и ограничений целостности.
	2. Для каждой таблицы приведите 2-3 команды INSERT для наполнения данных. Обращайте внимание на типизацию вставляемых данны
	Decision:
	$ cat Sql-Ddl2.sql
	CREATE TABLE de13ma.gabn_dz2_brands (
	id_brand SERIAL PRIMARY KEY,
	title VARCHAR (255)
	);
	INSERT INTO de13ma.gabn_dz2_brands (title) VALUES 
	('Nissan'),
	('Chevrolet'),
	('Datsun'),
	('Hyundai'),
	('Lada');
	CREATE TABLE de13ma.gabn_dz2_transmittion_box (
	id_box SERIAL PRIMARY KEY,
	title VARCHAR (255)
	);
	INSERT INTO de13ma.gabn_dz2_transmittion_box (title) VALUES 
	('Автомат'),
	('Механика'),
	('Вариатор');
	CREATE TABLE de13ma.gabn_dz2_country_partner (
	id_country SERIAL PRIMARY KEY,
	title VARCHAR (255)
	);
	INSERT INTO de13ma.gabn_dz2_country_partner (title) VALUES 
	('Russia'),
	('Japane'),
	('USA'),
	('South Korea');
	CREATE TABLE de13ma.gabn_dz2_clients (
	id_client SERIAL PRIMARY KEY,
	fio VARCHAR (255),
	phone VARCHAR (255),
	city VARCHAR (255)
	);
	INSERT INTO de13ma.gabn_dz2_clients 
	(fio, phone, city) 
	VALUES 
	('David', '88886666000', 'Kutaisi'),
	('Angelina', '88880000665', 'Irkutsk'),
	('Leonid', '88886666111', 'Irkutsk');
	CREATE TABLE de13ma.gabn_dz2_cars (
	id_car SERIAL PRIMARY KEY,
	id_brand INT REFERENCES de13ma.gabn_dz2_brands(id_brand),
	model VARCHAR (255),
	price NUMERIC,
	releases TIMESTAMP,
	id_box INT REFERENCES de13ma.gabn_dz2_transmittion_box(id_box),
	id_country INT REFERENCES de13ma.gabn_dz2_country_partner(id_country)
	);
	INSERT INTO de13ma.gabn_dz2_cars (id_brand, model, price, releases, id_box, id_country) VALUES 
	(1, 'Windgroad', 250000, '2006-09-12 12:12:12', 1, 2),
	(2, 'Aveo', 450000, '2013-09-12 12:12:12', 3, 3),
	(3, 'On-do', 300000, '2015-09-12 12:12:12', 2, 2),
	(4, 'Solaris1', 750000, '2017-09-12 12:12:12', 1, 4),
	(4, 'Solaris2', 900000, '2020-09-12 12:12:12', 1, 4),
	(5, 'Vesta', 850000, '2021-09-12 12:12:12', 3, 1);
	CREATE TABLE de13ma.gabn_dz2_sale (
	id_sale SERIAL PRIMARY KEY,
	id_car INT REFERENCES de13ma.gabn_dz2_cars(id_car),
	id_client INT REFERENCES de13ma.gabn_dz2_clients(id_client),
	dates TIMESTAMP
	);
	INSERT INTO de13ma.gabn_dz2_sale (id_car, id_client, dates) VALUES 
	(1, 1, '2006-09-12 12:12:12'),
	(2, 2, '2014-09-12 12:12:12'),
	(3, 1, '2015-09-12 12:12:12'),
	(4, 2, '2017-09-12 12:12:12'),
	(5, 3, '2020-09-12 12:12:12'),
	(6, 1, '2021-09-12 12:12:12');
	SELECT * from de13ma.gabn_dz2_sale;

Django, Разработка сайта
	Task:
	Cоздать с использованием Django и bootstrap веб-приложение для работы с информацией о неких персонах.
	Task:
	Реализовать следующие кейсы: 
	1. Автогенерация данных персон. 
	2. Поиск в списке персон. 
	3. Просмотр данных выбранной персоны. 
	4. Добавление новой персоны вручную 
	5. Редактирование данных выбранной персоны. 
	6. Экспорт данных из списка персон
	Task:
	Продумать механизм запуска автогенерации данных.
	Task:
	При автогенерации, должны создаваться персоны, например 10000, с рандомными данными по следующим полям: 
	1. ФИО (строка) 
	2. Дата рождения (дата) 
	3. Пол (справочник) 
	4. Номер мобильного телефона (строка) 
	5. Срок обучения с (дата) 
	6. Срок обучения по (дата) 
	7. Группа обучения (строка) 
	8. Наименование учебного заведения (строка)
	Task:
	У персоны также должны быть один или несколько документов, со следующими полями: 
	1. номер (строка) 
	2. дата выдачи (дата) 
	3. тип (справочник) (паспорт, студенческий, св. о рождении и т.п.) 
	4. скан документа (файл) 
	5. необходимо обеспечить уникальность номера документа в системе
	Task:
	В списке персон выводить следующие колонки: 
	1. ФИО 
	2. Дата рождения 
	3. Пол 
	4. Номер мобильного телефона 
	5. Срок обучения с 
	6. Срок обучения по 
	7. Группа обучения 
	8. Наименование учебного заведения 
	9. Номер паспорта (если есть)
	Task:
	Должен быть поиск по всем перечисленым полям 
	1. поля с датой должны иметь фильтры от и до 
	2. поля с справочниками должны иметь в фильтре мультивыбор
	Task:
	Экспорт данных из списка персон должен быть с учётом указанных в интерфейсе фильтров и сортировки.
	1. На странице просмотра детальной информации о персоне должна быть представлена инфомация по всем связанным с ней документам, включая сканы.
	2. Напиши функцию, которая будет возвращать список от N до M не используя range

Django, Построение системы для обучения
    Task:
    Суть задания заключается в проверке знаний построения связей в БД и умение правильно строить запросы без ошибок N+1.
    Построение архитектуры:
    В этом задании у нас есть три бизнес-задачи на хранение:
    1. Создать сущность продукта. У продукта должен быть владелец. Необходимо добавить сущность для сохранения доступов к продукту для пользователя.
    2. Создать сущность урока. Урок может находиться в нескольких продуктах одновременно. В уроке должна быть базовая информация: название, ссылка на видео, длительность просмотра (в секундах).
    3. Урок могут просматривать множество пользователей. Необходимо для каждого фиксировать время просмотра и фиксировать статус “Просмотрено”/”Не просмотрено”. Статус “Просмотрено” проставляется, если пользователь просмотрел 80% ролика.
    Написание запросов:
    В этом пункте потребуется использовать выполненную вами в прошлом задании архитектуру:
    1. Реализовать API для выведения списка всех уроков по всем продуктам к которым пользователь имеет доступ, с выведением информации о статусе и времени просмотра.
    2. Реализовать API с выведением списка уроков по конкретному продукту к которому пользователь имеет доступ, с выведением информации о статусе и времени просмотра, а также датой последнего просмотра ролика.
    3. Реализовать API для отображения статистики по продуктам. Необходимо отобразить список всех продуктов на платформе, к каждому продукту приложить информацию:
    1. Количество просмотренных уроков от всех учеников.
    2. Сколько в сумме все ученики потратили времени на просмотр роликов.
    3. Количество учеников занимающихся на продукте.
    4. Процент приобретения продукта (рассчитывается исходя из количества полученных доступов к продукту деленное на общее количество пользователей на платформе).
    Результат выполнения:
    1. Выполненная архитектура на базе данных SQLite с использованием Django.
    2. Реализованные API на базе готовой архитектуры.
    Мы ожидаем: 
    1. Ссылка на публичный репозиторий в GitHub с выполненным проектом.
    Source:
    1. https://docs.djangoproject.com/en/4.2/intro/tutorial01/
    2. https://docs.djangoproject.com/en/4.2/topics/db/models/
    3. https://docs.djangoproject.com/en/4.2/topics/db/queries/
    4. https://docs.djangoproject.com/en/4.2/ref/models/querysets/
    5. https://www.django-rest-framework.org/tutorial/quickstart/
    6. https://www.django-rest-framework.org/api-guide/viewsets/
    7. https://www.django-rest-framework.org/api-guide/serializers/

Sql, Решение проблем
	Task:
	Проверить базу на наличие ошибок. Какими записями забилась база.
	Decision:
	программой IbExpert (Подробная инофрмация будет)
	Task:
	После отключения света в здании служба OracleServiceНАЗВАНИЕСИСТЕМЫ не запускается. При подключении к БСР клиента на сервере выходит следующая ошибка:
	ОШИБКА ORA-01033. ORACLE INITIALIZATION OR SHUTDOWN IN PROGRESS
	Не помогает перезапуск службы ORACLE и перезагрузка сервера.
	Также пробовали подключиться и настроить базу в командной строке через sql plus. После ввода команды выдает ошибку:
	C:\>sqlplus
	Enter user-name: СОКРАЩЕННОЕОЕИМЯПОЛЬЗОВАТЕЛЯ as ПОЛНОЕИМЯПОЛЬЗОВАТЕЛЯ
	SQL> alter pluggable database all open;
	alter pluggable database all open
	*
	ERROR at line 1:
	ORA-00940: invalid ALTER command
	Нужно сделать рестарт базы
	Decision:
	C:\>sqlplus /nolog
	SQL> connect СОКРАЩЕННОЕОЕИМЯПОЛЬЗОВАТЕЛЯ/pass@НАЗВАНИЕСИСТЕМЫ as ПОЛНОЕИМЯПОЛЬЗОВАТЕЛЯ
	ERROR:
	ORA-01017: invalid username/password; logon denied
	SQL> conn СОКРАЩЕННОЕОЕИМЯПОЛЬЗОВАТЕЛЯ/oracle@НАЗВАНИЕСИСТЕМЫ as ПОЛНОЕИМЯПОЛЬЗОВАТЕЛЯ
	SQL> startup mount
	ORA-01081: cannot start already-running ORACLE - shut it down first
	SQL> shutdown immediate
	ORA-01109: database not open
	Database dismounted.
	ORACLE instance shut down.
	SQL> startup mount
	SQL> col file format a5;
	SQL> col name format a20;
	SQL> col status format a10;
	SQL> select file#,name,status from v$datafile;
	     FILE# NAME                 STATUS
	---------- -------------------- ----------
	         1 C:\ORACLE\ORADATA\GA SYSTEM
	           S\SYSTEM01.DBF
	         2 C:\ORACLE\ORADATA\GA ONLINE
	           S\UNDOTBS01.DBF
	         3 C:\ORACLE\ORADATA\GA ONLINE
	           S\CWMLITE01.DBF
	         4 C:\ORACLE\ORADATA\GA ONLINE
	           S\DRSYS01.DBF
	     FILE# NAME                 STATUS
	---------- -------------------- ----------
	         5 C:\ORACLE\ORADATA\GA ONLINE
	           S\EXAMPLE01.DBF
	         6 C:\ORACLE\ORADATA\GA ONLINE
	           S\INDX01.DBF
	         7 C:\ORACLE\ORADATA\GA ONLINE
	           S\ODM01.DBF
	         8 C:\ORACLE\ORADATA\GA ONLINE
	     FILE# NAME                 STATUS
	---------- -------------------- ----------
	           S\TOOLS01.DBF
	         9 C:\ORACLE\ORADATA\GA ONLINE
	           S\USERS01.DBF
	        10 C:\ORACLE\ORADATA\GA ONLINE
	           S\XDB01.DBF
	        11 C:\ORACLE\ORADATA\GA ONLINE
	           S\TBLS_BSR.ORA
	     FILE# NAME                 STATUS
	---------- -------------------- ----------
	        12 C:\ORACLE\ORADATA\GA ONLINE
	           S\DELO_D.DAT
	        13 C:\ORACLE\ORADATA\GA ONLINE
	           S\DELO_I.DAT
	        14 C:\ORACLE\ORADATA\GA ONLINE
	           S\DELO_O.DAT
	        15 C:\ORACLE\ORADATA\GA ONLINE
	           S\KADR_D.DAT
	     FILE# NAME                 STATUS
	---------- -------------------- ----------
	        16 C:\ORACLE\ORADATA\GA ONLINE
	           S\KADR_I.DAT
	        17 C:\ORACLE\ORADATA\GA ONLINE
	           S\KADR_O.DAT
	        18 C:\ORACLE\ORADATA\GA ONLINE
	           S\ARCH_D.DAT
	        19 C:\ORACLE\ORADATA\GA ONLINE
	     FILE# NAME                 STATUS
	---------- -------------------- ----------
	           S\ARCH_I.DAT
	        20 C:\ORACLE\ORADATA\GA ONLINE
	           S\EDS_D.DAT
	        21 C:\ORACLE\ORADATA\GA ONLINE
	           S\EDS_I.DAT
	        22 C:\ORACLE\ORADATA\GA ONLINE
	           S\EDS_O.DAT
	     FILE# NAME                 STATUS
	---------- -------------------- ----------
	        23 C:\ORACLE\ORADATA\GA ONLINE
	           S\.ORA
	        24 C:\ORACLE\ORADATA\GA SYSTEM
	           S\SYSTEM02.ORA
	        25 C:\ORACLE\ORADATA\GA SYSTEM
	           S\SYSTEM03.ORA
	25 rows selected.
	SQL> recover datafile 1;
	SQL> select file#,name,status from v$datafile;
	     FILE# NAME                 STATUS
	---------- -------------------- ----------
	         1 C:\ORACLE\ORADATA\GA SYSTEM
	           S\SYSTEM01.DBF
	         2 C:\ORACLE\ORADATA\GA ONLINE
	           S\UNDOTBS01.DBF
	         3 C:\ORACLE\ORADATA\GA ONLINE
	           S\CWMLITE01.DBF
	         4 C:\ORACLE\ORADATA\GA ONLINE
	           S\DRSYS01.DBF
	     FILE# NAME                 STATUS
	---------- -------------------- ----------
	         5 C:\ORACLE\ORADATA\GA ONLINE
	           S\EXAMPLE01.DBF
	         6 C:\ORACLE\ORADATA\GA ONLINE
	           S\INDX01.DBF
	         7 C:\ORACLE\ORADATA\GA ONLINE
	           S\ODM01.DBF
	         8 C:\ORACLE\ORADATA\GA ONLINE
	     FILE# NAME                 STATUS
	---------- -------------------- ----------
	           S\TOOLS01.DBF
	         9 C:\ORACLE\ORADATA\GA ONLINE
	           S\USERS01.DBF
	        10 C:\ORACLE\ORADATA\GA ONLINE
	           S\XDB01.DBF
	        11 C:\ORACLE\ORADATA\GA ONLINE
	           S\TBLS_BSR.ORA
	     FILE# NAME                 STATUS
	---------- -------------------- ----------
	        12 C:\ORACLE\ORADATA\GA ONLINE
	           S\DELO_D.DAT
	        13 C:\ORACLE\ORADATA\GA ONLINE
	           S\DELO_I.DAT
	        14 C:\ORACLE\ORADATA\GA ONLINE
	           S\DELO_O.DAT
	        15 C:\ORACLE\ORADATA\GA ONLINE
	           S\KADR_D.DAT
	     FILE# NAME                 STATUS
	---------- -------------------- ----------
	        16 C:\ORACLE\ORADATA\GA ONLINE
	           S\KADR_I.DAT
	        17 C:\ORACLE\ORADATA\GA ONLINE
	           S\KADR_O.DAT
	        18 C:\ORACLE\ORADATA\GA ONLINE
	           S\ARCH_D.DAT
	        19 C:\ORACLE\ORADATA\GA ONLINE
	     FILE# NAME                 STATUS
	---------- -------------------- ----------
	           S\ARCH_I.DAT
	        20 C:\ORACLE\ORADATA\GA ONLINE
	           S\EDS_D.DAT
	        21 C:\ORACLE\ORADATA\GA ONLINE
	           S\EDS_I.DAT
	        22 C:\ORACLE\ORADATA\GA ONLINE
	           S\EDS_O.DAT
	     FILE# NAME                 STATUS
	---------- -------------------- ----------
	        23 C:\ORACLE\ORADATA\GA ONLINE
	           S\.ORA
	        24 C:\ORACLE\ORADATA\GA SYSTEM
	           S\SYSTEM02.ORA
	        25 C:\ORACLE\ORADATA\GA SYSTEM
	           S\SYSTEM03.ORA
	25 rows selected.
	SQL> alter database open;
	Task:
	В ПОДСИСТЕМА не грузятся на сайт 200 дел. Смотрим лог файл:
	$ cat importer.log.xml
	...
	  <Error ReadableDateTime="23.01.2023 12:51:31" FileTimeUtc="133189230912753002">
	    <Message>Îøèáêà ïðè âûïîëíåíèè çàïðîñà:
	BEGIN BSR.PK_BSR.CTX_Sinxronize; END;
	Òåêñò îøèáêè:
	ORA-20000: Oracle Text error:
	DRG-50857: oracle error in dreii0fsh
	ORA-01653: unable to extend table BSR.DR$CTX_SRH$I by 8192 in tablespace SYSTEM
	ORA-06512: at "CTXSYS.DRUE", line 157
	ORA-06512: at "CTXSYS.CTX_DDL", line 1328
	ORA-06512: at "BSR.PK_BSR", line 313
	ORA-06512: at line 1
	</Message>
	    <Details>System.Exception: Îøèáêà ïðè âûïîëíåíèè çàïðîñà:
	BEGIN BSR.PK_BSR.CTX_Sinxronize; END;
	Òåêñò îøèáêè:
	ORA-20000: Oracle Text error:
	DRG-50857: oracle error in dreii0fsh
	ORA-01653: unable to extend table BSR.DR$CTX_SRH$I by 8192 in tablespace SYSTEM
	ORA-06512: at "CTXSYS.DRUE", line 157
	ORA-06512: at "CTXSYS.CTX_DDL", line 1328
	ORA-06512: at "BSR.PK_BSR", line 313
	ORA-06512: at line 1
	&#xD;
	   â ImpFunktions.Database.DbaseIns(String cmdString)&#xD;
	   â ImpFunktions.Importer.synchronize()</Details>
	  </Error>
	пуск - все программы - oracle orahome92 - enterprize manager console - ок - databases - gas -  system - oracle - storage - tablespaces
	Проблема из за того, что у Вас закончилось свободное оракловое ТП SYSTEM и Tbls_bsr, которые надо увеличить вручную путем добавления DATA файла. "Флаг" в чек боксе Авторасширение не поможет.
	Decision:
	Обязательно делайте бэкап перед любыми действиями с базой. Дважды щелкните ЛКМ табличное пространство SYSTEM и добавьте в него второй файл. Oracle автоматически подставит расширение ORA. Исправьте его на DBF перед сохранением. 
	system - add datafile - name - SYSTEM04.ORA - file size - 4096MB - storage - automatically extend datafile when full - increment - 10240KB - value - 32767MB - ok - перезапустить службу BSRImport - В админке обновлять авоматический импорт из СДП
	Task:
	Можно сделать это в командной строке, добавив дополнительный файл данных к табличному пространству и изменив размер текущего файла данных, Некоторые версии Oracle не позволяют такого!
	Decision:
	ALTER TABLESPACE USERS ADD DATAFILE '/u01/oradata/orcl/users02.dbf' size 25m;
	ALTER DATABASE DATAFILE '/u01/oradata/orcl/users01.dbf' resize 50M;
	Необходимо добавить новый датафайл к табличному пространству SYSTEM.
	Task:
	Ошибка: DM
	Unsuccessful execution caused by a system error that precludes successful execution of subsquent statements.
	Decision:
	Перезапуск службы FireBird
	Task:
	$ sudo apt-get -y install postgresql
	    E: Could not get lock /var/lib/dpkg/lock-frontend. It is held by process 4927 (unattended-upgr)
	    N: Be aware that removing the lock file is not a solution and may break your system.
	    E: Unable to acquire the dpkg frontend lock (/var/lib/dpkg/lock-frontend), is another process using it?
	Decision:
	$ ps aux | grep -i apt
	    root        4891  0.0  0.0   2616   536 ?        Ss   19:52   0:00 /bin/sh /usr/lib/apt/apt.systemd.daily install
	    root        4896  0.0  0.0   2616  1652 ?        S    19:52   0:00 /bin/sh /usr/lib/apt/apt.systemd.daily lock_is_held install
	    ubuntu      6172  0.0  0.0  19396   660 pts/1    S+   19:56   0:00 grep --color=auto -i apt
	$ sudo killall apt apt-get
	    apt: no process found
	    apt-get: no process found
	$ ps aux | grep -i apt
	    ubuntu      6233  0.0  0.0  19396   660 pts/1    S+   19:59   0:00 grep --color=auto -i apt
	$ sudo apt -y install postgresql
	Task:
	$ sudo sh -c 'echo "deb https://ftp.postgresql.org/pub/pgadmin/pgadmin4/apt/$(lsb_release -cs) pgadmin4 main" > /etc/apt/sources.list.d/pgadmin4.list && apt update'
	    ...                                   
	    Err:12 http://ppa.launchpad.net/wireshark-dev/stable/ubuntu focal
	    ...
	    All packages are up to date.
	    W: Failed to fetch http://ppa.launchpad.net/wireshark-dev/stable/ubuntu/dists/focal/InRelease  Temporary failure resolving 'ppa.launchpad.net'
	    W: Some index files failed to download. They have been ignored, or old ones used instead.
	Decision:
	$ cat /etc/apt/sources.list.d/pgadmin4.list
	deb https://ftp.postgresql.org/pub/pgadmin/pgadmin4/apt/focal pgadmin4 main
	$ sudo vim /etc/apt/sources.list.d/pgadmin4.list
	$ cat /etc/apt/sources.list.d/pgadmin4.list
	#deb https://ftp.postgresql.org/pub/pgadmin/pgadmin4/apt/focal pgadmin4 main
	$ sudo apt-get clean
	$ sudo apt-get update
	    ...                   
	    Reading package lists... Done
	$ sudo sh -c 'echo "deb https://ftp.postgresql.org/pub/pgadmin/pgadmin4/apt/$(lsb_release -cs) pgadmin4 main" > /etc/apt/sources.list.d/pgadmin4.list && apt update'
	Task:
	Ошибки в время установки и настройки postgresql
	    Skipping acquire of configured file 'main/binary-i386/Packages' as repository 'http://apt.postgresql.org/pub/repos/apt focal-pgdg InRelease' doesn't support architecture 'i386'
	$ sudo sh -c 'echo "deb http://apt.postgresql.org/pub/repos/apt $(lsb_release -cs)-pgdg main" > /etc/apt/sources.list.d/pgdg.list'
	$ wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add -
	    OK
	$ sudo apt-get update
	    ...                    
	    Reading package lists... Done
	    N: Skipping acquire of configured file 'main/binary-i386/Packages' as repository 'http://apt.postgresql.org/pub/repos/apt focal-pgdg InRelease' doesn't support architecture 'i386'
	Decision:
	$ cat /etc/apt/sources.list.d/pgdg.list
	deb http://apt.postgresql.org/pub/repos/apt focal-pgdg main
	$ sudo vim /etc/apt/sources.list.d/pgdg.list
	$ cat /etc/apt/sources.list.d/pgdg.list
	deb [arch=amd64] http://apt.postgresql.org/pub/repos/apt/ focal-pgdg main
	$ sudo apt-get update
	    ...                                      
	    Reading package lists... Done
	Task:
	    Could not get lock /var/lib/dpkg/lock-frontend. It is held by process 4927 (unattended-upgr). Be aware that removing the lock file is not a solution and may break your system. Unable to acquire the dpkg frontend lock (/var/lib/dpkg/lock-frontend), is another process using it?
	$ sudo apt-get -y install postgresql
	    E: Could not get lock /var/lib/dpkg/lock-frontend. It is held by process 4927 (unattended-upgr)
	    N: Be aware that removing the lock file is not a solution and may break your system.
	    E: Unable to acquire the dpkg frontend lock (/var/lib/dpkg/lock-frontend), is another process using it?
	Decision:
	$ ps aux | grep -i apt
	    root        4891  0.0  0.0   2616   536 ?        Ss   19:52   0:00 /bin/sh /usr/lib/apt/apt.systemd.daily install
	    root        4896  0.0  0.0   2616  1652 ?        S    19:52   0:00 /bin/sh /usr/lib/apt/apt.systemd.daily lock_is_held install
	    ubuntu      6172  0.0  0.0  19396   660 pts/1    S+   19:56   0:00 grep --color=auto -i apt
	$ sudo killall apt apt-get
	    apt: no process found
	    apt-get: no process found
	$ ps aux | grep -i apt
	    ubuntu      6233  0.0  0.0  19396   660 pts/1    S+   19:59   0:00 grep --color=auto -i apt
	$ sudo apt -y install postgresql
	    Reading package lists... Done
	    Building dependency tree       
	    Reading state information... Done
	    ...
	    Selecting previously unselected package libjson-perl.
	Task:
	    Failed to fetch http://ppa.launchpad.net/wireshark-dev/stable/ubuntu/dists/focal/InRelease  Temporary failure resolving 'ppa.launchpad.net'. Some index files failed to download. They have been ignored, or old ones used instead.
	$ sudo curl https://www.pgadmin.org/static/packages_pgadmin_org.pub | sudo apt-key add
	      % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
	                                     Dload  Upload   Total   Spent    Left  Speed
	    100  3935  100  3935    0     0    633      0  0:00:06  0:00:06 --:--:--   824
	    OK
	$ sudo sh -c 'echo "deb https://ftp.postgresql.org/pub/pgadmin/pgadmin4/apt/$(lsb_release -cs) pgadmin4 main" > /etc/apt/sources.list.d/pgadmin4.list && apt update'
	    Hit:1 http://archive.ubuntu.com/ubuntu focal InRelease
	    Hit:2 http://ru.archive.ubuntu.com/ubuntu bionic InRelease
	    Get:11 https://ftp.postgresql.org/pub/pgadmin/pgadmin4/apt/focal pgadmin4/main all Packages [1957 B]                                     
	    Err:12 http://ppa.launchpad.net/wireshark-dev/stable/ubuntu focal InRelease                                                              
	      Temporary failure resolving 'ppa.launchpad.net'
	    Fetched 338 kB in 10s (33.3 kB/s)
	    Reading package lists... Done
	    Building dependency tree       
	    Reading state information... Done
	    All packages are up to date.
	    W: Failed to fetch http://ppa.launchpad.net/wireshark-dev/stable/ubuntu/dists/focal/InRelease  Temporary failure resolving 'ppa.launchpad.net'
	    W: Some index files failed to download. They have been ignored, or old ones used instead.
	Decision:
	$ cat /etc/apt/sources.list.d/pgadmin4.list
	deb https://ftp.postgresql.org/pub/pgadmin/pgadmin4/apt/focal pgadmin4 main
	$ sudo vim /etc/apt/sources.list.d/pgadmin4.list
	$ cat /etc/apt/sources.list.d/pgadmin4.list
	#deb https://ftp.postgresql.org/pub/pgadmin/pgadmin4/apt/focal pgadmin4 main
	$ sudo apt-get clean
	$ sudo apt-get update
	    ...                   
	    Reading package lists... Done
	$ sudo sh -c 'echo "deb https://ftp.postgresql.org/pub/pgadmin/pgadmin4/apt/$(lsb_release -cs) pgadmin4 main" > /etc/apt/sources.list.d/pgadmin4.list && apt update'
	    ...
	    Reading package lists... Done
	    Building dependency tree       
	    Reading state information... Done
	    All packages are up to date.
	Task:
	$ sudo mysql -u root
	    [sudo] password for ar:
	    ERROR 2002 (HY000): Can't connect to local MySQL server through socket '/var/run/mysqld/mysqld.sock' (2)
	Decision:
	$ sudo service mysql status
	     * MySQL is stopped.
	$ sudo service mysql start
	     * Starting MySQL database server mysqld                                                                                su: warning: cannot change directory to /nonexistent: No such file or directory
	                                                                                                                     [ OK ]
	$ sudo service mysql status
	     * /usr/bin/mysqladmin  Ver 8.0.28-0uu0.20.04.3 for Linux on x86_64 ((uu))
	    Copyright (c) 2000, 2022, Oracle and/or its affiliates.
	    Oracle is a registered trademark of Oracle Corporation and/or its
	    affiliates. Other names may be trademarks of their respective
	    owners.
	    Server version          8.0.28-0uu0.20.04.3
	    Protocol version        10
	    Connection              Localhost via UNIX socket
	    UNIX socket             /var/run/mysqld/mysqld.sock
	    Uptime:                 24 sec
	    Threads: 2  Questions: 8  Slow queries: 0  Opens: 436  Flush tables: 3  Open tables: 27  Queries per second avg: 0.333
	$ sudo mysql -u root
	    Welcome to the MySQL monitor.  Commands end with ; or \g.
	    Your MySQL connection id is 12
	    Server version: 8.0.28-0uu0.20.04.3 (uu)
	    Copyright (c) 2000, 2022, Oracle and/or its affiliates.
	    Oracle is a registered trademark of Oracle Corporation and/or its
	    affiliates. Other names may be trademarks of their respective
	    owners.
	    Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

Sql, Администрирование
	Task:
	Создание и подключение к БД
	Decision:
	postgres-# \! chcp 1251
	postgres-# \l
	postgres-# CREATE DATABASE starter;
	postgres-# DROP DATABASE starter;
	postgres-# CREATE DATABASE starter;
	postgres-# \c starter
	Task:
	Работа с пользователями в PostgreSQL
	Decision:
	sudo -u postgres -H -- psql -d template1 -c "CREATE USER YOUR-USERNAME WITH PASSWORD 'USERSPASSWORD';"
	sudo -u postgres -H -- psql -d template1 -c "CREATE database NAMEDB;"
	sudo -u postgres -H -- psql -d template1 -c "GRANT ALL PRIVILEGES ON DATABASE "NAMEDB" to YOUR-USERNAME;"
	sudo -u postgres -H -- psql -d template1 -c "\c NAMEDB;"
	sudo -u postgres -H -- psql -d template1 -c "GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO "YOUR-USERNAME";"
	Source:
	https://www.dmosk.ru/miniinstruktions.php?mini=postgresql-users&ysclid=lig0a2xuou515754413#create
	Task:
	выполнить подключение к удаленной БД с помощью инструмента администрирования
	Decision:
	$ mysql -host=ubuntu-VirtualBox
	Task:
	выполнить корректную остановку, старт БД
	Decision:
	$ sudo systemctl stop mysql
	Task:
	проверка состояния БД
	Decision:
	$ sudo systemctl status mysql
	Task:
	оценить заполненность табличного пространства
	Decision:
	mysql> show databases;	