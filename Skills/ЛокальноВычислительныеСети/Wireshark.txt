Task:
Протокол TLS. В wirеshark настраиваем фильтр по протоколу tls и дальше пишем адрес сайта, которого хотим открыть.
Decision:
$ nslookup asozykin.ru
    Server:        127.0.0.53
    Address:    127.0.0.53#53
    Non-authoritative answer:
    Name:    asozykin.ru
    Address: 185.215.4.10
Дбавляем в wireshark  tls && ip.addr == 185.215.4.10 и откроем в браузере страницу asozykin.ru. Возращаемся в wireshark.
Взаимодествие начинается с установки соединения. Первый пакет который передается - client hello (приветствие от клиента). В нем мы видим, что вложены протоколы tls, tcp, ipv4. Протокол Tls содержит три поля: content type - тип сообщения, версия, длина сообщения и затем идет протокол установки соединения - handshake protocol.
В нем видим тип сообщения - client hello, версия, длина сообщения, random - случайное число сгенерированное клиентом, который используется для генерации разделяемого ключа. Клиент передает набор шифров - cipher suites. В набор шифров входит написание криптографических шифров, которые используются для защиты данных. Для каждого набора используется свой код и свое название. Название начинается с протокола - tls, затем идет тип протокола для обмена ключами - ecdhe, для цифровой подписи алгоритм - ecdsa, для симметричного шифрования используется - aes_128. во всех шифрах ecdhe для обмена ключами используется алгоритм ecdhe, означает, что в этих шифрах используется совершенно прямую секретность. А в шифрах RSA используется для обмена ключами, он не может совершить такую секретность. Клиент передает список всех наборов шифров, который поддерживает и в ответ от сервера в сообщений Server Hello, ожидает, что сервер выберет один из этих шифров. Затем идут расширения протокола TLS - extensions. Нас интересует расширение Server_name, оно указывает имя сервера. Это полезно если на одном и том же ip адресе работает несколько серверов.
Смотрим что содержится в server Hello.
Видим какой шифр выбрал server в cipher suites. Дальше происходит передача зашифрованных данных
в encrrypted application data мы видим, что данные, которые передаются по сети зашифрованы, именно это и обеспечивает защиту.
Task:
Протокол DNS - Прикладной уровень. C помощью nslookup определим ip адрес веб-сервера yandex
Decision:
$ nslookup www.yandex.ru
    Server:     127.0.0.53
    Address:    127.0.0.53#53
    Non-authoritative answer:
    Name:   www.yandex.ru
    Address: 77.88.55.80
    Name:   www.yandex.ru
    Address: 5.255.255.80
    Name:   www.yandex.ru
    Address: 5.255.255.88
    Name:   www.yandex.ru
    Address: 77.88.55.88
    Name:   www.yandex.ru
    Address: 2a02:6b8:a::a
В нашем случае 4 ip адреса у веб-сервера yandex версии ipv4 и один адрес 2a02:6b8:a::a версии ipv6. Non-authoritative answer - означает, что мы получили ответ не от сервера, который отвечает за зону yandex.ru, а от другого сервера - 127.0.0.53. Через веб-браузер подключимся по ip адресу. Сейчас почти везде используются виртуальные web-серверы (как в нашем случае), которые на одном IP-адресе обслуживают несколько сайтов. Поэтому для подключения к ним всегда нужно dns имя сайта, иначе виртуальный web-сервер не понимает, какой сайт запрашивается.
Task:
Запустим wireshark, в фильтре напишем dns, выполним еще раз запрос в консолеи смотрим в wireshark dns пакеты
Decision:
$ nslookup www.yandex.ru
    Server:     127.0.0.53
    Address:    127.0.0.53#53
    Non-authoritative answer:
    Name:   www.yandex.ru
    Address: 77.88.55.80
    Name:   www.yandex.ru
    Address: 5.255.255.80
    Name:   www.yandex.ru
    Address: 5.255.255.88
    Name:   www.yandex.ru
    Address: 77.88.55.88
    Name:   www.yandex.ru
Вот он, пакет, который использует UDP протокол, порт - 53, порт отправителя - 56270.
Протокол dns с номером транзакции 0х0b83
Флаги: первый запрос, второй стандартный запрос, третий запрос на работу днс сервере в рекурсивном режиме. questions - в данных у нас находится одно поле с запросом ответов (answer), авторитетных серверов (authority) и дополнительных записей (additional).
Запрос всео один в queries - www.yandex.ru, тип записи у него А, класс - IN (интернет), единственный класс, который используется в днс.
Также использует udp протокол, в заголовке идентификатор транзакции - 0х0b83, во флагах - информация о том, что это ответ, с типом ответа - стандартный, сервер выполнил запрос в рекурсивном режиме (recursion available), ошибки не возникло (reply code). В данных у нас 1 запрос (questions) и 4 записи с ответом (answer rrs). Запрос, который мы уже видели (queries). и 4 ответа (answers), который содержит разные ip адреса (они совпадают с адресами в консоли). time to live - время, которое можно сохранить кеш за 271 секунд, длина записи - data length (4 байта).
Также утилита nslookup отправила другой запрос в котором запрашивается запись АААА, это адрес Ipv6, идентификтор транзакции 34f5. и за ним же ответ с тем же самым иднтификатором транзакции.
В разделе данных (AAAA address) у ннего содержится версия ipv6.
Task:
Типы записей DNS. Запрос записей разных типов
Decision:
    nslookup -type=XXX yandex.ru
Task:
Запрос записей разных типов:
Decision:
$ nslookup -type=A www.yandex.ru
    Сервер: auth.hotelhighway.com
    Address: 172.27.0.1
    Не заслуживающий доверия ответ:
    Имя :     www.yandex.ru
    Addresses: 5.255.255.55
                77.88.55.66
                5.255.255.5
                77.88.55.55
$ nslookup -type=AAAA www.yandex.ru
    Сервер : auth.hotelhighway.com
    Address: 172.27.0.1
    Не заслуживающий доверия ответ:
    Имя :         www.yandex.ru
    Address:     2a02:6b8:a::a
Task:
C помощью nslookup определим ip адрес веб-сервера yandex
Decision:
$ nslookup www.yandex.ru
    Server:     127.0.0.53
    Address:    127.0.0.53#53
    Non-authoritative answer:
    Name:   www.yandex.ru
    Address: 77.88.55.50
    Name:   www.yandex.ru
    Address: 77.88.55.88
    Name:   www.yandex.ru
    Address: 5.255.255.5
    Name:   www.yandex.ru
    Address: 5.255.255.88
    Name:   www.yandex.ru
    Address: 2a02:6b8:a::a
Task:
Введем тип записи днс с компощью ключа type с запросом ipv4
Decision:
$ nslookup -type=A www.yandex.ru
    Server:     127.0.0.53
    Address:    127.0.0.53#53
    Non-authoritative answer:
    Name:   www.yandex.ru
    Address: 5.255.255.88
    Name:   www.yandex.ru
    Address: 5.255.255.5
    Name:   www.yandex.ru
    Address: 77.88.55.88
    Name:   www.yandex.ru
    Address: 77.88.55.50
Task:
Чтобы запросить адрес с версией ipv6 нужно указать тип AAAA
Decision:
$ nslookup -type=AAAA www.yandex.ru
    Server:     127.0.0.53
    Address:    127.0.0.53#53
    Non-authoritative answer:
    Name:   www.yandex.ru
    Address: 2a02:6b8:a::a
Task:
Определим адрес почтового сервера, которые принимают почту для домена
Decision:
$ nslookup -type=MX www.yandex.ru
    Server:     127.0.0.53
    Address:    127.0.0.53#53
    Non-authoritative answer:
    www.yandex.ru   mail exchanger = 10 mx.yandex.ru.
    Authoritative answers can be found from:
Task:
mx.yandex.ru - адрес сервера, 10 - его приоритет. Смотрим эту информацию в wireshark.
Decision:
Это запрос протокола. MX - тип записи. А вот ответ протокола:
Preference - приоритет (10). дополнительные записи:
Task:
Поробуем запросить для gmail.com
Decision:
$ nslookup -type=MX gmail.com
    Server:     127.0.0.53
    Address:    127.0.0.53#53
    Non-authoritative answer:
    gmail.com   mail exchanger = 30 alt3.gmail-smtp-in.l.google.com.
    gmail.com   mail exchanger = 10 alt1.gmail-smtp-in.l.google.com.
    gmail.com   mail exchanger = 40 alt4.gmail-smtp-in.l.google.com.
    gmail.com   mail exchanger = 5 gmail-smtp-in.l.google.com.
    gmail.com   mail exchanger = 20 alt2.gmail-smtp-in.l.google.com.
    Authoritative answers can be found from:
Здесь вместо одного сервера используется имен серверов с разными приоритетами. Впервую очередь используется сервис с наименьшим приоритетом, в нашем случае 5.
Task:
Дальше мы хотим узнать какие сервера отвечают за зону gmail.com
Decision:
$ nslookup -type=NS gmail.com
    Server:     127.0.0.53
    Address:    127.0.0.53#53
    Non-authoritative answer:
    gmail.com   nameserver = ns3.google.com.
    gmail.com   nameserver = ns1.google.com.
    gmail.com   nameserver = ns2.google.com.
    gmail.com   nameserver = ns4.google.com.
    Authoritative answers can be found from:
Тут видим 4 сервера. Cмотрим в wireshark: Тут видим тип записи - NS. в зоне ответа ответе видим 4 записи с серверами ns3.google.com, ns1.google.com, ns2.google.com, ns4.google.com
Task:
Прямой запрос выглядит так:
Decision:
$ nslookup gmail.com
    Server:     127.0.0.53
    Address:    127.0.0.53#53
    Non-authoritative answer:
    Name:   gmail.com
    Address: 173.194.73.19
    Name:   gmail.com
    Address: 173.194.73.17
    Name:   gmail.com
    Address: 173.194.73.18
    Name:   gmail.com
    Address: 173.194.73.83
    Name:   gmail.com
    Address: 2a00:1450:4010:c0d::53
    Name:   gmail.com
    Address: 2a00:1450:4010:c0d::11
    Name:   gmail.com
    Address: 2a00:1450:4010:c0d::12
    Name:   gmail.com
    Address: 2a00:1450:4010:c0d::13
Task:
А обратный запрос используется для определения доменного имени компьютера по его ip адресу:
Decision:
$ nslookup 77.88.55.88
    88.55.88.77.in-addr.arpa    name = yandex.ru.
    Authoritative answers can be found from
B wireshark запрос и ответ выглядят так:
В запросе видим, что имя записано в специальном домене in-addr.arpa. это домен для реверсивной зоны и сам адрес у него записан наоборот, начиная с конца. тип записи - ptr, который используется в обратноых зонах днс, для того чтобы поставить соответсвие ip адресу компьютера доменное имя.
DNS: итеративный и рекурсивный режим
$ nslookup www.yandex.ru
    Server:     127.0.0.53
    Address:    127.0.0.53#53
    Non-authoritative answer:
    Name:   www.yandex.ru
    Address: 77.88.55.55
    Name:   www.yandex.ru
    Address: 5.255.255.5
    Name:   www.yandex.ru
    Address: 77.88.55.50
    Name:   www.yandex.ru
    Address: 5.255.255.50
    Name:   www.yandex.ru
    Address: 2a02:6b8:a::a
127.0.0.53 - dns-сервер, который находится в локальной сети. Сервер работает в рекурсивном режиме. Сервер, который находится в локальной сети сам опрашивает все необходимые днс сервера и возращает нам уже готовый ответ. Посмотрим в Wireshark как задается желаемый режим взаимодействия с серверами dns в днс пакете:
Ipv4, dst - айпи получателя, сервер который находится в локальной сети. Когда клиент отправляет запрос, он устанавливает флаг recursion desired (1), то есть просит сервер работать в рекурсивном режиме. у ответа сервера в поле флаги стоит реукрсия доступна (recursion available - 1), то есть сервер может работать в рекурсивном режиме.
Но не все серверы могут работать в таком режиме. Серверы, которые обслуживают крупные доменные зоны (корневая доменная зона, зона room), работают только в декоративном режиме.
Task:
Попробуем в декоративном режиме получить ip адрес компьютера www.yandex.ru. Сначала нам нужно узнать адреса серверов, которые обслуживают корневой домен. В качестве записи указываем ns - name server, которые обслуживают зону и в качестве доменного имени указывает точку (корневой домен)
Decision:
$ nslookup -type=ns .
    Server:     127.0.0.53
    Address:    127.0.0.53#53
    Non-authoritative answer:
    .   nameserver = e.root-servers.net.
    .   nameserver = h.root-servers.net.
    .   nameserver = l.root-servers.net.
    .   nameserver = i.root-servers.net.
    .   nameserver = a.root-servers.net.
    .   nameserver = d.root-servers.net.
    .   nameserver = c.root-servers.net.
    .   nameserver = b.root-servers.net.
    .   nameserver = j.root-servers.net.
    .   nameserver = k.root-servers.net.
    .   nameserver = g.root-servers.net.
    .   nameserver = m.root-servers.net.
    .   nameserver = f.root-servers.net.
Task:
Пробуем запроситb интересующее нас доменное имя у одного из корневых серверов с адресом 198.41.0.4
Decision:
$ nslookup 198.41.0.4 a.root-servers.net
    Authoritative answers can be found from:
    in-addr.arpa    nameserver = e.in-addr-servers.arpa.
    in-addr.arpa    nameserver = f.in-addr-servers.arpa.
    in-addr.arpa    nameserver = d.in-addr-servers.arpa.
    in-addr.arpa    nameserver = c.in-addr-servers.arpa.
    in-addr.arpa    nameserver = b.in-addr-servers.arpa.
    in-addr.arpa    nameserver = a.in-addr-servers.arpa.
    e.in-addr-servers.arpa  internet address = 203.119.86.101
    e.in-addr-servers.arpa  has AAAA address 2001:dd8:6::101
    f.in-addr-servers.arpa  internet address = 193.0.9.1
    f.in-addr-servers.arpa  has AAAA address 2001:67c:e0::1
    d.in-addr-servers.arpa  internet address = 200.10.60.53
    d.in-addr-servers.arpa  has AAAA address 2001:13c7:7010::53
    c.in-addr-servers.arpa  internet address = 196.216.169.10
    c.in-addr-servers.arpa  has AAAA address 2001:43f8:110::10
    b.in-addr-servers.arpa  internet address = 199.253.183.183
    b.in-addr-servers.arpa  has AAAA address 2001:500:87::87
    a.in-addr-servers.arpa  internet address = 199.180.182.53
    a.in-addr-servers.arpa  has AAAA address 2620:37:e000::53
Task:
Протокол HTTP - Прикладной уровень. Для исследования http используем клиент терминал, который позволяет передавать на сервер строки. Можно использовать putty или telnet. B Host name пишем доменное имя сервера, к которому мы хотим подключиться (dato-138it.ru) и connection type - raw, чтобы передавать данные без каких то изменений, порт 80 и запретим закрывать окно после закрытия соединения.
Decision:
Соединение установлено, можно передавать http запрос. Запрос начинается с метода, потом адрес ресурса (/-начальная страница) версия протокола, имя сервера. тоже самое можно сделать в телнет, просто введя команды:
$ telnet dato-138it.ru 80
    Trying 92.53.96.18...
    Connected to dato-138it.ru.
    Escape character is '^]'.
GET / HTTP/1.1
Host: dato-138it.ru

    HTTP/1.1 200 OK
    Server: nginx/1.14.1
    Date: Sat, 09 Oct 2021 06:19:59 GMT
    Content-Type: text/html; charset=utf-8
    Content-Length: 3087
    Connection: keep-alive
    Vary: Accept-Encoding
    Last-Modified: Fri, 24 Sep 2021 12:53:47 GMT
    ETag: "c0f-5ccbd3cf4529e"
    Accept-Ranges: bytes
    <!DOCTYPE html>
    <html>
    <head>
    ...
    <body>
    ...
    </body>
    </html>
тут мы видим ответ сервера в формате html. Ответ начинается со статуса (HTTP/1.1 200 OK). в заголовках указана реализация сервера (Server: nginx/1.14.1). длина страницы (Content-Length: 3087). информация о том, что сервер оставил соединение не закрытым (Connection: keep-alive), чтобы можно было отправлять запросы с тем же самым соединением.
Task:
запросим веб страницу, которая не существует на сервере.
Decision:
$ telnet dato-138it.ru 80
    Trying 92.53.96.18...
    Connected to dato-138it.ru.
    Escape character is '^]'.
GET /123 HTTP/1.1
Host: dato-138it.ru
    HTTP/1.1 404 Not Found
    Server: nginx/1.14.1
    Date: Sat, 09 Oct 2021 06:30:04 GMT
    Content-Type: text/html; charset=iso-8859-1
    Content-Length: 201
    Connection: keep-alive
    <!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
    <html><head>
    <title>404 Not Found</title>
    </head><body>
    <h1>Not Found</h1>
    <p>The requested URL /123 was not found on this server.</p>
    </body></html>
Task:
В ответе статус 404 (HTTP/1.1 404 Not Found) - не найдена страница. По эксперементируем еще с текстовыми запросами, чтобы получить еще заголовки.
Decision:
$ telnet www.yandex.ru 80
    Trying 77.88.55.50...
    Connected to www.yandex.ru.
    Escape character is '^]'.
GET / HTTP/1.1
Host: www.yandex.ru
    HTTP/1.1 301 Moved permanently
    Cache-Control: max-age=1209600,private
    Location: https://yandex.ru/
    NEL: {"report_to": "network-errors", "max_age": 86400, "success_fraction": 0.001, "failure_fraction": 0.1}
    P3P: policyref="/w3c/p3p.xml", CP="NON DSP ADM DEV PSD IVDo OUR IND STP PHY PRE NAV UNI"
    Portal: Home
    Report-To: { "group": "network-errors", "max_age": 86400, "endpoints": [ { "url": "https://dr.yandex.net/nel"}]}
    Transfer-Encoding: chunked
    X-Content-Type-Options: nosniff
    X-Yandex-Req-Id: 1633761443643575-15557569317521118508-sas3-0783-515-sas-l7-balancer-8080-BAL-5547
    set-cookie: is_gdpr=0; Path=/; Domain=.yandex.ru; Expires=Mon, 09 Oct 2023 06:37:23 GMT
    set-cookie: is_gdpr_b=CKDNLhCRSigC; Path=/; Domain=.yandex.ru; Expires=Mon, 09 Oct 2023 06:37:23 GMT
    set-cookie: _yasc=0+j/vk1Zs02REJJvuglK5Lj/Pz28h3fh1b3rJtUjfttgaQ==; domain=.yandex.ru; path=/; expires=Mon, 08-Nov-2021 06:37:23 GMT; secure
    0
GET /nel HTTP/1.1
Host: dr.yandex.ru
    HTTP/1.1 302 Moved temporarily
    Content-Length: 0
    Location: https://dr.yandex.ru/nel
    NEL: {"report_to": "network-errors", "max_age": 86400, "success_fraction": 0.001, "failure_fraction": 0.1}
    Report-To: { "group": "network-errors", "max_age": 86400, "endpoints": [ { "url": "https://dr.yandex.net/nel"}]}
    X-Content-Type-Options: nosniff
    X-XSS-Protection: 1; mode=block
    set-cookie: is_gdpr=0; Path=/; Domain=.yandex.ru; Expires=Mon, 09 Oct 2023 06:41:21 GMT
    set-cookie: is_gdpr_b=CKDNLhCRSg==; Path=/; Domain=.yandex.ru; Expires=Mon, 09 Oct 2023 06:41:21 GMT
    set-cookie: _yasc=pO80+yKKSm7/BUQc7fMoBomkXafH7K0R7nKs+c0W97o0CI/Y; domain=.yandex.ru; path=/; expires=Mon, 08-Nov-2021 06:41:21 GMT; secure
Task:
Порты на транспортном уровне. Рассмотрим адресацию транспортного уровня в wireshark. В стеке протокола tcp/ip это порты. Это уникальный номер процесса, который взаимодействует с другими процессами по сети. У него есть два протокола TCP и UDP. Рассмотрим как использяуются данные порты. Введем в фильтре http и откроем браузер. Это протокол для просмотра веб-страниц
Decision:
Вот пакеты http запрос про страницн сайта и сам заголовок TCP
В начале идут номера портов. Номер целевого порта (destination port) - 80 (номер веб сервера).
Порты до 1024 - широкоизвестные порты, которые закреплены за теми или иными сервисами. То есть порт 80 закреплен за веб-сервером.
Порт отправителя - 47342. Когда мы подключаемся веб-серверу с помощью браузера, номер порта, на который работает браузер, для нас значения не имеет. Поэтому номера портов для клиентов назначаются операционной системой.
А дальше мы видим ответ, который присылает нам с порта номер 80 на порт 47342:
Вот dns пакет, в котором выполняется запрос на разрешение доменного имени firefox. Видиим, что dns в отличии от http использует транспортный уровень udp.
Порт назначения - 53, порт отправителя - 50577, он так же аавтоматически назначен операционной ситемой для ДНС-клиента.
Рассмотрим протокол DHCP. У него фиксирован не только номер порта сервера 67, но и номер порта клиента 68.
Dhcp Discovery- поиск запроса на dhcp-server. DHCP-Offer - ответ dhcp-server.
Теперь мы знаем как смотреть номера портов в протоколах транспортного уровня.
Task:
Установка соединения в TCP - Транспортный уровень. Рассмотрим как установить соеденение в tcp. Если смотреть соединение с веб-сервером, то там будут не сколько соединений: на странице самого текста стилевого файла картинок. Почтовый клиент имеет всего одно соединение. Устанавливать мы будем с почтовым сервером сервером с помощью почтового клиента.
Decision:
B фильтре добавим tcp
Тут видим три сегмента, которые используются для установки соединения. В ТСП используется процедура трехкратного рукопажатия.
Сначала отпрвляется с установленным флагом SYN, получатели отправляеют в ответ сегменты SYN,ACK и отправители передают сегмент с установленным флагом ACK.
SYN - запрос на соединение. порт назначения - 80, который работает по протоколу http, порт отправителя - 38532. Нас интереуют флаги
Все флаги сброшены, кроме одного - Syn: Seet.
номер байта tcp - sequence number. 0 - относительный номер последовательности. В нижней части видим что здесь совсем не 0.
Чтобы отключить предварительную обработку, убираем галочку на analyze protocol
Теперь видим реальный номер байта, который используется для нумерации байтов в потоке.
SYN,ACK - данное сообщение передает почтовый сервер. это говорит о том, что он хочет установить соединение - флаг SYN, и подтверждает получение предыдущего сообщения - флаг ACK.
В поле флаги, установлены 2 флага - ack и syn. поле acknowledgment number - содержит номер байта. Предыдущий номер заканчивался на 8, а текущий на 9. sequence number - номер лишь сообщения который будет показан в слудющем сообщении. Это нужно для того, чтобы не пеерепутать данные пришедшие из рразных соединений.
ACK - данный сегмент инифиатор соединения передают получателю, где говорит о том, что предыдущее сообщение получено и можно устанавливать соединение.
тут уже только один флаг - acknowledgment. в acknowledgment number стоит номер ожидаемого следующего байта.
Соединение установлено, теперь происходит обмен данными, а после происходит разрыв соединения FIN, ACK
Со стороны сервера разрыв соединения недостаточно, клиент тоже должен закрыть соединение.
В Wireshark можно также посмотреть установку и разрыв соединение в:
    меню-statistics-flow graph.
Task:
Протокол TCP: сокеты - Транспортный уровень. Программист взаимодействует с транспортным уровнем через интерфейс сокетов. Протоколы скрыты от программиста. При изменении протоколов транспортного уровня программу менять не придется.
Decision:
Серверный сокет:
import socket
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.bind(('192.168.0.1', 8888))
s.listen(1)
conn, addr = s.accept()
while True:
    data = conn.recv(1024)
    if not data: break
    conn.sendall(data)
conn.close()
Клиентский сокет:
import socket
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('192.168.0.1', 8888))
s.sendall(b'Hello, world!')
data = s.recv(1024)
s.close()
print('Полученные данные:', repr(data))
Task:
Инкапсуляция. Это включение сообщения вышестоящего уровня в сообщении нижестоящего. И сообщение целиком состоит из заголовка данных. Вот пакет протокола http:
Decision:
Устройства сетевого уровня маршрутизаторы анализируют заголовок ipv4:
извлекают ip адрес получателя destination и с помощью таблицы маршрутизации определяю куда нужно передавать этот ip пакет. То что проходит дальше этого заголовка сетевого уровня маршрутизаторы не рассматривают. Это считаются данные сетевого уровня, но на самом деле в данные сетевого уровня вложено сообщение траснпортного уровня, которое опять же начинается с заголовка:
главные здесь поля, destination port и source port. все что находится дальше этого заголовка протокол ТСР считает данными и не обрабатывает. Но там находятся сообщения протокола прикладного уровня http:
Итак, наш пакет http на самом деле состоит из сообщений разных уровней - канального, сетевого, транспортного и прикладного, которые вложены в друг в друга. это и называется инкапсуляция.
Не всегда в пакетах будут присутствовать протоколы всех уровней. Например, в ARP используются всего два уровня
Это канальный уровень с протоколом ethernet и сетевой уровень с протоколом arp.
Task:
Протокол IP - Сетевой уровень. Рассмотрим, как устроен заголовок протокола IP. Выбираем пакет в wireshark, например, DNS.
Decision:
В нижней части видим цифровое представление пакетов в том виде, в котором он передается по сети.
В начале пакет, представлен заголовок канального уровня.
Дальше идет заголовок версии IPv4 и в нем мы можем посмотреть какие есть поля. Важные поля здесь адреса отправителя (source) и получателя (destination), код протокола уровня (в нашем случае - 17).
В начале идет версия протокола. Затем идет поле длина заголовка, значение 5, означает, что длина заголовка - 20 байт.
Следующее поле из 8ми бит состоит из 2х частей. Первые 6 бит предназначены для передачи данных о качестве обслуживания. Сейчас используется формат дифференированного обслуживания, но в этом пакете никакие флаги не установлены. Последние 2 байта используют в технологии explicit notification. Технологии используются маршрутизатором для того, чтобы сообщить о перегрузке сети. Отправитель получив такой сигнал, должен передавать меньше данных в сеть, для этого он уменьшает размер окна.
Следующее поле - общая длина (86).
Затем идут 3 поля, которые используются для фрагментации - идентификатор пакета, флаги и смещение фрагмента. Для флага есть 3 бита, 1 из них не используется, 2 других используются для фрагментации. Don't fragment - запрет фрагментации, а флаг more fragments - пакет был фрагментирован и вслед за полученным пакетом должны прийти другие фрагменты.
Следующее поле - время жизни пакетов (64). То есть пакет может пройти через 64 маршрутизаторов, после чего он будет отброшен.
Следующее поле, контрольная сумма заголовка, которая используется для проверки правильности доставки пакета
Task:
Таблица маршрутизации:
Decision:
$ route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         192.168.0.1     0.0.0.0         UG    100    0        0 enp0s3
169.254.0.0     0.0.0.0         255.255.0.0     U     1000   0        0 enp0s3
192.168.0.0     0.0.0.0         255.255.255.0   U     100    0        0 enp0s3
Task:
Протокол DHCP - Сетевой уровень. Для dhcp пакетов в Wireshark используется фильтр bootp. Перед тем как получить адрес по протоколу dhcp нужно освободить тот, который у компьютера уже есть. для конкретного подключения, например Wi-Fi
Decision:
$ ifconfig
    enp0s3: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.0.105  netmask 255.255.255.0  broadcast 192.168.0.255
        inet6 fe80::3dd0:64cb:aebf:9381  prefixlen 64  scopeid 0x20<link>
        ether 08:00:27:3c:93:19  txqueuelen 1000  (Ethernet)
        RX packets 64638  bytes 68467891 (68.4 MB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 7319  bytes 620656 (620.6 KB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
    lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10<host>
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 397  bytes 32617 (32.6 KB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 397  bytes 32617 (32.6 KB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
$ sudo dhclient -r enp0s3
Task:
Адрес отдали, теперь хотим получить и посмотрим как проходило получения ip адреса по протоколу dhcp.
Decision:
$ sudo dhclient enp0s3
Нас интересует именно DCHP Discover, Offer, Request, Ack (DORA). Именно эти пакеты используются для назначения ip адреса.
Пакет Discover отправляет компьютер, когда хочет получить ip адрес. В это время у компьютера нет никаких сетевых адресов и сетевых настроек. ПОэтому сообщение dhcp dicover передается на широковещательный адрес ff:ff:...:ff на канальном уровне. Так как у компьютера, пока что нету собственного ip адреса, поэтому у адреса отправителя (src) нули 0.0.0.0, а в адресе получителя битовые единицы (dst) 255.255.255.255.
в Пакете Offer dhcp-server отправляет клиенту сообщение в ответ на запрос dhcp-Discovery. Так как ардеса никакого нету, сообщения также пересылаются по широковещательному адресу ff:ff:...:ff. Его принимают все компьютеры сети, но обрабатывает только тот кто выслал запрос.
Посмотрим данные протокoла dhcp.
самое важное здесь ip адрес, который нам предлагает dhcp-сервер (your client адрес) и идентификатор клиента (client mac address), который хочет получить ip адрес в протоколе dhcp. есть еще дополнительная информация, так называемая - options.
1ая опция - название операции (dhcp offer). нам предлагается маска (subnet). Маршрутизатор по умолчанию - (router). Сервера доменных имен, которые используются для преобразования dns имен в ip адреса. lease time - время, на которое выдается ip адресу. dhcp сервер выдал нам этот адрес на 1 день.
B следующем пакетe dhcp request запрос предложенному ip адрес клиенту. Он нужен так как в сети работают два dhcp сервера. В этом случае клиент выбирает ip адрес одного dhcp сервера и именно ему посылает dhcp request.
Опять же сообщения посылаются на канальном уровне на широковещательный mac адрес, так как сетевая адреса еще также нету. И в сообдщении dhcp клиент указывает адрес, который он запрашивает (reqeust ip address). также в сообщение клиент включает еще список опций, который он хочет получить от dhcp сервера (parametr request list).
B следующем пакетe dhcp ack сообщение dhcp сервер посылает клиенту и он подтверждает что клиент, может использовать данный ip адрес. На этом получеие ip адреса заканчивается.
Task:
Протокол ARP - Сетевой уровень. Результаты работы протокола ARP записываются в ARP-таблицу на компьютере. В wireshark мы используем фильтр по названию протоколa ARP, для того чтобы отобрать только нужные нам пакеты. Работа протокола протоколa ARP состоит из 2х операций - запрос и ответ.
Decision:
Здесь краткая информация мак-адрес отправителя (source) посылает на широковещательный мак-адрес пакет, в котором спрашивается у кого есть адрес 192.168.0.106 ответить компьютеру с адресом 192.168.0.1. Следующий пакет пакажет информацию с мак адресом о компьютера с адресом 192.168.0.106.
Рассмотрим как устроены пакеты протоколa ARP
В нижней части окна видим пакет в том виде, в котором передается по сети. В среднем окне ethernet II - заголовок канального уровня, destination - адрес получателя. Этот широковещательный адрес отправляется всем компьютера в сети, так как компьютеру отправителю извесетен только ip адрес, но не мак-адрес получаетля. source - мак-адрес отправителя, и type - код протокола следующего уровня. Затем идут поля даныых заголовка протокола ARP.
Данный разработан для того чтобы преобразовывать адрес различных технологий сетевого уровня в различные технологии канального уровня. Поэтому в начале строке идут поля, которые говорят о том адреса каких типов мы преобразуем. С hardware ethernet и типом протокола IPv4 мы пытаемся определить адрес. В ethernet указывается длина адресов HS-6  и PS-4. Затем идет тип операции reply - ответ, но есть еще request - запрос. Дальше указывыается мак-адрес, который мы хотим узнать - target mac-adress. Мак-адрес и искомый мак адрес находится в поле sendeer mac-adress. После того как компьютер запросил мак-адрес некоторого айпи адреса по протоколу ARP, он его записывает во внутренний кэш, который называется arp таблицей
$ arp -a
Выводится имеющуюся таблицу соответсвие ip и mac адреса. Можно добавить в ручную, в этом случае будет статический адрес, либо удалить.
$ arp -d 192.168.0.104
Task:
Протокол ICMP - Сетевой уровень. Если мы запустим wireshark и в фильтре введем icmp, увидим, что просто так сети пакета ничего не передается. Чтобы все таки посмотреть как данный протокол работает, буду использовать утлиту ping, котороый использует в своей работе именно этот протокол. Ping используется для проверки допступности компьютеров в сети
Decision:
$ ping 8.8.8.8
    PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data.
    64 bytes from 8.8.8.8: icmp_seq=1 ttl=108 time=79.0 ms
    64 bytes from 8.8.8.8: icmp_seq=2 ttl=108 time=78.4 ms
    64 bytes from 8.8.8.8: icmp_seq=3 ttl=108 time=74.2 ms
    64 bytes from 8.8.8.8: icmp_seq=4 ttl=108 time=73.7 ms
    64 bytes from 8.8.8.8: icmp_seq=5 ttl=108 time=74.2 ms
    ^C
    --- 8.8.8.8 ping statistics ---
    5 packets transmitted, 5 received, 0% packet loss, time 4033ms
    rtt min/avg/max/mdev = 73.740/75.916/79.018/2.300 ms
Видим, что сервер получил 5 пакетов, это значит что сервер доступен по сети. Смотрим как это реализовано в ICMP
В верхней части показан перечень всех пакетов, которые были переданы - request и получены - reply. В нижней части видим цифровое представление пакета. В средней части также протокол канального уровня ethernet, сетевого уровня IPv4 и протокол ICMP.
в ICMP type говорит о том что произошло в сети. в нашем случае код сообщения 8 с эхо (ping) запросом. После заголовка добавляются данные (Data), чтобы не передавать пустой пакет.
Попробуем  ввести команду ping c ограничением время жизни 1. Это означает, что, когда пакет дойдет до 1ого маршрутизатора, маршрутизатор уменьшит время жизни до 0, отбросит пакет и отправит нам сообщение о том,что время жизни пакета истекл.о:
    $ ping -i 1 8.8.8.8
А в wireshark вывдется такая информация:
    Time-to-live exceeded.
Тип сообщения будет 11 с кодом 0.
Task:
Рассмотрим утилиту tracеroute для определения маршрута от отправителя к получателю. Установим маршрут до сайта:
Decision:
$ sudo traceroute -d google.com
    traceroute to google.com (74.125.131.138), 30 hops max, 60 byte packets
     1  _gateway (192.168.0.1)  1.086 ms  1.155 ms  1.049 ms
     2  * * *
     3  dynamicip-109-194-24-39.pppoe.penza.ertelecom.ru (109.194.24.39)  2.276 ms  2.038 ms  3.363 ms
     4  net131.234.188-158.ertelecom.ru (188.234.131.158)  71.095 ms  70.891 ms  70.740 ms
     5  net131.234.188-159.ertelecom.ru (188.234.131.159)  71.626 ms 72.14.214.138 (72.14.214.138)  71.519 ms net131.234.188-159.ertelecom.ru (188.234.131.159)  71.458 ms
     6  10.252.225.62 (10.252.225.62)  71.396 ms 10.23.205.254 (10.23.205.254)  73.098 ms 10.252.175.126 (10.252.175.126)  72.994 ms
     7  74.125.244.129 (74.125.244.129)  72.939 ms 209.85.240.254 (209.85.240.254)  72.780 ms  72.348 ms
     8  74.125.244.133 (74.125.244.133)  73.347 ms  88.624 ms 74.125.244.180 (74.125.244.180)  70.965 ms
     9  72.14.232.85 (72.14.232.85)  72.030 ms 142.251.51.187 (142.251.51.187)  73.705 ms 72.14.232.84 (72.14.232.84)  70.664 ms
    10  142.251.61.221 (142.251.61.221)  74.866 ms 216.239.58.67 (216.239.58.67)  75.103 ms 216.239.48.163 (216.239.48.163)  74.589 ms
    11  172.253.64.55 (172.253.64.55)  75.463 ms 172.253.64.53 (172.253.64.53)  75.309 ms 216.239.56.113 (216.239.56.113)  75.929 ms
    12  * * *
    13  * * *
    14  * * *
    15  * * *
    16  * * *
    17  * * lu-in-f138.1e100.net (74.125.131.138)  73.826 ms
Task:
Для того чтобы попасть на сайт google нам нужно пройти через 11 промежуточных маршрутизаторов. Посмотрим как tracerout распознает адреса этих маршрутизаторов в wireshark.
Decision:
Тег сообщения - 11, код - 0, время жизни пакета истекло. tracerout смотрит заголовок IPv4 и извлекает из него адрес отправителя - source. Это и есть адрес первого маршрутизатора, через который нужно пройти.
Task:
На канальном уровне работает ethernet и wifi.
Decision:
Заголовок канального уровня wireshark содержит адрес получателя (destintation, указан мак адрес компьютера получателя), адрес отправителя (source), тип протокола следующего уровня (type)
Task:
Рассмотрим пакеты протола arp
Decision:
1. Адрес состоящий из битовых единиц или шестнадцатеричном виде ff 6 раз это широковещательный адрес. При отправки данных на него эти данные получают все компьютеры в сеть.
2. В сети ethernet есть ограничения на максимальный размер кадра - 46 байт. Это ограничения унаследованно из ethernet, в котором необходимо было, чтобы сигнал колизии дашел до самого дальнего конца сети. Поэтому кадр должен быть достаточно большой. И есил размер пакета маленький (arp), то он в конце дополняется нулями (padding).
3. Есть несколько форматов заголовка канального уровня. Если мы посмотрим форматы кадров технологии Ethernet после полей физического уровня (поле преамбулы, начальный ограничитель) идут следующие поля заголовка адрес получателя, отправителя и вместо тип протокола содержит длину данных в кадре. Это Стандарт 802.3 и он не единственный. А производители использовали индустриальный стандарт ethernet II (Ethernet DIX)
Task:
Протокол NDP Протокол обнаружения соседей - расширение протокола icmp, поэтому в wireshark мы используем фильтр icmpv6.
Decision:
Видим пакет router advertisemen - пакет маршрутизатора, который находится в сети, рассылает постоянно через определенные промежутки времени.
На уровне IP адрес отправителя - source (ipv6 адрес маршрутизатора) и адрес получателя - destination. destination - групповой адрес, с которым соответсвуют все устройства в сети. Тип заголовка следующего уровня (Next Header) - 58, протокол icmpv6, его модификация версия 6. В пакете icmpv6^
Тип сообщения - 134, router advertisement - анонс маршрутизатором. Адрес маршрутизатора извлекается из заголовка ipv6, а в icmp находятся рекомендуемый максимального количества промежуточных участков (Cur hop limit) - 64, то есть пакет может пройти через 64 маршрутизатор прежде чем он будет отброшен. Время жизни маршрутизатора (router lifetime) - то время, на которое запись об этом маршрутизаторе заносится в таблицу маршрутизации. Важная имнформация - опции icmpv6 (icmpv6 option), source link-layer address - мак адрес маршрутизатора. В IPv6 мак адрес маршрутизатора разделен на 2 части, внутрь добавлены значения - ff:fe. после них правая часть ip адреса (ipv6) полностью совпадают с правой часть в макадресе (ethernet II). А в левой части изменены биты.
Протокол NDP используется для автоматической конфигурации сетевых настроек компьютера. Из сообщения router advertisement мы получаем ipv6 адрес маршрутизатора.
В канального уровне (ethernet II) используется групповой макадрес, в отличии от ipv6 где использовался широковещательный мак адрес из одниз бинарных единиц. Групповые макадрес, которые соответсвуют групповым ipv6 устроены следущюим образом. В начале идут 2 числа - 33:33, а затем 4 числа, которые совпадают в групповом ipv6 (dst), здесь все 0, последняя - 1, таже и в ipv6, пустые значения и послендяя 1.
Определим Мак адреса компьютеров в сети по адресам ipv6 другим способом. Комп версии ipv6 когда хочет узнать макадрес получателя, по его ардесу ipv6, отправляет запрос соседа (neighbor solicitation) с типом соообщения 135.
Ответ от соседа neighbor advertisement с типом соообщения 136. Целевой адрес соседа target address соответсвует ему мак адрес icmpv6 option. В ipv6 (src) отпралвет тот адрес, которого мы хотели узнать mac адрес (target address), напрямую нашему компьютеру (dst).
Проткол NDP, как и ARP, хранит определенные мак адрес в кэш, в таблице ndp.
$ ip -6 neighbor show
    fe80::b295:75ff:fe76:ef70 dev enp0s3 lladdr b0:95:75:76:ef:70 router STALE
Task:
Анализатор сети Wireshark
Decision:
Запуск анализатора, выбираем один из списка подключенных сетевых интерфейсов:
В верхней части показаны пакеты, которые приходят из сети. Именно в этой части можно увидеть какие пакеты приходят и уходят из нашей сети.
В нижней части представлены пакеты в том виде, в котором они передаются по сети (набор 16-ричных чисел - цифровые сети).
Среднее окно позволяет нам понять, что означают те цифры в пакете. Тут прдставлены заголовки разного уровня - frame, физический уровень - ethernet II, протокол сетевого уровня IPv6.
Выберем, какой-нибудь протокол, то его заголовок в нижней части высвечивается, и в нем увидим описание всех полей в заголовке протокола. Наример, в пакете можно увидеть ip адрес отправителя (source address) и ip адрес получателя (destination)
Чтобы посмотреть как проходит захват пакетов, сначала запустим wireshark и после какую-нибудь веб страницу. Чтобы быстро найти нужый нам пакет мы используем фильтр и напишем в нем http. Увидим GET - запрос, http - ответ. и, например, в средней части если откроем протокол Line-based text data мы увидим как раз данные той самой веб страницы.
Source:
https://www.asozykin.ru/courses/networks_online