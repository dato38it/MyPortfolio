Mail for feedback: David138it@gmail.com

Python, Планировщик задач
	Task:
	Планирование и автоматический запуск сценариев по времени
	Decision:
	$ python3 -m venv Py-SchedulingAndAutorunScriptsByTime
	$ source Py-SchedulingAndAutorunScriptsByTime/bin/activate
	$ pip list
	Package       Version
	------------- -------
	pip           20.0.2
	pkg-resources 0.0.0
	setuptools    44.0.0
	$ pip install schedule requests
	$ pip list
	Package            Version
	------------------ ---------
	certifi            2022.6.15
	charset-normalizer 2.1.0
	idna               3.3
	pip                20.0.2
	pkg-resources      0.0.0
	requests           2.28.1
	schedule           1.1.0
	setuptools         44.0.0
	urllib3            1.26.10
	$ vim Py-SchedulingAndAutorunScriptsByTime.py
	$ python Py-SchedulingAndAutorunScriptsByTime.py
	day's tasks
	08:00-Drink coffee
	11:00-Work meeting
	23:59-Hack the Planet!
	$ cat Py-SchedulingAndAutorunS
	criptsByTime.py
	import schedule
	import requests
	def greeting():
	    todos_dict={
	        '08:00':'Drink coffee',
	        '11:00':'Work meeting',
	        '23:59':'Hack the Planet!'
	    }
	    print("day's tasks")
	    for k, v in todos_dict.items():
	        print(f'{k}-{v}')
	def main():
	    greeting()
	if __name__=='__main__':
	    main()
	Decision:
	$ vim Py-SchedulingAndAutorunScriptsByTime.py
	$ python Py-SchedulingAndAutorunScriptsByTime.py
	day's tasks
	08:00-Drink coffee
	11:00-Work meeting
	23:59-Hack the Planet!
	{'btc_usd': {'high': 24399.99999999, 'low': 22401.00005001, 'avg': 23400.500025, 'vol': 45134.35781963, 'vol_cur': 1.92382651, 'last': 23953.00002, 'buy': 23958.50007, 'sell': 24195.2, 'updated': 1658287860}}
	$ cat Py-SchedulingAndAutorunScriptsByTime.py
	import schedule
	import requests
	def greeting():
	    todos_dict={
	        '08:00':'Drink coffee',
	        '11:00':'Work meeting',
	        '23:59':'Hack the Planet!'
	    }
	    print("day's tasks")
	    for k, v in todos_dict.items():
	        print(f'{k}-{v}')
	    response = requests.get(url='https://yobit.net/api/3/ticker/btc_usd')
	    data = response.json()
	    print(data)
	def main():
	    greeting()
	if __name__=='__main__':
	    main()
	Decision:
	$ vim Py-SchedulingAndAutorunScriptsByTime.py
	$ python Py-SchedulingAndAutorunScriptsByTime.py
	day's tasks
	08:00-Drink coffee
	11:00-Work meeting
	23:59-Hack the Planet!
	23953.00002
	$ cat Py-SchedulingAndAutorunScriptsByTime.py
	import schedule
	import requests
	def greeting():
	    todos_dict={
	        '08:00':'Drink coffee',
	        '11:00':'Work meeting',
	        '23:59':'Hack the Planet!'
	    }
	    print("day's tasks")
	    for k, v in todos_dict.items():
	        print(f'{k}-{v}')
	    response = requests.get(url='https://yobit.net/api/3/ticker/btc_usd')
	    data = response.json()
	    #print(data)
	    btc_price = data.get('btc_usd').get('last')
	    print(btc_price)
	def main():
	    greeting()
	if __name__=='__main__':
	    main()
	Decision:
	$ vim Py-SchedulingAndAutorunScriptsByTime.py
	$ python Py-SchedulingAndAutorunScriptsByTime.py
	day's tasks
	08:00-Drink coffee
	11:00-Work meeting
	23:59-Hack the Planet!
	BTC: 23953.0$
	$ cat Py-SchedulingAndAutorunScriptsByTime.py
	import schedule
	import requests
	def greeting():
	    todos_dict={
	        '08:00':'Drink coffee',
	        '11:00':'Work meeting',
	        '23:59':'Hack the Planet!'
	    }
	    print("day's tasks")
	    for k, v in todos_dict.items():
	        print(f'{k}-{v}')
	    response = requests.get(url='https://yobit.net/api/3/ticker/btc_usd')
	    data = response.json()
	    #print(data)
	    #btc_price = data.get('btc_usd').get('last')
	    btc_price = f"BTC: {round(data.get('btc_usd').get('last'), 2)}$\n"
	    print(btc_price)
	def main():
	    greeting()
	if __name__=='__main__':
	    main()
	Decision:
	$ vim Py-SchedulingAndAutorunScriptsByTime.py
	$ python Py-SchedulingAndAutorunScriptsByTime.py
	day's tasks
	08:00-Drink coffee
	11:00-Work meeting
	23:59-Hack the Planet!
	BTC: 23953.0$
	day's tasks
	08:00-Drink coffee
	11:00-Work meeting
	23:59-Hack the Planet!
	BTC: 23953.0$
	day's tasks
	08:00-Drink coffee
	11:00-Work meeting
	23:59-Hack the Planet!
	BTC: 23953.0$
	^CTraceback (most recent call last):
	  File "Py-SchedulingAndAutorunScriptsByTime.py", line 24, in <module>
	    main()
	  File "Py-SchedulingAndAutorunScriptsByTime.py", line 22, in main
	    schedule.run_pending()
	  File "/mnt/c/Users/david/Documents/MySkills/Py-Lessons/Py-SchedulingAndAutorunScriptsByTime/lib/python3.8/site-packages/schedule/__init__.py", line 780, in run_pending
	    default_scheduler.run_pending()
	  File "/mnt/c/Users/david/Documents/MySkills/Py-Lessons/Py-SchedulingAndAutorunScriptsByTime/lib/python3.8/site-packages/schedule/__init__.py", line 99, in run_pending
	    for job in sorted(runnable_jobs):
	  File "/mnt/c/Users/david/Documents/MySkills/Py-Lessons/Py-SchedulingAndAutorunScriptsByTime/lib/python3.8/site-packages/schedule/__init__.py", line 98, in <genexpr>
	    runnable_jobs = (job for job in self.jobs if job.should_run)
	  File "/mnt/c/Users/david/Documents/MySkills/Py-Lessons/Py-SchedulingAndAutorunScriptsByTime/lib/python3.8/site-packages/schedule/__init__.py", line 636, in should_run
	    @property
	KeyboardInterrupt
	$ cat Py-SchedulingAndAutorunScriptsByTime.py
	import schedule
	import requests
	def greeting():
	    todos_dict={
	        '08:00':'Drink coffee',
	        '11:00':'Work meeting',
	        '23:59':'Hack the Planet!'
	    }
	    print("day's tasks")
	    for k, v in todos_dict.items():
	        print(f'{k}-{v}')
	    response = requests.get(url='https://yobit.net/api/3/ticker/btc_usd')
	    data = response.json()
	    #print(data)
	    #btc_price = data.get('btc_usd').get('last')
	    btc_price = f"BTC: {round(data.get('btc_usd').get('last'), 2)}$\n"
	    print(btc_price)
	def main():
	    #greeting()
	    schedule.every(4).seconds.do(greeting)
	    while True:
	        schedule.run_pending()
	if __name__=='__main__':
	    main()
	Decision:
	$ cat Py-SchedulingAndAutorunScriptsByTime.py
	import schedule
	import requests
	def greeting():
	    todos_dict={
	        '08:00':'Drink coffee',
	        '11:00':'Work meeting',
	        '23:59':'Hack the Planet!'
	    }
	    print("day's tasks")
	    for k, v in todos_dict.items():
	        print(f'{k}-{v}')
	    response = requests.get(url='https://yobit.net/api/3/ticker/btc_usd')
	    data = response.json()
	    #print(data)
	    #btc_price = data.get('btc_usd').get('last')
	    btc_price = f"BTC: {round(data.get('btc_usd').get('last'), 2)}$\n"
	    print(btc_price)
	def main():
	    #greeting()
	    '''schedule.every(4).seconds.do(greeting)
	    schedule.every(5).minutes.do(greeting)
	    schedule.every().hour.do(greeting)'''
	    schedule.every().day.at('12:00').do(greeting)
	    schedule.every().thursday.do(greeting)
	    schedule.every().friday.at('23:45').do(greeting)
	    while True:
	        schedule.run_pending()
	if __name__=='__main__':
	    main()
	$ deactivate

Python, Локально-вычислительные сети
	Task:
	Реализовать простой http-прокси-сервер, запускаемый локально (порт на ваше усмотрение), который показывает содержимое страниц Хабра. Прокси должен модицифировать текст на страницах следующим образом: после каждого слова из шести букв должен стоять значок «». Пример:
	Исходный текст: http://habrahabr.ru/company/yandex/blog/258673/
	Сейчас на фоне уязвимости Logjam все в индустрии в очередной раз обсуждают проблемы и особенности TLS. Я хочу воспользоваться этой возможностью, чтобы  поговорить об одной из них, а именно — о настройке ciphersiutes.
	Через ваш прокси: http://127.0.0.1:8232/company/yandex/blog/258673/
	Сейчас на фоне уязвимости Logjam все в индустрии в очередной раз обсуждают проблемы и особенности TLS. Я хочу воспользоваться этой возможностью, чтобы поговорить об одной из них, а именно — о настройке ciphersiutes. 
	Условия:
	1. Python 3.5+ страницы должны отображаться и работать полностью корректно, в точности так, как и оригинальные (за исключением модифицированного текста);
	2. при навигации по ссылкам, которые ведут на другие страницы хабра, браузер должен оставаться на адресе вашего прокси;
	3. можно использовать любые общедоступные библиотеки, которые сочтёте нужным;
	4. чем меньше кода, тем лучше. PEP8 — обязательно;
	5. если в условиях вам не хватает каких-то данных, опирайтесь на здравый смысл.
	Если задачу удалось сделать быстро, и у вас еще остался энтузиазм - как насчет написания тестов?
	Присылайте ваше решение в виде ссылки на gist или на публичный репозиторий на Github.
	Task:
	Как определить местоположение с помощью IIP
	Decision:
	$ python3 -m venv Py-HowToDetermineTheLocationByIp
	$ source Py-HowToDetermineTheLocationByIp/bin/activate
	$ pip install requests pyfiglet
	$ vim Py-HowToDetermineTheLocationByIp.py
	$ python Py-HowToDetermineTheLocationByIp.py
	Please enter a target IP: 222.12.154.103
	{'status': 'success', 'country': 'Japan', 'countryCode': 'JP', 'region': '27', 'regionName': 'Ōsaka', 'city': 'Osaka', 'zip': '540-0002', 'lat': 34.6937, 'lon': 135.502, 'timezone': 'Asia/Tokyo', 'isp': 'Kddi Corporation', 'org': 'DION (KDDI CORPORATION)', 'as': 'AS2516 KDDI CORPORATION', 'query': '222.12.154.103'}
	$ cat Py-HowToDetermineTheLocationByIp.py
	import requests
	def get_info_by_ip(ip='127.0.0.1'):
	    try:
	        response = requests.get(url=f'http://ip-api.com/json/{ip}').json()
	        print(response)
	    except requests.exceptions.ConnectionError:
	        print('[!] Please check your connection!')
	def main():
	    ip = input('Please enter a target IP: ')
	    get_info_by_ip(ip=ip)
	if __name__ == '__main__':
	    main()
	Decision:
	$ vim Py-HowToDetermineTheLocationByIp.py
	$ python Py-HowToDetermineTheLocationByIp.py
	    ________     _____   ____________
	   /  _/ __ \   /  _/ | / / ____/ __ \
	   / // /_/ /   / //  |/ / /_  / / / /
	 _/ // ____/  _/ // /|  / __/ / /_/ /
	/___/_/      /___/_/ |_/_/    \____/
	Please enter a target IP: 222.12.154.103
	[IP] : 222.12.154.103
	[Int prov] : Kddi Corporation
	[Org] : DION (KDDI CORPORATION)
	[Country] : Japan
	[Region Name] : Ōsaka
	[City] : Osaka
	[ZIP] : 540-0002
	[Lat] : 34.6937
	[Lon] : 135.502
	$ cat Py-HowToDetermineTheLocationByIp.py
	import requests
	from pyfiglet import Figlet
	def get_info_by_ip(ip='127.0.0.1'):
	    try:
	        response = requests.get(url=f'http://ip-api.com/json/{ip}').json()
	        #print(response)
	        data = {
	            '[IP]': response.get('query'),
	            '[Int prov]': response.get('isp'),
	            '[Org]': response.get('org'),
	            '[Country]': response.get('country'),
	            '[Region Name]': response.get('regionName'),
	            '[City]': response.get('city'),
	            '[ZIP]': response.get('zip'),
	            '[Lat]': response.get('lat'),
	            '[Lon]': response.get('lon'),
	        }
	        for k, v in data.items():
	            print(f'{k} : {v}')
	    except requests.exceptions.ConnectionError:
	        print('[!] Please check your connection!')
	def main():
	    preview_text = Figlet(font='slant')
	    print(preview_text.renderText('IP INFO'))
	    ip = input('Please enter a target IP: ')
	    get_info_by_ip(ip=ip)
	if __name__ == '__main__':
	    main()
	Decision:
	$ pip install folium
	$ vim Py-HowToDetermineTheLocationByIp.py
	$ python Py-HowToDetermineTheLocationByIp.py
	    ________     _____   ____________
	   /  _/ __ \   /  _/ | / / ____/ __ \
	   / // /_/ /   / //  |/ / /_  / / / /
	 _/ // ____/  _/ // /|  / __/ / /_/ /
	/___/_/      /___/_/ |_/_/    \____/
	Please enter a target IP: 222.12.154.103
	[IP] : 222.12.154.103
	[Int prov] : Kddi Corporation
	[Org] : DION (KDDI CORPORATION)
	[Country] : Japan
	[Region Name] : Ōsaka
	[City] : Osaka
	[ZIP] : 540-0002
	[Lat] : 34.6937
	[Lon] : 135.502
	$ ls 222.12.154.103_Osaka.html
	222.12.154.103_Osaka.html
	$ cat Py-HowToDetermineTheLocationByIp.py
	import requests
	from pyfiglet import Figlet
	import folium
	def get_info_by_ip(ip='127.0.0.1'):
	    try:
	        response = requests.get(url=f'http://ip-api.com/json/{ip}').json()
	        #print(response)
	        data = {
	            '[IP]': response.get('query'),
	            '[Int prov]': response.get('isp'),
	            '[Org]': response.get('org'),
	            '[Country]': response.get('country'),
	            '[Region Name]': response.get('regionName'),
	            '[City]': response.get('city'),
	            '[ZIP]': response.get('zip'),
	            '[Lat]': response.get('lat'),
	            '[Lon]': response.get('lon'),
	        }
	        for k, v in data.items():
	            print(f'{k} : {v}')
	        area = folium.Map(location=[response.get('lat'), response.get('lon')])
	        area.save(f'{response.get("query")}_{response.get("city")}.html')
	    except requests.exceptions.ConnectionError:
	        print('[!] Please check your connection!')
	def main():
	    preview_text = Figlet(font='slant')
	    print(preview_text.renderText('IP INFO'))
	    ip = input('Please enter a target IP: ')
	    get_info_by_ip(ip=ip)
	if __name__ == '__main__':
	    main()
	$ deactivate

Data Engineer Python, медицинская клиника
	Task:
	Результаты анализов приходят в зашифрованном виде в файле medicine.xlsx. На сервере лежат таблицы de.med_an_name, de.med_name для расшифровки показаний. В ответе приложите два файла - скрипт python и результат работы (xlsx).
	Легкий режим: Вы забираете данные с листа 'easy'. Нужно отыскать пациентов, у которых не в норме хотя бы один анализ. Вывести телефон, имя, название анализа и заключение 'Повышен' или 'Понижен'. Сохранить в xlsx.
	Сложный режим: Вы забираете данные с листа 'hard'. Нужно отыскать пациентов, у которых не в норме два и более анализов. Вывести телефон, имя, название анализа и заключение 'Повышен', 'Понижен' или 'Положительный'. Сохранить в xlsx.
	Дополнительно сохраните таблицу с расшифрованными значениями и результатами анализа в таблице xxxx_med_results в базе данных (помните про 4 буквы в начале, идентифицирующие вашу таблицу).
	Decision:
	$ cat Py-Medicine.py
	import pandas as pd
	import psycopg2
	conn = psycopg2.connect(database = "database",
	    host = "host.ru",
	    user = "de13ma",
	    password = "meriadocbrandybuck",
	    port = "5432")
	conn.autocommit = False
	cursor = conn.cursor()
	sel = input('Please select the mode (e/h/q): ') 
	while (sel.lower() != "e" or sel.lower() != "h" or sel.lower() != "q"): 
	    if sel.lower() == "e": 
	        # Чтение из файла
	        df = pd.read_excel( 'medicine.xlsx', sheet_name='easy', header=0, index_col=None )
	        print( df )
	        cursor.execute("CREATE TABLE de13ma.gabn_med_easy (patient_code int, analysis varchar, value numeric);")
	        # Выполнение SQL кода вставки в базу данных
	        cursor.executemany( """INSERT INTO de13ma.gabn_med_easy (patient_code, analysis, value)
	            VALUES (%s, %s, %s)""", df.values.tolist() )
	        # Выполнение SQL кода в базе данных с возвратом результата
	        #cursor.execute( "SELECT * FROM de.med_an_name" )
	        #cursor.execute( "SELECT * FROM de.med_name" )
	        cursor.execute("""CREATE TABLE de13ma.gabn_med_easy1 AS (
	            SELECT 
	                * 
	            FROM (
	                SELECT 
	                        --*
	                        dmn.phone,
	                        dmn.name,
	                        dma.name AS analysis,  
	                        (CASE 
	                                WHEN dmt.value<dma.min_value 
	                                        THEN 'Понижен'
	                                WHEN dmt.value>dma.max_value 
	                                        THEN 'Повышен'
	                        --ELSE
	                          --'Это нормально'
	                        END) AS results--,
	                        --dmt.value,
	                        --dma.min_value,
	                        --dma.max_value 
	                FROM de13ma.gabn_med_easy AS dmt
	                LEFT JOIN de.med_name AS dmn
	                        ON dmt.patient_code = dmn.id
	                LEFT JOIN de.med_an_name AS dma
	                        ON dmt.analysis = dma.id
	                ) AS temp_result
	                WHERE results IS NOT null);""")
	        conn.commit()
	        cursor.execute("SELECT * from de13ma.gabn_med_easy1;")
	        records = cursor.fetchall()
	        for row in records:
	            print( row )
	        # Формирование DataFrame
	        names = [ x[0] for x in cursor.description ]
	        df = pd.DataFrame( records, columns = names )
	        df
	        print( df )
	        # Запись в файл
	        df.to_excel( 'gabn_med_res_e.xlsx', sheet_name='easy', header=True, index=False )
	        break; 
	    elif sel.lower() == "h": 
	        df = pd.read_excel( 'medicine.xlsx', sheet_name='hard', header=0, index_col=None )
	        print( df )
	        cursor.execute("CREATE TABLE de13ma.gabn_med_hard (patient_code int, analysis varchar, value varchar);")
	        cursor.executemany( """INSERT INTO de13ma.gabn_med_hard (patient_code, analysis, value)
	            VALUES (%s, %s, %s)""", df.values.tolist() )
	        cursor.execute("""create table de13ma.gabn_med_hard1 as (
		    with t2 as (
		        select 
			    name,
			    count(*) as cnt 
			from (
			    select 
				--*,
				mn.phone,
				mn.name,
				man.name AS analysis,
				(case 
			            when 
				        lower(gmh.value) = 'положит.' 
					or lower(gmh.value) = 'положительно' 
					or lower(gmh.value) = '+' 
				    then 
				        'Положительный'
				    when 
					lower(gmh.value) = 'отриц.'
					or lower(gmh.value) = '-' 
					or lower(gmh.value) = 'отр' 
				    then 
					'Отрицательный'
				    when 
					cast(gmh.value as numeric) > cast(man.max_value as numeric)
				    then 
					'Повышен' 
				    when 
					cast(gmh.value as numeric) < cast(man.min_value as numeric)
				    then 
					'Понижен'
				    when 
				    	cast(gmh.value as numeric) >= cast(man.min_value as numeric)  
					and cast(gmh.value as numeric) <= cast(man.max_value as numeric)  
				    then 
					'Это нормально'
	                        else 
				    'Не определено'  
				end) as results--,		
				--gmh.value,
				--man.min_value,
				--man.max_value
				from de13ma.gabn_med_hard as gmh
				left join de.med_name as mn
				    on gmh.patient_code = mn.id
				left join de.med_an_name as man
				    on gmh.analysis = man.id
				where 
				    (case 
				        when 
					    lower(gmh.value) = 'положит.' 
					    or lower(gmh.value) = 'положительно' 
					    or lower(gmh.value) = '+' 
					then 
					    'Положительный'
					when 
					    lower(gmh.value) = 'отриц.'
					    or lower(gmh.value) = '-' 
					    or lower(gmh.value) = 'отр' 
					then 
					    'Отрицательный'
					when 
					    cast(gmh.value as numeric) > cast(man.max_value as numeric)
					then 
					    'Повышен' 
					when 
					    cast(gmh.value as numeric) < cast(man.min_value as numeric)
					then 
					    'Понижен'
					when 
					    cast(gmh.value as numeric) >= cast(man.min_value as numeric)  
					    and cast(gmh.value as numeric) <= cast(man.max_value as numeric)  
					then 
					    'Это нормально'
				    else 
					'Не определено'  
				    end) in ('Положительный', 'Повышен' ,'Понижен')) as t1
			        group by name
			        having count(*) > 1)
		            select 
			        * 
		            from (
			        select 
				    --*,
				    mn.phone,
				    mn.name,
				    man.name AS analysis,
				    (case 
					when 
					    lower(gmh.value) = 'положит.' 
					    or lower(gmh.value) = 'положительно' 
					    or lower(gmh.value) = '+' 
					then 
					    'Положительный'
					when 
					    lower(gmh.value) = 'отриц.'
					    or lower(gmh.value) = '-' 
					    or lower(gmh.value) = 'отр' 
					then 
					    'Отрицательный'
					when 
					    cast(gmh.value as numeric) > cast(man.max_value as numeric)
					then 
					    'Повышен' 
					when 
					    cast(gmh.value as numeric) < cast(man.min_value as numeric)
					then 
					    'Понижен'
					when 
					    cast(gmh.value as numeric) >= cast(man.min_value as numeric)  
					    and cast(gmh.value as numeric) <= cast(man.max_value as numeric)  
					then 
					    'Это нормально'
				    else 
					'Не определено'  
				    end) as results--,		
				    --gmh.value,
				    --man.min_value,
				    --man.max_value
			            from de13ma.gabn_med_hard as gmh
			            left join de.med_name as mn
				        on gmh.patient_code = mn.id
			            left join de.med_an_name as man
				        on gmh.analysis = man.id
			            where 
				        (case 
					    when 
					        lower(gmh.value) = 'положит.' 
						or lower(gmh.value) = 'положительно' 
						or lower(gmh.value) = '+' 
					    then 
						'Положительный'
					    when 
						lower(gmh.value) = 'отриц.'
						or lower(gmh.value) = '-' 
						or lower(gmh.value) = 'отр' 
					    then 
						'Отрицательный'
					    when 
						cast(gmh.value as numeric) > cast(man.max_value as numeric)
					    then 
						'Повышен' 
					    when 
						cast(gmh.value as numeric) < cast(man.min_value as numeric)
					    then 
						'Понижен'
					    when 
						cast(gmh.value as numeric) >= cast(man.min_value as numeric)  
						and cast(gmh.value as numeric) <= cast(man.max_value as numeric)  
					    then 
						'Это нормально'
				        else 
					    'Не определено'  
				        end) in ('Положительный', 'Повышен' ,'Понижен')) as t1
		                where name in (
			            select 
				        name 
			            from t2)
		                order by name, results);""")
	        conn.commit()
	        cursor.execute("SELECT * from de13ma.gabn_med_hard1;")
	        records = cursor.fetchall()
	        for row in records:
	            print( row )
	        # Формирование DataFrame
	        names = [ x[0] for x in cursor.description ]
	        df = pd.DataFrame( records, columns = names )
	        df
	        print( df )
	        # Запись в файл
	        df.to_excel( 'gabn_med_res_h.xlsx', sheet_name='easy', header=True, index=False )
	        break; 
	    elif sel.lower() == "q":
	        break;
	    else: 
	        sel = input('Please select the mode (e/h/q): ')
	# Закрываем соединение
	cursor.close()
	conn.close()

Python Django, Функционал "Сохраненных поисков" для DjangoQL
	Task:
	разработать функционал "Сохраненных поисков" для библиотеки DjangoQL. Обуждение здесь (на английском): https://github.com/ivelum/djangoql/issues/1
	Присылайте ваше решение в виде ссылки на форк проекта.

Python, Code Review
	Task:
	На обработку поступает последовательность из 8 целых чисел. Известно, что вводимые числа по абсолютной величине не превышают 10^12. Нужно написать программу, которая выводит на экран количество делящихся нацело на 4 чисел в исходной последовательности и максимальное делящееся нацело на 4 число. Если делящихся нацело на 4 чисел нет, требуется на экран вывести «NO». Программист торопился и написал программу неправильно.
	Найдите все ошибки в этой программе (их может быть одна или несколько). Известно, что каждая ошибка затрагивает только одну строку и может быть исправлена без изменения других строк.
	Decision:
	n = 8 # n = 7, по условию чисел 8
	count = 0
	maximum = -10**6 - 1 # maximum = 1000, все случаи, когда все числа меньше 1000, обрабатываются неверно
	for i in range(1, n + 1):
	    x = int(input())
	    if x % 4 == 0: # x // 4 == 0, по условию нужно найти числа, дел. на 4 без остатка
	        count += 1
	        if x > maximum: # if x < maximum, если число больше максимума, оно его заменяет, не если меньше максимума
	            maximum = x
	if count > 0:
	    print(count)
	    print(maximum)
	else:
	    print('NO')
	Task:
	На обработку поступает последовательность из 4 целых чисел. Известно, что вводимые числа по абсолютной величине не превышают 10^8. Нужно написать программу, которая выводит на экран количество нечётных чисел в исходной последовательности и максимальное нечётное число. Если нечётных чисел нет, требуется на экран вывести «NO». Программист торопился и написал программу неправильно.
	Найдите все ошибки в этой программе (их может быть одна или несколько). Известно, что каждая ошибка затрагивает только одну строку и может быть исправлена без изменения других строк.
	Decision:
	#n = 4
	count = 0
	maximum = -1
	for i in range(4):
	    x = int(input())
	    if x % 2 != 0:
	        count += 1
	        if x > maximum:
	            maximum = x
	            #break
	if count > 0:
	    print(count)
	    print(maximum)
	else:
	    print('NO')

Python, Color Mixer
	Task:
	Красный, синий и желтый называются основными цветами, потому что их нельзя получить путем смешения других цветов. При смешивании двух основных цветов получается вторичный цвет:
	    если смешать красный и синий, то получится фиолетовый;
	    если смешать красный и желтый, то получится оранжевый;
	    если смешать синий и желтый, то получится зеленый.
	Напишите программу, которая считывает названия двух основных цветов для смешивания. Если пользователь вводит что-нибудь помимо названий «красный», «синий» или «желтый», то программа должна вывести сообщение об ошибке. В противном случае программа должна вывести название вторичного цвета, который получится в результате.
	Decision:
	color1, color2 = input(), input()
	if color1 == 'красный' and color2 == 'синий' or (color1 == 'синий' and color2 == 'красный'):
	    print('фиолетовый')
	elif color1 == 'желтый' and color2 == 'синий' or (color1 == 'синий' and color2 == 'желтый'):
	    print('зеленый')
	elif color1 == 'красный' and color2 == 'желтый' or (color1 == 'желтый' and color2 == 'красный'):
	    print('оранжевый')
	elif color1 == 'красный' and color2 == 'красный' or color1 == 'желтый' and color2 == 'желтый' or color1 == 'синий' and color2 == 'синий':
	    print(color1)
	else:
	    print('ошибка цвета')

Python, Игры
	Task:
	Pin Ball
	Decision:
	#1) создать поле
	from tkinter import *#1
	import random #44) Содаем отскок
	WIDTH=900#2 настройки окна глоб переменная
	HEIGHT=300#3 настройки окна глоб переменная
	PAD_W=10#ракетка
	PAD_H=100#ракетка
	BALL_RADIUS=40#мяч
	#15) двигаем мяч
	BALL_X_CHANCGE=20#16 переменная для скорости мяча, горизонтально и вертикально
	BALL_Y_CHANCGE=0#16
	root=Tk()#7
	root.title("Ping-pong")#8
	c=Canvas(root,
	         width=WIDTH,
	         height=HEIGHT,
	         background="#008B8B")#9 создаем область, в котором все это делается
	c.pack()#10 ставим наш канвас
	c.create_line(PAD_W,
	              0,
	              PAD_W,
	              HEIGHT,
	              fill="white")#11 Сделаем левую и правую ракетку на поле, мяч и линию, он будет касаться
	c.create_line(WIDTH-PAD_W,
	              0,
	              WIDTH-PAD_W,
	              HEIGHT,
	              fill="white")#11 Вычитаем, потому что с обратной стороны, для правой ракетки
	c.create_line(WIDTH/2,
	              0,
	              WIDTH/2,
	              HEIGHT,
	              fill="white")#12 сделаем линию, которая разделяет игровое поле
	BALL=c.create_oval(WIDTH/2-BALL_RADIUS/2,
	                   HEIGHT/2-BALL_RADIUS/2,
	                   WIDTH/2+BALL_RADIUS/2,
	                   HEIGHT/2+BALL_RADIUS/2, fill="#FF4500")#13 создаем мяч
	LEFT_PAD=c.create_line(PAD_W/2,
	                       0,
	                       PAD_W/2,
	                       PAD_H,
	                       width=PAD_W,
	                       fill="#DA70D6")#13 создаем левую и правую ракетку, чтоб они просто были
	RIGHT_PAD=c.create_line(WIDTH-PAD_W/2,
	                        0,
	                        WIDTH-PAD_W/2,
	                        PAD_H,
	                        width=PAD_W,
	                        fill="#DA70D6")#13
	PLAYER1_SCORE=0#66) считаем очки и возвращаем мяч на изначальную точку
	PLAYER2_SCORE=0
	#68 нужны функции смена счета и функции смены положения мяча
	INITIAL_SPEED=20#69 переменная для счета скорости
	p_1_text=c.create_text(WIDTH-WIDTH/6,
	                       PAD_H/4,
	                       text=PLAYER1_SCORE,
	                       font='Arial 20',
	                       fill='aqua')#67 создаем текст очков
	p_2_text=c.create_text(WIDTH/6,
	                       PAD_H/4,
	                       text=PLAYER2_SCORE,
	                       font='Arial 20',
	                       fill='aqua')
	#22) создаем упраление ракетами
	PAD_SPEED=20#23 задаем сначала общую скорость ракетки
	LEFT_PAD_SPEED=0#24  скорость левой и правой ракетки, задаем 0, ибо изначально она не двигается
	RIGHT_PAD_SPEED=0#24
	BALL_SPEED_UP=1.00#45 скорость мяча с каждым ударом
	BALL_MAX_SPEED=30#46 максимальная скорость мяча
	BALL_X_SPEED=20#47 начальная скорость по горизонтали
	BALL_Y_SPEED=20#48 po vertikali
	right_line_distance=WIDTH-PAD_W#49 расстояние да правого края
	def update_score(player):#70  создадим функцию, которая будет обнвлять счет
	    global PLAYER1_SCORE, PLAYER2_SCORE
	    if player=='right':
	        PLAYER1_SCORE+=1
	        c.itemconfig(p_1_text, text=PLAYER1_SCORE)
	    else:
	        PLAYER2_SCORE+=1
	        c.itemconfig(p_2_text, text=PLAYER2_SCORE)
	def spawn_ball():#71 respoun
	    global BALL_X_SPEED#72
	    c.coords(BALL,
	             WIDTH/2-BALL_RADIUS/2,
	             HEIGHT/2-BALL_RADIUS/2,
	             WIDTH/2+BALL_RADIUS/2,
	             HEIGHT/2+BALL_RADIUS/2)#73
	    BALL_X_SPEED=-(BALL_X_SPEED*INITIAL_SPEED)/abs(BALL_X_SPEED)#74
	def bounce(actiom):#50 напишем функию, которая будет отскакиать мяч
	    global BALL_X_SPEED, BALL_Y_SPEED#51 переменные, которые понадобятся для мяча
	    if actiom=='strike':#52 если ужарим ракеткй, то мы повернем в случайном направлении от -10 дo +10
	        BALL_Y_SPEED=random.randrange(-10, 10)#52
	        if abs(BALL_X_SPEED)<BALL_MAX_SPEED:#53 и если скорость мяча < скорости максимального мяча, то мы эту скорость увеличим
	            BALL_X_SPEED *= -BALL_SPEED_UP
	        else:#54 иначе оставляем ее на месте
	            BALL_X_SPEED= -BALL_X_SPEED
	    else:#55
	        BALL_Y_SPEED= -BALL_Y_SPEED#56
	def move_ball():#17 Сделаем функцию движения мяча
	    #57c.move(BALL, BALL_X_CHANCGE, BALL_Y_CHANCGE)#18 двигаем мяча по определенному скорости
	    ball_left, ball_top, ball_right, ball_bot=c.coords(BALL) # 58 нужно переписать движение мяча с учетом движения, которое мы написали в функции bounce. то есть нужно определять координаты мяча oт центра
	    ball_center=(ball_top+ball_bot)/2#59 теперь нужно это все определеить, например центр
	    if ball_right + BALL_X_SPEED < right_line_distance and  ball_left +BALL_X_SPEED > PAD_W:#60 теперь нужно сделатьь так, чтоб вертикально отскакивал
	        c.move(BALL, BALL_X_SPEED, BALL_Y_SPEED)#61 тогда двигаем дальше
	    elif ball_right==right_line_distance or ball_left==PAD_W:#62 проверяем, проверим какой именно стороны поля мы коснулись, если правой стороны -сравниваем позицию центра мяча, и если мяч в пределах ракетки, то делаем отскок
	        if ball_right>WIDTH/2:
	            if c.coords(RIGHT_PAD)[1]<ball_center<c.coords(RIGHT_PAD)[3]:
	                bounce('strike')#63 тогда мы делаем отскок
	            else:
	                #76pass
	                update_score('left')#77
	                spawn_ball()#78
	        else:
	            if c.coords(LEFT_PAD)[1]<ball_center<c.coords(LEFT_PAD)[3]:
	                bounce('strike')#63 тогда мы делаем отскок
	            else:
	                #76pass
	                update_score('right')#77
	                spawn_ball()#78    else:#64 теперь нужно проверить момент, когда мяч выходит за пределы игрового поля
	    else:
	        if ball_right > WIDTH/2:
	            c.move(BALL,
	                   right_line_distance-ball_right,
	                   BALL_Y_SPEED)
	        else:
	            c.move(BALL,
	                   -ball_left+PAD_W,
	                   BALL_Y_SPEED)
	    if ball_top+BALL_Y_SPEED<0 or ball_bot+BALL_Y_SPEED>HEIGHT:
	        bounce('ricochet')
	        #65 на экране мы должны увидеть отскок
	def move_pads():#25 напишим функию двжиения обих ракеток сразу
	    PADS={LEFT_PAD: LEFT_PAD_SPEED,
	          RIGHT_PAD: RIGHT_PAD_SPEED}#26 нужно сделать так чтоб левая ракеткка двигалась ско скорость левой ракеткой, а праввая - правой. для этого создаим словарик
	    for pad in PADS:#27 теперь нужно перебррать ракетки, и двигать с заданной скоростью, черех цикл FOR
	        c.move(pad, 0, PADS[pad])#27
	        if c.coords(pad)[1]<0:#28 Если ракетка входит выше поля, то мы ее возращаем на место
	            c.move(pad, 0, -c.coords(pad)[1])#29 отталкиваем нашу ракетку
	        elif c.coords(pad)[3]>HEIGHT:#30 если снизу, то отталкиваем вниз
	            c.move(pad, 0, HEIGHT-c.coords(pad)[3])#30
	def main():#19  main вызывает функию move_ball при помощи рекурсии
	    move_ball()#19
	    move_pads()# 31 вставим move_pads в функцию main,  чтоб когда мы вызывали эту функциюу нас не только летел, но идвигались наши ракетки
	    root.after(30, main)#20
	c.focus_get()#32 фокус на сanvas, чтоб реагировал на нажатие клавиши
	def moveent_hadeler(event):#33 функция обработки нажатия клавиш
	    global LEFT_PAD_SPEED, RIGHT_PAD_SPEED#34
	    if event.keysym=='w':#35
	        LEFT_PAD_SPEED= -PAD_SPEED#36 когда мы нажимаем верх, ракетка должна идти верх
	    elif event.keysym=='s':#36
	        LEFT_PAD_SPEED= PAD_SPEED#36
	    elif event.keysym=='Up':#37 для 2ой ракетки
	        RIGHT_PAD_SPEED= -PAD_SPEED
	    elif event.keysym=='Down':#37 для 2ой ракетки
	        RIGHT_PAD_SPEED= PAD_SPEED
	c.bind("<KeyPress>", moveent_hadeler)#38 теперь нужно привязывать Сanvas  эту функцию
	#39 po idee na ekrane dlojni reagirovat uje raketki, klavishi, a zdes ERROR 15:46
	def stop_pad(event):#40 сделаем функцию реагирования на отпускания
	    global LEFT_PAD_SPEED, RIGHT_PAD_SPEED#41
	    if event.keysym in 'ws':#42 если эти клавиши не нажаты, то мы ставим скорость 0
	        LEFT_PAD_SPEED=0
	    elif event.keysym in ('Up', 'Down'):
	        RIGHT_PAD_SPEED=0
	c.bind("<KeyRelease>", stop_pad)#43 делаем привязку этой функцииdelaem privyazku etoi funkcii
	main()#21 запуск самого двжиения
	root.mainloop()#14 запуск окна
	Task:
	Snake
	Decision:
	import pygame, random, sys, time
	"""print("hello")
	def privet():
	    error = pygame.init()
	    if error[1]==0:
	        print("Hello! It's been a rain, weather")
	    else:
	        print("error detected!")
	        sys.exit()
	privet()
	#выводит, что было выполненно 6 команд, и 0 ошибок
	"""
	playSurface=pygame.display.set_mode((800,600)) # Создаем экран
	pygame.display.set_caption("Snake") # Даем имя экрану
	#time.sleep(56)
	position=[50, 50] # Координаты змейки
	body=[[80,50],[70,50],[60,50]] # Структура тела змейки
	bait=[random.randrange(1,80)*10, random.randrange(1,60)*10] # Пища
	baitVisible=True
	fpsController=pygame.time.Clock()
	direction='RIGHT' # Направление движения
	changeto=direction # Изменение направления
	score=0 # Игровой счет
	"""
	Нужно еще создать цвета, таблица цветов rgb - google
	color=pygame.Color(r,b,a)
	"""
	white=pygame.Color(255,255,255) # Фон
	black=pygame.Color(0,0,0) # Конец игры
	red=pygame.Color(255,0,0) # Шрифт
	green=pygame.Color(0,255,0) # Змейка
	blue=pygame.Color(0,0,255)
	lightslateblue=pygame.Color(132,112,255) # Пища для змейки
	def gameOver():
	"""
	Сделаем надпись, которая будет появляться в конце игры.
	Чтобы несколько раз не писать pygame, мы объекту передаем дополнительные
	параметры
	"""
	    gaOFont=pygame.font.SysFont('Garamond', 48)
	# Объект, который отвечает за шрифт, и то, какой будет шрифт
	    gaOSurface=gaOFont.render('Game over!', True, white)
	"""
	Здесь нужно было создать надпись GAMEOVER. Для этого мы используем Функцию render,
	которая отвечает за то, чтобы создать саму надпись
	"""
	    gaORectangular=gaOSurface.get_rect()
	    gaORectangular.midtop=(400, 25) # Тут задаем координаты для надписи
	    playSurface.blit(gaOSurface, gaORectangular)
	""" blit отвечает за то, что бы нарисовать 1 объект поверх другого, т.е.
	поверх gaOSurface нужно разместить gaORectangular
	"""
	    showScore(2) # Строим счетчик
	    pygame.display.flip()
	"""
	Выводим на экран воображаемые объекты. Если эту строку не писать, то мы увидим
	пустой экра. flip - прописывает то, что мы написали в коде
	"""
	    time.sleep(8) # Задержка
	    pygame.quit()
	# Чтобы игра была завершена технически, нужно закончить pygame 
	    sys.exit() # Чтобы закончить саму программу в Питоне
	def showScore (choice=1):
	    scoreFont=pygame.font.SysFont('Garamond', 24)
	    scoreSurface=scoreFont.render('Score: {0}'.format(score), True, red)
	#   scoreSurface=scoreFont.render('Score:'+str(score), True, red)
	    scoreRectangular=scoreSurface.get_rect()
	    if choice==1:
	        scoreRectangular.midtop=(50, 25)
	    else:
	        scoreRectangular.midtop=(400, 125)
	# Два варианта, которые будут позиционировать блок со шрифтом
	    playSurface.blit(scoreSurface, scoreRectangular)
	    pygame.display.flip()

	#                       Создаем осноной элемент игры
	while True:
	"""
	Сделаем бесконечную игру с помощью цикла.
	Игра ждет действие игрока, т.е. во время бесконечного цикла мы будем забирать
	событие event
	"""
	    for event in pygame.event.get(): # очередь событии, т.е. последовательности
	"""
	Для работы с последовательностью, чтобы работать с каждым элементом в поисках
	элемента только с определенным типом. Поэтому используем цикл for
	"""
	        if event.type == pygame.QUIT:
	# Мы каждый раз проверяем не хочет ли игрок выйти из игры
	            pygame.guit()
	            sys.exit()
	# Если хочет игрок выйти, тогда мы закрываем программу
	        elif event.type == pygame.KEYDOWN:
	# Проверяем на нажатие клавиши, но мы должны посмотреть какую именно клавишу
	            if event.key==pygame.K_RIGHT or event.key == ord('d'):
	                changeto='RIGHT'
	# Если K_RIGHT, то нужно изменить направление
	# ord('d') - Кодировка клавиши - 100
	            if event.key==pygame.K_LEFT or event.key == ord('a'):
	                changeto='LEFT'
	            if event.key==pygame.K_UP or event.key == ord('w'):
	                changeto='UP'
	            if event.key==pygame.K_DOWN or event.key == ord('d'):
	                changeto='DOWN'
	            if event.key==pygame.K_ESCAPE:
	# и рассмотрим случаи, когда работает кнопка ESC
	#               pygame.event.post(pygame.event.Event(QUIT))
	# Для этого Сделаем метод post, чтобы отправить в очередь событие
	                gameOver()
	#                   Обработка направления движения змейки
	"""
	Что делать при смене определения направления движения. определение направления
	движения влиеяет на положение Змейки на карте с координатами POSITION[50,50].
	Т.е. direction будет влиять на значение Х или У
	Мы должны прописать связку, которая образовывает changeto
	Представим, что есть Змейка [][][]. Слева хвост, справа голова. и он сейчас
	движется вправо, если игрок нажал RIGHT, а если вверх - UP, а это значит, что
	голова будет находиться в других координатах
	  []
	[][]
	а потом так
	  []
	  []
	  []
	т.е. голова вверху, а хвост внизу. Но если игрок нажмет в таком слуаче вниз, а
	это неправильный ход. Сначала голова же должна повернуться, а потом уже внизу.
	Именно это нужно сейчас прописать. Сделаем так, чтобы змея не меняла направление
	в таких случаях
	"""
	    if direction != 'LEFT' and changeto == 'RIGHT':
	        direction='RIGHT'
	    if direction != 'RIGHT' and changeto == 'LEFT':
	        direction = 'LEFT'
	    if direction != 'UP' and changeto == 'DOWN':
	        direction = 'DOWN'
	    if direction != 'DOWN' and changeto == 'UP':
	        direction = 'UP'
	"""
	Если направление движения не было вниз, а мы получили указание двигаться вверх,
	то мы двигаемся вверх
	"""
	#                   Изменение позиции в зависимости от направления
	    if direction == 'RIGHT':
	        position[0] += 10
	"""
	Мы производим увеличение оси Х, обращаясь к элементу с индексом 0, т.к. Х идет по
	этому индексу, а с индексом 1 - У. Поэтому мы меняем значение Х по списке на 10.
	10 это то на что мы делим - длины, позиции, и т.д. кратное 10
	"""
	    if direction == 'LEFT':
	        position[0] -= 10 # Влево, значит уменьшенное на 10
	    if direction == 'UP':
	        position[1] -= 10
	    if direction == 'DOWN':
	        position[1] += 10
	# Тут надо еще учитывать, что оси Х и У в pygame, не такие ккак в математике
	"""
	Двигается змейка вправо и состоит из 3х блоков
	[][][]
	При каждом поедании нужно проверить съел ли он пищу (BAIT), и если съел -
	увеличить его на один блок
	[][][][]
	Увлеличение будем осуществлять методом insert в начало списка. А дальше еда
	исчезает, добавляется новый блок и пища появляется в другом месте. в новом теле
	будем добавлять новый элемент, потом сразу проверим на совпадение координат тела
	и координаты пищи. Если совпадение произошло, то будем оставлять новый добавленный
	блок, если нет - просто удаляем
	"""
	#               Работа над длиной тела змейки, увеличение счета
	    body.insert(0, list(position))
	    if position[0]==bait[0] and position[1]==bait[1]:
	        baitVisible=False
	        score+=1
	    else:
	        body.pop() # pop - удаляет последний элемент из списка
	#           Ввдимость пишем на карте
	    if baitVisible== False:
	# Проверим является пища не видимой, потому что она должна появиться сново
	        baitVisible=True # Тут рисуем новую пищу
	        bait = [random.randrange(1, 80) * 10, random.randrange(1, 60) * 10]  # primanka
	# Тут рисуем пищу в другом координате. этот же код был наверху.
	    playSurface.fill(white)
	# у нас есть элемент поверхностный - PLAYSURFACE, сделаем белым    
	"""
	Но нам еще нужно прописать тело змейки (BODY, он  состоит из списка), мы можем
	прописать эти элементы в списке по очереди, что делаем с помощью цикла for
	"""
	    for element in body:
	        pygame.draw.rect(playSurface, green, pygame.Rect(element[0], element[1], 10, 10))
	"""
	В библиотеке pygame есть класс DRAW, в этом классе, есть метод RECT(Рисование
	прямоугольника), мы передаем ему 3 элемента: поверхность, цвет, и еще 1 кдасс,
	который тоже рисует прямоугольник. у него координата Х (element[0]), У, и
	отдельно указываем ширину и высоту прямоугольника
	"""
	# рисуем пищу
	    pygame.draw.rect(playSurface, lightslateblue, pygame.Rect(bait[0], bait[1], 10, 10))
	# исправляем проблему, когда змейкка выходит за пределы экрана
	    if position[0]>790 or position[0]<0:
	        position[0]=400
	    if position[1]>590 or position[1]<0:
	        position[1]=300
	# чтоб змейка себя не съела
	    for element in body[1: ]:
	        if position[0]==element[0] and position[1]==element[1]:
	            position=[50,50] # координаты змейки
	            body=[[80,50], [70,50], [60,50]] # структура тела змейки
	    showScore()
	# чтобы выполнилось функция SCRORE счетчик
	    fpsController.tick(12)
	# чтобы змейка двигаласчь по медленее
	    pygame.display.flip()
    Task:
	Тетрис
	Decision:
	import pygame as pg
	import random, time, sys
	from pygame.locals import *
	#Затем определяем основные константы – кадровую частоту fps, высоту и ширину окна программы, размер базового элемента фигур-букв block (20 х 20 пикселей), параметры стакана, символ для обозначения пустых ячеек на игровом поле:
	fps = 25
	window_w, window_h = 600, 500
	block, cup_h, cup_w = 20, 20, 10
	#Параметры side_freq и down_freq задают время, которое затрачивается на перемещение фигуры в сторону или вниз, если игрок удерживает клавишу нажатой:
	side_freq, down_freq = 0.15, 0.1
	#Для размещения стакана и информационных надписей, а также для конвертации координат нам также понадобятся константы side_margin и top_margin – первая задает дистанцию между правой и левой сторонами окна программы и стаканом; вторая определяет расстояние между верхней границей стакана и окном:
	side_margin = int((window_w - cup_w * block) / 2)
	top_margin = window_h - (cup_h * block) - 5
	#Цвета фигур задаются двумя кортежами: colors и lightcolors. Последний включает чуть более светлые оттенки тех же цветов, что и colors – для создания псевдо 2.5 D эффекта.
	colors = ((0, 0, 225), (0, 225, 0), (225, 0, 0), (225, 225, 0)) # синий, зеленый, красный, желтый
	lightcolors = ((30, 30, 255), (50, 255, 50), (255, 30, 30), (255, 255, 30)) # светло-синий, светло-зеленый, светло-красный, светло-желтый
	white, gray, black  = (255, 255, 255), (185, 185, 185), (0, 0, 0)
	brd_color, bg_color, txt_color, title_color, info_color = white, black, white, colors[3], colors[0]
	#Поскольку каждая фигура состоит из 4 блоков, размер шаблона должен быть 5 х 5: 
	fig_w, fig_h = 5, 5
	empty = 'o'
	#Поскольку каждую фигуру-букву можно поворачивать на 90 градусов, все возможные варианты поворотов описаны в словаре figures с помощью вложенных списков, элементы которых состоят из строк: символом x отмечены занятые ячейки, o – пустые. Количество вращений зависит от формы буквы: у O, к примеру, будет всего один вариант:
	figures = {'S': [['ooooo',
	                  'ooooo',
	                  'ooxxo',
	                  'oxxoo',
	                  'ooooo'],
	                 ['ooooo',
	                  'ooxoo',
	                  'ooxxo',
	                  'oooxo',
	                  'ooooo']],
	           'Z': [['ooooo',
	                  'ooooo',
	                  'oxxoo',
	                  'ooxxo',
	                  'ooooo'],
	                 ['ooooo',
	                  'ooxoo',
	                  'oxxoo',
	                  'oxooo',
	                  'ooooo']],
	           'J': [['ooooo',
	                  'oxooo',
	                  'oxxxo',
	                  'ooooo',
	                  'ooooo'],
	                 ['ooooo',
	                  'ooxxo',
	                  'ooxoo',
	                  'ooxoo',
	                  'ooooo'],
	                 ['ooooo',
	                  'ooooo',
	                  'oxxxo',
	                  'oooxo',
	                  'ooooo'],
	                 ['ooooo',
	                  'ooxoo',
	                  'ooxoo',
	                  'oxxoo',
	                  'ooooo']],
	           'L': [['ooooo',
	                  'oooxo',
	                  'oxxxo',
	                  'ooooo',
	                  'ooooo'],
	                 ['ooooo',
	                  'ooxoo',
	                  'ooxoo',
	                  'ooxxo',
	                  'ooooo'],
	                 ['ooooo',
	                  'ooooo',
	                  'oxxxo',
	                  'oxooo',
	                  'ooooo'],
	                 ['ooooo',
	                  'oxxoo',
	                  'ooxoo',
	                  'ooxoo',
	                  'ooooo']],
	           'I': [['ooxoo',
	                  'ooxoo',
	                  'ooxoo',
	                  'ooxoo',
	                  'ooooo'],
	                 ['ooooo',
	                  'ooooo',
	                  'xxxxo',
	                  'ooooo',
	                  'ooooo']],
	           'O': [['ooooo',
	                  'ooooo',
	                  'oxxoo',
	                  'oxxoo',
	                  'ooooo']],
	           'T': [['ooooo',
	                  'ooxoo',
	                  'oxxxo',
	                  'ooooo',
	                  'ooooo'],
	                 ['ooooo',
	                  'ooxoo',
	                  'ooxxo',
	                  'ooxoo',
	                  'ooooo'],
	                 ['ooooo',
	                  'ooooo',
	                  'oxxxo',
	                  'ooxoo',
	                  'ooooo'],
	                 ['ooooo',
	                  'ooxoo',
	                  'oxxoo',
	                  'ooxoo',
	                  'ooooo']]}
	#Заливку сплошным цветом реализовать очень просто, но полупрозрачную заставку сделать сложнее – как ни странно, метод draw в Pygame до сих пор не поддерживает эту опцию. Есть несколько способов решения этой проблемы. Мы воспользуемся методом, который предусматривает создание дополнительной поверхности с попиксельным альфа-смешением, и последующую заливку экрана паузы цветом с наложением на поверхность окна игры:
	def pauseScreen():
	    pause = pg.Surface((600, 500), pg.SRCALPHA)
	    pause.fill((0, 0, 255, 127))
	    display_surf.blit(pause, (0, 0))
	#Эта функция отвечает за создание нескольких дополнительных глобальных констант, инициализирует модуль Pygame, рисует стартовое окно игры, вызывает запуск Тетриса runTetris() и в случае необходимости отображает сообщение о проигрыше:
	def main():
	    global fps_clock, display_surf, basic_font, big_font
	    pg.init()
	    fps_clock = pg.time.Clock()
	    display_surf = pg.display.set_mode((window_w, window_h))
	    basic_font = pg.font.SysFont('arial', 20)
	    big_font = pg.font.SysFont('verdana', 45)
	    pg.display.set_caption('Тетрис Lite')
	    showText('Тетрис Lite')
	    while True: # начинаем игру
	        runTetris()
	        pauseScreen()
	        showText('Игра закончена')
	#Код игры располагается в функции runTetris():
	def runTetris():
	    cup = emptycup()
	    last_move_down = time.time()
	    last_side_move = time.time()
	    last_fall = time.time()
	    going_down = False
	    going_left = False
	    going_right = False
	    points = 0
	    level, fall_speed = calcSpeed(points)
	    fallingFig = getNewFig()
	    nextFig = getNewFig()
	    #Основной цикл обрабатывает все основные события, связанные с генерацией фигур, движением вниз и показом следующей фигуры:
	    while True: 
	        if fallingFig == None:
	            # если нет падающих фигур, генерируем новую
	            fallingFig = nextFig
	            nextFig = getNewFig()
	            last_fall = time.time()
	            if not checkPos(cup, fallingFig):
	                return # если на игровом поле нет свободного места - игра закончена
	        quitGame()
	        for event in pg.event.get(): 
	            if event.type == KEYUP:
	                if event.key == K_SPACE:
	                    pauseScreen()
	                    showText('Пауза')
	                    last_fall = time.time()
	                    last_move_down = time.time()
	                    last_side_move = time.time()
	                #Цикл обрабатывает паузу и определяет момент, когда пользователь нажимает и отпускает клавиши со стрелками. Если клавиши →, ← и ↓ не нажаты, значения соответствующих переменных меняются на False:
	                elif event.key == K_LEFT:
	                    going_left = False
	                elif event.key == K_RIGHT:
	                    going_right = False
	                elif event.key == K_DOWN:
	                    going_down = False
	            #Управление движением фигур происходит в ветке elif event.type == KEYDOWN: если нажата клавиша со стрелкой и функция checkPos() возвращает True, положение фигуры изменяется на один блок в соответствующем направлении:
	            elif event.type == KEYDOWN:
	                if event.key == K_LEFT and checkPos(cup, fallingFig, adjX=-1):
	                    fallingFig['x'] -= 1
	                    going_left = True
	                    going_right = False
	                    last_side_move = time.time()
	                elif event.key == K_RIGHT and checkPos(cup, fallingFig, adjX=1):
	                    fallingFig['x'] += 1
	                    going_right = True
	                    going_left = False
	                    last_side_move = time.time()                    
	                # поворачиваем фигуру, если есть место
	                elif event.key == K_UP:
	                    fallingFig['rotation'] = (fallingFig['rotation'] + 1) % len(figures[fallingFig['shape']])
	                    #При нажатии ↑ происходит вращение фигуры – варианты берутся из словаря figures. Чтобы не получить ошибку IndexError: list index out of range, мы используем конструкцию, которая обнуляет индекс элемента, когда инкремент достигает максимального значения: fallingFig['rotation'] + 1) % len(figures[fallingFig['shape']]. Если функция checkPos() сообщает, что очередное вращение невозможно из-за того, что фигура натыкается на какой-то блок, нужно вернуться к предыдущему варианту из списка:
	                    if not checkPos(cup, fallingFig):
	                        fallingFig['rotation'] = (fallingFig['rotation'] - 1) % len(figures[fallingFig['shape']])
	                #Для ускорения падения игрок нажимает и удерживает клавишу ↓:
	                elif event.key == K_DOWN:
	                    going_down = True
	                    if checkPos(cup, fallingFig, adjY=1):
	                        fallingFig['y'] += 1
	                    last_move_down = time.time()
	                #Если пользователь хочет мгновенно сбросить фигуру на дно, он может нажать Enter. Цикл for здесь определяет максимально низкую свободную позицию в стакане:
	                elif event.key == K_RETURN:
	                	going_down = False
	                	going_left = False
	                	going_right = False
	                	for i in range(1, cup_h):
	                    	    if not checkPos(cup, fallingFig, adjY=i):
	                      	        break
	                	fallingFig['y'] += i - 1
	        #Чтобы определить, удерживает ли пользователь клавишу движения, программа использует условия:
	        if (going_left or going_right) and time.time() - last_side_move > side_freq:
	            if going_left and checkPos(cup, fallingFig, adjX=-1):
	                fallingFig['x'] -= 1
	            elif going_right and checkPos(cup, fallingFig, adjX=1):
	                fallingFig['x'] += 1
	            last_side_move = time.time()
	        if going_down and time.time() - last_move_down > down_freq and checkPos(cup, fallingFig, adjY=1):
	            fallingFig['y'] += 1
	            last_move_down = time.time()
	        #Если пользователь никак не вмешивается в управление фигурой, движение вниз происходит так:
	        if time.time() - last_fall > fall_speed: # свободное падение фигуры
	            if not checkPos(cup, fallingFig, adjY=1): # проверка "приземления" фигуры
	                addToCup(cup, fallingFig) # фигура приземлилась, добавляем ее в содержимое стакана
	                points += clearCompleted(cup)
	                level, fall_speed = calcSpeed(points)
	                fallingFig = None
	            else: # фигура пока не приземлилась, продолжаем движение вниз
	                fallingFig['y'] += 1
	                last_fall = time.time()
	        #Функцию runTetris() завершает набор функций, обеспечивающих отрисовку игрового поля, вывод названия игры, падающей и следующих фигур, а также информационных надписей:
	        display_surf.fill(bg_color)
	        drawTitle()
	        gamecup(cup)
	        drawInfo(points, level)
	        drawnextFig(nextFig)
	        if fallingFig != None:
	            drawFig(fallingFig)
	        pg.display.update()
	        fps_clock.tick(fps)
	#ункция txtObjects() принимает текст, шрифт и цвет, и с помощью метода render() возвращает готовые объекты Surface (поверхность) и Rect (прямоугольник). Эти объекты в дальнейшем обрабатываются методом blitв функции showText(), выводящей информационные надписи и название игры.
	def txtObjects(text, font, color):
	    surf = font.render(text, True, color)
	    return surf, surf.get_rect()
	#Выход из игры обеспечивает функция stopGame(), в которой используется sys.exit() из импортированного в начале кода модуля sys.
	def stopGame():
	    pg.quit()
	    sys.exit()
	def checkKeys():
	    quitGame()
	    for event in pg.event.get([KEYDOWN, KEYUP]):
	        if event.type == KEYDOWN:
	            continue
	        return event.key
	    return None
	def showText(text):
	    titleSurf, titleRect = txtObjects(text, big_font, title_color)
	    titleRect.center = (int(window_w / 2) - 3, int(window_h / 2) - 3)
	    display_surf.blit(titleSurf, titleRect)
	    pressKeySurf, pressKeyRect = txtObjects('Нажмите любую клавишу для продолжения', basic_font, title_color)
	    pressKeyRect.center = (int(window_w / 2), int(window_h / 2) + 100)
	    display_surf.blit(pressKeySurf, pressKeyRect)
	    while checkKeys() == None:
	        pg.display.update()
	        fps_clock.tick()
	def quitGame():
	    for event in pg.event.get(QUIT): # проверка всех событий, приводящих к выходу из игры
	        stopGame() 
	    for event in pg.event.get(KEYUP): 
	        if event.key == K_ESCAPE:
	            stopGame() 
	        pg.event.post(event) 
	def calcSpeed(points):
	    # вычисляет уровень
	    level = int(points / 10) + 1
	    fall_speed = 0.27 - (level * 0.02)
	    return level, fall_speed
	def getNewFig():
	    # возвращает новую фигуру со случайным цветом и углом поворота
	    shape = random.choice(list(figures.keys()))
	    newFigure = {'shape': shape,
	                'rotation': random.randint(0, len(figures[shape]) - 1),
	                'x': int(cup_w / 2) - int(fig_w / 2),
	                'y': -2, 
	                'color': random.randint(0, len(colors)-1)}
	    return newFigure
	#За добавление фигур к содержимому стакана отвечает addToCup():
	def addToCup(cup, fig):
	    for x in range(fig_w):
	        for y in range(fig_h):
	            if figures[fig['shape']][fig['rotation']][y][x] != empty:
	                cup[x + fig['x']][y + fig['y']] = fig['color']
	#Пустой стакан создается функцией emptycup():
	def emptycup():
	    # создает пустой стакан
	    cup = []
	    for i in range(cup_w):
	        cup.append([empty] * cup_h)
	    return cup
	def incup(x, y):
	    return x >= 0 and x < cup_w and y < cup_h
	#Функция checkPos() следит за тем, чтобы падающая фигура оставалась в пределах игрового поля и не накладывалась на предыдущие. На примере слева фигура остается в допустимой области, на примере справа – ошибочно накладывается на предыдущую. Чтобы определить положение фигуры в стакане, нужно суммировать собственные координаты фигуры со «стаканными»:
	def checkPos(cup, fig, adjX=0, adjY=0):
	    # проверяет, находится ли фигура в границах стакана, не сталкиваясь с другими фигурами
	    for x in range(fig_w):
	        for y in range(fig_h):
	            abovecup = y + fig['y'] + adjY < 0
	            if abovecup or figures[fig['shape']][fig['rotation']][y][x] == empty:
	                continue
	            if not incup(x + fig['x'] + adjX, y + fig['y'] + adjY):
	                return False
	            if cup[x + fig['x'] + adjX][y + fig['y'] + adjY] != empty:
	                return False
	    return True
	#За обнаружение и удаление заполненных рядов отвечает функция clearCompleted() вместе со вспомогательной isCompleted(). Если isCompleted() возвращает True, программе нужно последовательно переместить вниз все ряды, располагающиеся над удаляемым, после чего заполнить нулевой ряд empty-значениями о:
	def isCompleted(cup, y):
	    # проверяем наличие полностью заполненных рядов
	    for x in range(cup_w):
	        if cup[x][y] == empty:
	            return False
	    return True
	def clearCompleted(cup):
	    # Удаление заполенных рядов и сдвиг верхних рядов вниз
	    removed_lines = 0
	    y = cup_h - 1
	    while y >= 0:
	        if isCompleted(cup, y):
	           for pushDownY in range(y, 0, -1):
	                for x in range(cup_w):
	                    cup[x][pushDownY] = cup[x][pushDownY-1]
	           for x in range(cup_w):
	                cup[x][0] = empty
	           removed_lines += 1
	        else:
	            y -= 1
	    return removed_lines
	def convertCoords(block_x, block_y):
	    return (side_margin + (block_x * block)), (top_margin + (block_y * block))
	#Каждая фигура состоит из 4 элементов – блоков. Блоки рисует функция drawBlock(), которая получает координаты из convertCoords():
	def drawBlock(block_x, block_y, color, pixelx=None, pixely=None):
	    #отрисовка квадратных блоков, из которых состоят фигуры
	    if color == empty:
	        return
	    if pixelx == None and pixely == None:
	        pixelx, pixely = convertCoords(block_x, block_y)
	    pg.draw.rect(display_surf, colors[color], (pixelx + 1, pixely + 1, block - 1, block - 1), 0, 3)
	    pg.draw.rect(display_surf, lightcolors[color], (pixelx + 1, pixely + 1, block - 4, block - 4), 0, 3)
	    pg.draw.circle(display_surf, colors[color], (pixelx + block / 2, pixely + block / 2), 5)
	def gamecup(cup):
	    # граница игрового поля-стакана
	    pg.draw.rect(display_surf, brd_color, (side_margin - 4, top_margin - 4, (cup_w * block) + 8, (cup_h * block) + 8), 5)
	    # фон игрового поля
	    pg.draw.rect(display_surf, bg_color, (side_margin, top_margin, block * cup_w, block * cup_h))
	    for x in range(cup_w):
	        for y in range(cup_h):
	            drawBlock(x, y, cup[x][y])
	def drawTitle():
	    titleSurf = big_font.render('Тетрис Lite', True, title_color)
	    titleRect = titleSurf.get_rect()
	    titleRect.topleft = (window_w - 425, 30)
	    display_surf.blit(titleSurf, titleRect)
	def drawInfo(points, level):
	    pointsSurf = basic_font.render(f'Баллы: {points}', True, txt_color)
	    pointsRect = pointsSurf.get_rect()
	    pointsRect.topleft = (window_w - 550, 180)
	    display_surf.blit(pointsSurf, pointsRect)
	    levelSurf = basic_font.render(f'Уровень: {level}', True, txt_color)
	    levelRect = levelSurf.get_rect()
	    levelRect.topleft = (window_w - 550, 250)
	    display_surf.blit(levelSurf, levelRect)
	    pausebSurf = basic_font.render('Пауза: пробел', True, info_color)
	    pausebRect = pausebSurf.get_rect()
	    pausebRect.topleft = (window_w - 550, 420)
	    display_surf.blit(pausebSurf, pausebRect)
	    escbSurf = basic_font.render('Выход: Esc', True, info_color)
	    escbRect = escbSurf.get_rect()
	    escbRect.topleft = (window_w - 550, 450)
	    display_surf.blit(escbSurf, escbRect)
	def drawFig(fig, pixelx=None, pixely=None):
	    figToDraw = figures[fig['shape']][fig['rotation']]
	    if pixelx == None and pixely == None:    
	        pixelx, pixely = convertCoords(fig['x'], fig['y'])
	    #отрисовка элементов фигур
	    for x in range(fig_w):
	        for y in range(fig_h):
	            if figToDraw[y][x] != empty:
	                drawBlock(None, None, fig['color'], pixelx + (x * block), pixely + (y * block))
	def drawnextFig(fig):  # превью следующей фигуры
	    nextSurf = basic_font.render('Следующая:', True, txt_color)
	    nextRect = nextSurf.get_rect()
	    nextRect.topleft = (window_w - 150, 180)
	    display_surf.blit(nextSurf, nextRect)
	    drawFig(fig, pixelx=window_w-150, pixely=230)
	if __name__ == '__main__':
	    main()
	Task:
	шахматы
	Даны две различные клетки шахматной доски. Напишите программу, которая определяет, может ли ладья попасть с первой клетки на вторую одним ходом. Программа получает на вход четыре числа от 1 до 8 каждое, задающие номер столбца и номер строки сначала для первой клетки, потом для второй клетки. Программа должна вывести «YES», если из первой клетки ходом ладьи можно попасть во вторую, или «NO» в противном случае.
	Decision:
	x1,y1,x2,y2=int(input()),int(input()),int(input()),int(input())
	if x1==x2 or y1==y2:
	    print("YES")
	else:    
	    print("NO")
	Task:
	Даны две различные клетки шахматной доски. Напишите программу,  которая определяет, может ли король попасть с первой клетки на вторую одним ходом. Программа получает на вход четыре числа от 1 до 8 каждое, задающие номер столбца и номер строки сначала для первой клетки, потом для второй клетки. Программа должна вывести «YES», если из первой клетки ходом короля можно попасть во вторую, или «NO» в противном случае.
	Decision:
	x1,y1,x2,y2=int(input()),int(input()),int(input()),int(input())
	if (x2==x1+1 and y2==y1) or (x2==x1+1 and y2==y1-1) or (x2==x1+1 and y2==y1+1) or (x2==x1 and y2==y1+1) or (x2==x1 and y2==y1-1) or (x2==x1-1 and y2==y1) or (x2==x1-1 and y2==y1-1) or (x2==x1-1 and y2==y1+1):
	    print("YES")
	else:    
	    print("NO")
	Task:
	Заданы две клетки шахматной доски. Напишите программу, которая определяет имеют ли указанные клетки один цвет или нет. Если они покрашены в один цвет, то выведите слово «YES», а если в разные цвета — то «NO».
	Decision:
	x1, y1, x2, y2 = int(input()), int(input()), int(input()), int(input())
	if (x1 + y1 + x2 + y2) % 2 == 0:
	    print('YES')
	else:
	    print('NO')
	Task:
	Даны две различные клетки шахматной доски. Напишите программу, которая определяет, может ли слон попасть с первой клетки на вторую одним ходом. Программа получает на вход четыре числа от 1 до 8 каждое, задающие номер столбца и номер строки сначала для первой клетки, потом для второй клетки. Программа должна вывести «YES», если из первой клетки ходом слона можно попасть во вторую или «NO» в противном случае.
	Decision:
	x1, y1, x2, y2 = int(input()), int(input()), int(input()), int(input())
	if (x1 - y1 == x2 - y2) or (x1 + y1 == x2 + y2):
	    print('YES')
	else:
	    print('NO')
	Task:
	Даны две различные клетки шахматной доски. Напишите программу,  которая определяет, может ли конь попасть с первой клетки на вторую одним ходом. Программа получает на вход четыре числа от 1 до 8 каждое, задающие номер столбца и номер строки сначала для первой клетки, потом для второй клетки. Программа должна вывести «YES», если из первой клетки ходом коня можно попасть во вторую или «NO» в противном случае.
	Decision:
	x1,y1,x2,y2= int(input()),int(input()),int(input()),int(input())
	if (x2==x1-1 or x2==x1+1) and y2==y1-2:
	    print('YES')
	elif (x2==x1-2 or x2==x1+2) and y2==y1-1:
	    print('YES')
	elif (x2==x1-2 or x2==x1+2) and y2==y1+1:
	    print('YES')
	elif (x2==x1-1 or x2==x1+1) and y2==y1+2:
	    print('YES')
	else:
	    print('NO')
	Task:
	Даны две различные клетки шахматной доски. Напишите программу,  которая определяет, может ли ферзь попасть с первой клетки на вторую одним ходом. Программа получает на вход четыре числа от 1 до 8 каждое, задающие номер столбца и номер строки сначала для первой клетки, потом для второй клетки. Программа должна вывести «YES», если из первой клетки ходом ферзя можно попасть во вторую или «NO» в противном случае.
	Decision:
	x1, y1, x2, y2 = int(input()), int(input()), int(input()), int(input())
	if (x1 - y1 == x2 - y2) or (x1 + y1 == x2 + y2):#слон
	    print('YES')
	elif (x1==x2 or x2==x1+1 or x2==x1-1) and (y1==y2 or y2==y1+1 or y2==y1-1): #король
	    print('YES')
	elif x1==x2 or y1==y2:#ладья
	    print('YES')
	else :
	    print('NO')
	Task:
	Нарисуйте шахматную доску размера nхn, состоящую из нулей и единиц. Верхний левый символ должен быть единицей.
	Примечание: между единицами и нулями в строке не должно быть пробелов, каждая строка должна быть на новой строке (в тестах отображается по-другому для экономии пространства).
	Decision:
	$ cat Py-Draft.py
	n = int(input())
	for i in range(n):
	  row = ""
	  for j in range(n):
	    if (i+j)%2==0:
	      row += "1"
	    else:
	      row += "0"
	  print(row)
	$ python3 Py-Draft.py
	3
	101
	010
	101
	$ python3 Py-Draft.py
	5
	10101
	01010
	10101
	01010
	10101
	$ python3 Py-Draft.py
	6
	101010
	010101
	101010
	010101
	101010
	010101

Python, Data Conversion
	Task:
	Converting a dictionary list to html code. From this:
	[{"A":"a_1", "B":"b_1", "C":"c_1"},
	{"A":"a_2", "B":"b_2", "C":"c_2"}]
	Convert to this:
	<tr>
	    <td>
	        <select>
	            <option value="A">
	            A
	            </option>
	            <option value="a_1">
	            a_1
	            </option>
	            <option value="a_2">
	            a_2
	            </option>
	        </select>
	    </td>
	    <td>
	        <select>
	            <option value="B">
	            B
	            </option>
	            <option value="b_1">
	            b_1
	            </option>
	            <option value="b_2">
	            b_2
	            </option>
	        </select>
	    </td>
	    <td>
	        <select>
	            <option value="C">
	            C
	            </option>
	            <option value="c_1">
	            c_1
	            </option>
	            <option value="c_2">
	            c_2
	            </option>
	        </select>
	    </td>
	</tr>
	<tr>
	    <td>
	        a_1
	    </td>
	    <td>
	        b_1
	    </td>
	    <td>
	        c_1
	    </td>
	</tr>
	<tr>
	    <td>
	        a_2
	    </td>
	    <td>
	        b_2
	    </td>
	    <td>
	        c_2
	    </td>
	</tr>
	Decision:
	'''
	listOfDictionaries = [
	        {"A":"a_1", "B":"b_1", "C":"c_1"}, 
	        {"A":"a_2", "B":"b_2", "C":"c_2"}
	    ]
	'''
	listOfDictionaries=[]
	listOfDictionaries.append({"A":"a_1", "B":"b_1", "C":"c_1"})
	listOfDictionaries.append({"A":"a_2", "B":"b_2", "C":"c_2"})
	'''
	numb=int(input("Enter number: "))
	for dictionary in range(1,numb):
	    listOfDictionaries.append({"A":"a_$dictionary", "B":"b_$dictionary", "C":"c_$dictionary"})
	    print(dictionary)
	'''
	'''
	for dictionary in listOfDictionaries:
	    #print(dictionary)
	    #print(listOfDictionaries[0]['A'])
	    for k in dictionary:
	        print(k)
	    for v in dictionary:
	        print(dictionary[v])
	'''
	html="""{0}"""
	tr="<tr>{0}</tr>"
	td="<td>{0}</td>"
	dictionary=[tr.format(''.join([td.format(a) for a in item])) for item in listOfDictionaries[:1]]
	dictionary.extend([tr.format(''.join([td.format(item[a]) for a in item])) for item in listOfDictionaries])
	print (html.format("".join(dictionary)))
	Task:
	Нужно чтобы на рабочем столе периодично отображались курсы доллара. заходим в центральный банк  смотрим курс валют, просмотрим тег. зацепимся именно за знак доллара, он один на этой странице. у него тег ins, и цепляюсь за него, потом есть родительский тег tr и забираю последний элемент td
	Decision:
	#!/usr/bin/python3.7
	import requests #1 импортирую бибилиотеку, так как она будет отвечать за отправку запросов
	from bs4 import BeautifulSoup
	import os #26 отвечает за взаимодействие с ОС
	def get_html(): #6 создаем фугкцию которая отправляет запрос
		url='http://www.cbr.ru/'
		r=requests.get(url) #8 делаем запрос на сервер
		return r.text #9 функция возвращает свойство text, уоторая содержит информацию об html
	def get_dollar_rate(html): 
		soup = BeatifulSoup(html, 'lxml')
		# t = soup.find('ins', text='$') #13 ищем ins в теге tr 
		# t = soup.find('ins', text='$').find_parent('tr') #17 обратимся к его родительскому контейнеру tr
	 	t = soup.find('ins', text='$').find_parent('tr').find_all('td')[-1].text #19 получим тег tr
		result=t.split('>')[-1] #21 указываем до какого числа нуно пропустить инфу (>) и какой элемент нам нужен (-1)
	 	return result #23 получим число курс
	def send_message(message): #24 хотим выводить это число на экран
	 	title='dollar SHA:'
		#26 os.system('notify-send "title" "message"')
		os.system('notify-send "{}" "{}"'.format(title, message)) 
	def main():
	 	rate=get_dollar_rate(get_html()) #27 получаем курс доллара
	 	send_message(rate)
	if __name__ == '__main__':
		main()

Python, Генерация
	Task:
	Данная программа очень простая, она брет два случайных слова из файла words.txt и комбинирует их
	Зачем это нужно?
	При комбинировании слов включается фантазия, позволяющая представить какую вещь можно было бы создать, скомбинировав
	два предмета или их свойства
	Данный подход примняется в ТРИЗ для генерации идей, и изобретений
	Decision:
	import random#1 Импортируем библиотеку
	mas=[]#2 создаем пустой список
	f=open(u'words.txt', 'r')#3 Открываем файлы со словами (существит)
	for x in f:#4 и в цикле
	    mas.append(x.replace('\n',''))#5 добавляем их всех в массив, добавляя знак переноса строки
	l=len(mas)-1#6 получаем длину этого массива
	z=''
	print('-----------------------------------------')
	print('Генератор идей на основе случайного скрещивания предметов')#
	print('-----------------------------------------')
	print('Нажимайте Enter для генерации пар')#
	print('\n')
	while(z!='exit'):#7 и пока не напечатаем exit
	    a=random.randint(0,l)#8 сгенерируем 2 случайных числа а
	    b=random.randint(0,l)#8 и b с диапозоном от 0 до длина массива
	    print(mas[a]+'-'+mas[b])# 9 и печатаем случайные строчки из файла words.txt после чего мы получаем различные комбинации случайных предметов
	    z=input('')#    
	Task:
	В заданном списке (преподаватель сгенерирует для вас список), возьмите каждый третий элемент, начиная с элемента с индексом 4 и до индекса 15 (невключительно).
	Decision:
	$ cat Py-Draft.py
	my_list = [8, 6, 2, 4, 2, 9, 1, 3, 8, 6, 8, 4, 6, 9, 7, 1, 6, 4, 8, 10]
	print(my_list[4:15:3])
	$ python3 Py-Draft.py
	[2, 3, 8, 9]  
	Task:
	При помощи генератора-списка сохраните в переменной zeroes список из 100 нулей.
	Выводить ничего не нужно, только правильно заполните список в переменной zeroes.
	Decision:
	$ cat /home/david/Документы/test/test.py            
	# Ваше решение
	l = [0]*100
	print(l)
	my_list = [0 for _ in range(100)]
	print(my_list)  
	$ /bin/python3.11 /home/david/Документы/test/test.py
	[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
	[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
	Task:
	При помощи генератора-списка создайте список [1, 2, 3, ..., n], само натуральное число n будет поступать на вход вашей программе.
	В качестве ответа просто выведите получившийся список.
	Decision:
	$ cat /home/david/Документы/test/test.py            
	n = int(input())
	lst = [i for i in range(1, n+1)]
	print(lst)
	$ /bin/python3.11 /home/david/Документы/test/test.py
	10
	[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
	Task:
	На вход программе подается натуральное число n (n<=1000). При помощи генератора списка с условием (list comprehension) создайте список, состоящий из делителей введенного числа.
	Decision:
	$ cat /home/david/Документы/test/test.py            
	n = int(input())
	list_1 = [i for i in range(1, n+1) if n%i == 0]
	print(list_1) 
	$ /bin/python3.11 /home/david/Документы/test/test.py
	9
	[1, 3, 9]
	$ /bin/python3.11 /home/david/Документы/test/test.py
	25
	[1, 5, 25]  

Python, Разработка библиотек
	Task:
	Создание собстенного модуля
	Для выполнения данного задания:
	Создайте файл my_calc.py,
	В этом файле напишите функцию calc_sum, которая на вход принимает два целых числа и возвращает их сумму. Пропишите аннотации к переменным, а также докстринг для функции,
	Загрузите файл во временное сессионное хранилище Google Colab
	Импортируйте файл в ноутбук:
	import my_calc
	Воспользуйтесь вашей функцией для сложения двух чисел: 10 и 5
	Выведите результат на экран
	Decision:
	$ touch /home/david/Документы/test/my_calc.py
	$ cat /home/david/Документы/test/my_calc.py 
	def calc_sum(oper1: int = 20, oper2: int = 30) -> int:
	    """_summary_
	    This method returns sum of 2 input arguments
	    """
	    total_sum = oper1 + oper2
	    return total_sum                                                                                                                
	$ cat /home/david/Документы/test/test.py            
	import my_calc as mc
	print(mc.calc_sum())
	$ /bin/python3.11 /home/david/Документы/test/test.py
	50

